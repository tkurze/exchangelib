<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exchangelib.fields API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exchangelib.fields</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import abc
import datetime
import logging
from contextlib import suppress
from decimal import Decimal, InvalidOperation
from importlib import import_module

from .errors import InvalidTypeError
from .ewsdatetime import UTC, EWSDate, EWSDateTime, EWSTimeZone, NaiveDateTimeNotAllowed, UnknownTimeZone
from .util import (
    TNS,
    create_element,
    get_xml_attr,
    get_xml_attrs,
    is_iterable,
    set_xml_value,
    value_to_xml_text,
    xml_text_to_value,
)
from .version import EXCHANGE_2013, SupportedVersionInstanceMixIn

log = logging.getLogger(__name__)


# DayOfWeekIndex enum. See
# https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/dayofweekindex
FIRST = &#34;First&#34;
SECOND = &#34;Second&#34;
THIRD = &#34;Third&#34;
FOURTH = &#34;Fourth&#34;
LAST = &#34;Last&#34;
WEEK_NUMBERS = (FIRST, SECOND, THIRD, FOURTH, LAST)

# Month enum
JANUARY = &#34;January&#34;
FEBRUARY = &#34;February&#34;
MARCH = &#34;March&#34;
APRIL = &#34;April&#34;
MAY = &#34;May&#34;
JUNE = &#34;June&#34;
JULY = &#34;July&#34;
AUGUST = &#34;August&#34;
SEPTEMBER = &#34;September&#34;
OCTOBER = &#34;October&#34;
NOVEMBER = &#34;November&#34;
DECEMBER = &#34;December&#34;
MONTHS = (JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER)

# Weekday enum
MONDAY = &#34;Monday&#34;
TUESDAY = &#34;Tuesday&#34;
WEDNESDAY = &#34;Wednesday&#34;
THURSDAY = &#34;Thursday&#34;
FRIDAY = &#34;Friday&#34;
SATURDAY = &#34;Saturday&#34;
SUNDAY = &#34;Sunday&#34;
WEEKDAY_NAMES = (MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY)

# Used for weekday recurrences except weekly recurrences. E.g. for &#34;First WeekendDay in March&#34;
DAY = &#34;Day&#34;
WEEK_DAY = &#34;Weekday&#34;  # Non-weekend day
WEEKEND_DAY = &#34;WeekendDay&#34;
EXTRA_WEEKDAY_OPTIONS = (DAY, WEEK_DAY, WEEKEND_DAY)

# DaysOfWeek enum: See
# https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/daysofweek-daysofweektype
WEEKDAYS = WEEKDAY_NAMES + EXTRA_WEEKDAY_OPTIONS


class InvalidField(ValueError):
    &#34;&#34;&#34;Used when a field name does not match any defined fields.&#34;&#34;&#34;


class InvalidFieldForVersion(ValueError):
    &#34;&#34;&#34;Used when a field is not supported on the given Exchange version.&#34;&#34;&#34;


class InvalidChoiceForVersion(ValueError):
    &#34;&#34;&#34;Used when a value is not valid for an enum-type field.&#34;&#34;&#34;


def split_field_path(field_path):
    &#34;&#34;&#34;Split a string path into its field, label and subfield parts.

    :param field_path:

    :return Examples:
      &#39;start&#39; -&gt; (&#39;start&#39;, None, None)
      &#39;phone_numbers__PrimaryPhone&#39; -&gt; (&#39;phone_numbers&#39;, &#39;PrimaryPhone&#39;, None)
      &#39;physical_addresses__Home__street&#39; -&gt; (&#39;physical_addresses&#39;, &#39;Home&#39;, &#39;street&#39;)
    &#34;&#34;&#34;
    if not isinstance(field_path, str):
        raise InvalidTypeError(&#34;field_path&#34;, field_path, str)
    search_parts = field_path.split(&#34;__&#34;)
    field = search_parts[0]
    try:
        label = search_parts[1]
    except IndexError:
        label = None
    try:
        subfield = search_parts[2]
    except IndexError:
        subfield = None
    return field, label, subfield


def resolve_field_path(field_path, folder, strict=True):
    &#34;&#34;&#34;Take the name of a field, or &#39;__&#39;-delimited path to a subfield, and return the corresponding Field object,
    label and SubField object.
    &#34;&#34;&#34;
    from .indexed_properties import MultiFieldIndexedElement, SingleFieldIndexedElement

    fieldname, label, subfield_name = split_field_path(field_path)
    field = folder.get_item_field_by_fieldname(fieldname)
    subfield = None
    if isinstance(field, IndexedField):
        if strict and not label:
            raise ValueError(
                f&#34;IndexedField path {field_path!r} must specify label, e.g. &#34;
                f&#34;&#39;{fieldname}__{field.value_cls.get_field_by_fieldname(&#39;label&#39;).default}&#39;&#34;
            )
        valid_labels = field.value_cls.get_field_by_fieldname(&#34;label&#34;).supported_choices(version=folder.account.version)
        if label and label not in valid_labels:
            raise ValueError(
                f&#34;Label {label!r} on IndexedField path {field_path!r} must be one of {sorted(valid_labels)}&#34;
            )
        if issubclass(field.value_cls, MultiFieldIndexedElement):
            if strict and not subfield_name:
                raise ValueError(
                    f&#34;IndexedField path {field_path!r} must specify subfield, e.g. &#34;
                    f&#34;&#39;{fieldname}__{label}__{field.value_cls.FIELDS[1].name}&#39;&#34;
                )

            if subfield_name:
                try:
                    subfield = field.value_cls.get_field_by_fieldname(subfield_name)
                except ValueError:
                    field_names = &#34;, &#34;.join(
                        f.name for f in field.value_cls.supported_fields(version=folder.account.version)
                    )
                    raise ValueError(
                        f&#34;Subfield {subfield_name!r} on IndexedField path {field_path!r} &#34;
                        f&#34;must be one of {sorted(field_names)}&#34;
                    )
        else:
            if not issubclass(field.value_cls, SingleFieldIndexedElement):
                raise InvalidTypeError(&#34;field.value_cls&#34;, field.value_cls, SingleFieldIndexedElement)
            if subfield_name:
                raise ValueError(
                    f&#34;IndexedField path {field_path!r} must not specify subfield, e.g. just {fieldname}__{label}&#39;&#34;
                )
            subfield = field.value_cls.value_field(version=folder.account.version)
    else:
        if label or subfield_name:
            raise ValueError(f&#34;Field path {field_path!r} must not specify label or subfield, e.g. just {fieldname!r}&#34;)
    return field, label, subfield


class FieldPath:
    &#34;&#34;&#34;Holds values needed to point to a single field. For indexed properties, we allow setting either field,
    field and label, or field, label and subfield. This allows pointing to either the full indexed property set, a
    property with a specific label, or a particular subfield field on that property.
    &#34;&#34;&#34;

    def __init__(self, field, label=None, subfield=None):
        &#34;&#34;&#34;

        :param field: A FieldURIField or ExtendedPropertyField instance
        :param label: a str
        :param subfield: A SubField instance
        &#34;&#34;&#34;
        # &#39;label&#39; and &#39;subfield&#39; are only used for IndexedField fields
        self.field = field
        self.label = label
        self.subfield = subfield

    @classmethod
    def from_string(cls, field_path, folder, strict=False):
        field, label, subfield = resolve_field_path(field_path, folder=folder, strict=strict)
        return cls(field=field, label=label, subfield=subfield)

    def get_value(self, item):
        # For indexed properties, get either the full property set, the property with matching label, or a particular
        # subfield.
        if self.label:
            for sub_item in getattr(item, self.field.name):
                if sub_item.label == self.label:
                    if self.subfield:
                        return getattr(sub_item, self.subfield.name)
                    return sub_item
            return None  # No item with this label
        return getattr(item, self.field.name)

    def get_sort_value(self, item):
        # For fields that allow values of different types, we need to return a value that is
        val = self.get_value(item)
        if isinstance(self.field, DateOrDateTimeField) and isinstance(val, EWSDate):
            return item.date_to_datetime(field_name=self.field.name)
        return val

    def to_xml(self):
        if isinstance(self.field, IndexedField):
            if not self.label or not self.subfield:
                raise ValueError(f&#34;Field path for indexed field {self.field.name!r} is missing label and/or subfield&#34;)
            return self.subfield.field_uri_xml(field_uri=self.field.field_uri, label=self.label)
        return self.field.field_uri_xml()

    def expand(self, version):
        # If this path does not point to a specific subfield on an indexed property, return all the possible path
        # combinations for this field path.
        if isinstance(self.field, IndexedField):
            labels = (
                [self.label]
                if self.label
                else self.field.value_cls.get_field_by_fieldname(&#34;label&#34;).supported_choices(version=version)
            )
            subfields = [self.subfield] if self.subfield else self.field.value_cls.supported_fields(version=version)
            for label in labels:
                for subfield in subfields:
                    yield FieldPath(field=self.field, label=label, subfield=subfield)
        else:
            yield self

    @property
    def path(self):
        if self.label:
            from .indexed_properties import SingleFieldIndexedElement

            if issubclass(self.field.value_cls, SingleFieldIndexedElement) or not self.subfield:
                return f&#34;{self.field.name}__{self.label}&#34;
            return f&#34;{self.field.name}__{self.label}__{self.subfield.name}&#34;
        return self.field.name

    def __eq__(self, other):
        return hash(self) == hash(other)

    def __str__(self):
        return self.path

    def __repr__(self):
        return self.__class__.__name__ + repr((self.field, self.label, self.subfield))

    def __hash__(self):
        return hash((self.field, self.label, self.subfield))


class FieldOrder:
    &#34;&#34;&#34;Holds values needed to call server-side sorting on a single field path.&#34;&#34;&#34;

    def __init__(self, field_path, reverse=False):
        &#34;&#34;&#34;

        :param field_path: A FieldPath instance
        :param reverse: A bool
        &#34;&#34;&#34;
        self.field_path = field_path
        self.reverse = reverse

    @classmethod
    def from_string(cls, field_path, folder):
        return cls(
            field_path=FieldPath.from_string(field_path=field_path.lstrip(&#34;-&#34;), folder=folder, strict=True),
            reverse=field_path.startswith(&#34;-&#34;),
        )

    def to_xml(self):
        field_order = create_element(&#34;t:FieldOrder&#34;, attrs=dict(Order=&#34;Descending&#34; if self.reverse else &#34;Ascending&#34;))
        field_order.append(self.field_path.to_xml())
        return field_order


class Field(SupportedVersionInstanceMixIn, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Holds information related to an item field.&#34;&#34;&#34;

    value_cls = None
    is_list = False
    # Is the field a complex EWS type? Quoting the EWS FindItem docs:
    #
    #   The FindItem operation returns only the first 512 bytes of any streamable property. For Unicode, it returns
    #   the first 255 characters by using a null-terminated Unicode string. It does not return any of the message
    #   body formats or the recipient lists.
    #
    is_complex = False

    def __init__(
        self,
        name=None,
        is_required=False,
        is_required_after_save=False,
        is_read_only=False,
        is_read_only_after_send=False,
        is_searchable=True,
        is_attribute=False,
        default=None,
        *args,
        **kwargs,
    ):
        self.name = name  # Usually set by the EWSMeta metaclass
        self.default = default  # Default value if none is given
        self.is_required = is_required
        # Some fields cannot be deleted on update. Default to True if &#39;is_required&#39; is set
        self.is_required_after_save = is_required or is_required_after_save
        self.is_read_only = is_read_only
        # Set this for fields that raise ErrorInvalidPropertyUpdateSentMessage on update after send. Default to True
        # if &#39;is_read_only&#39; is set
        self.is_read_only_after_send = is_read_only or is_read_only_after_send
        # Define whether the field can be used in a QuerySet. For some reason, EWS disallows searching on some fields,
        # instead throwing ErrorInvalidValueForProperty
        self.is_searchable = is_searchable
        # When true, this field is treated as an XML attribute instead of an element
        self.is_attribute = is_attribute
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if version and not self.supports_version(version):
            raise InvalidFieldForVersion(
                f&#34;Field {self.name!r} does not support EWS builds prior to {self.supported_from} (server has {version})&#34;
            )
        if value is None:
            if self.is_required and self.default is None:
                raise ValueError(f&#34;{self.name!r} is a required field with no default&#34;)
            return self.default
        if self.is_list:
            if not is_iterable(value):
                raise TypeError(f&#34;Field {self.name!r} value {value!r} must be of type {list}&#34;)
            for v in value:
                if not isinstance(v, self.value_cls):
                    raise TypeError(f&#34;Field {self.name!r} value {v!r} must be of type {self.value_cls}&#34;)
                if hasattr(v, &#34;clean&#34;):
                    v.clean(version=version)
        else:
            if not isinstance(value, self.value_cls):
                raise TypeError(f&#34;Field {self.name!r} value {value!r} must be of type {self.value_cls}&#34;)
            if hasattr(value, &#34;clean&#34;):
                value.clean(version=version)
        return value

    @abc.abstractmethod
    def from_xml(self, elem, account):
        &#34;&#34;&#34;Read a value from the given element&#34;&#34;&#34;

    @abc.abstractmethod
    def to_xml(self, value, version):
        &#34;&#34;&#34;Convert this field to an XML element&#34;&#34;&#34;

    def __eq__(self, other):
        return hash(self) == hash(other)

    @abc.abstractmethod
    def __hash__(self):
        &#34;&#34;&#34;Field instances must be hashable&#34;&#34;&#34;

    def __repr__(self):
        args_str = &#34;, &#34;.join(
            f&#34;{f}={getattr(self, f)!r}&#34; for f in (&#34;name&#34;, &#34;value_cls&#34;, &#34;is_list&#34;, &#34;is_complex&#34;, &#34;default&#34;)
        )
        return f&#34;{self.__class__.__name__}({args_str})&#34;


class FieldURIField(Field):
    &#34;&#34;&#34;A field that has a FieldURI value in EWS. This means it&#39;s value is contained in an XML element or attribute. It
    may additionally be a label for searching, filtering and limiting fields. In that case, the FieldURI format will be
    &#39;itemtype:FieldName&#39;
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.field_uri = kwargs.pop(&#34;field_uri&#34;, None)
        self.namespace = kwargs.pop(&#34;namespace&#34;, TNS)
        super().__init__(*args, **kwargs)
        # See all valid FieldURI values at
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/fielduri
        # The field_uri has a prefix when the FieldURI points to an Item field.
        if self.field_uri is None:
            self.field_uri_postfix = None
        elif &#34;:&#34; in self.field_uri:
            self.field_uri_postfix = self.field_uri.split(&#34;:&#34;)[1]
        else:
            self.field_uri_postfix = self.field_uri

    def _get_val_from_elem(self, elem):
        if self.is_attribute:
            return elem.get(self.field_uri) or None
        return get_xml_attr(elem, self.response_tag())

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None:
            try:
                return xml_text_to_value(val, self.value_cls)
            except (ValueError, InvalidOperation):
                log.warning(&#34;Cannot convert value &#39;%s&#39; on field &#39;%s&#39; to type %s&#34;, val, self.name, self.value_cls)
                return None
        return self.default

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        return set_xml_value(field_elem, value, version=version)

    def field_uri_xml(self):
        from .properties import FieldURI

        if not self.field_uri:
            raise ValueError(f&#34;&#39;field_uri&#39; value is missing on field &#39;{self.name}&#39;&#34;)
        return FieldURI(field_uri=self.field_uri).to_xml(version=None)

    def request_tag(self):
        if not self.field_uri_postfix:
            raise ValueError(f&#34;&#39;field_uri_postfix&#39; value is missing on field &#39;{self.name}&#39;&#34;)
        return f&#34;t:{self.field_uri_postfix}&#34;

    def response_tag(self):
        if not self.field_uri_postfix:
            raise ValueError(f&#34;&#39;field_uri_postfix&#39; value is missing on field &#39;{self.name}&#39;&#34;)
        return f&#34;{{{self.namespace}}}{self.field_uri_postfix}&#34;

    def __hash__(self):
        return hash(self.field_uri)


class BooleanField(FieldURIField):
    &#34;&#34;&#34;A field that handles boolean values.&#34;&#34;&#34;

    value_cls = bool


class IntegerField(FieldURIField):
    &#34;&#34;&#34;A field that handles integer values.&#34;&#34;&#34;

    value_cls = int

    def __init__(self, *args, **kwargs):
        self.min = kwargs.pop(&#34;min&#34;, None)
        self.max = kwargs.pop(&#34;max&#34;, None)
        super().__init__(*args, **kwargs)

    def _clean_single_value(self, v):
        if self.min is not None and v &lt; self.min:
            raise ValueError(f&#34;Value {v!r} on field {self.name!r} must be greater than {self.min}&#34;)
        if self.max is not None and v &gt; self.max:
            raise ValueError(f&#34;Value {v!r} on field {self.name!r} must be less than {self.max}&#34;)

    def clean(self, value, version=None):
        value = super().clean(value, version=version)
        if value is not None:
            if self.is_list:
                for v in value:
                    self._clean_single_value(v)
            else:
                self._clean_single_value(value)
        return value


class DecimalField(IntegerField):
    &#34;&#34;&#34;A field that handles decimal values.&#34;&#34;&#34;

    value_cls = Decimal


class EnumField(IntegerField):
    &#34;&#34;&#34;A field type where you can enter either the 1-based index in an enum (tuple), or the enum value. Values will be
    stored internally as integers but output in XML as strings.
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.enum = kwargs.pop(&#34;enum&#34;)
        # Set different min/max defaults than IntegerField
        if &#34;max&#34; in kwargs:
            raise AttributeError(&#34;EnumField does not support the &#39;max&#39; attribute&#34;)
        kwargs[&#34;min&#34;] = kwargs.pop(&#34;min&#34;, 1)
        kwargs[&#34;max&#34;] = kwargs[&#34;min&#34;] + len(self.enum) - 1
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if self.is_list:
            value = list(value)  # Convert to something we can index
            for i, v in enumerate(value):
                if isinstance(v, str):
                    if v not in self.enum:
                        raise ValueError(f&#34;List value {v!r} on field {self.name!r} must be one of {sorted(self.enum)}&#34;)
                    value[i] = self.enum.index(v) + 1
            if not value:
                raise ValueError(f&#34;Value {value!r} on field {self.name!r} must not be empty&#34;)
            if len(value) &gt; len(set(value)):
                raise ValueError(f&#34;List entries {value!r} on field {self.name!r} must be unique&#34;)
        else:
            if isinstance(value, str):
                if value not in self.enum:
                    raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be one of {sorted(self.enum)}&#34;)
                value = self.enum.index(value) + 1
        return super().clean(value, version=version)

    def as_string(self, value):
        # Converts an integer in the enum to its equivalent string
        if self.is_list:
            return [self.enum[v - 1] for v in sorted(value)]
        return self.enum[value - 1]

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None:
            try:
                if self.is_list:
                    return [self.enum.index(v) + 1 for v in val.split(&#34; &#34;)]
                return self.enum.index(val) + 1
            except ValueError:
                log.warning(&#34;Cannot convert value &#39;%s&#39; on field &#39;%s&#39; to type %s&#34;, val, self.name, self.value_cls)
                return None
        return self.default

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        if self.is_list:
            return set_xml_value(field_elem, &#34; &#34;.join(self.as_string(value)), version=version)
        return set_xml_value(field_elem, self.as_string(value), version=version)


class EnumListField(EnumField):
    &#34;&#34;&#34;Like EnumField, but for lists of enum values.&#34;&#34;&#34;

    is_list = True


class WeekdaysField(EnumListField):
    &#34;&#34;&#34;Like EnumListField, allow a single value instead of a 1-element list.&#34;&#34;&#34;

    def clean(self, value, version=None):
        if isinstance(value, (int, str)):
            value = [value]
        return super().clean(value, version)


class EnumAsIntField(EnumField):
    &#34;&#34;&#34;Like EnumField, but communicates values with EWS in integers.&#34;&#34;&#34;

    def from_xml(self, elem, account):
        return super(EnumField, self).from_xml(elem=elem, account=account)

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        return set_xml_value(field_elem, value, version=version)


class AppointmentStateField(IntegerField):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/appointmentstate&#34;&#34;&#34;

    NONE = &#34;None&#34;
    MEETING = &#34;Meeting&#34;
    RECEIVED = &#34;Received&#34;
    CANCELLED = &#34;Canceled&#34;
    STATES = {
        NONE: 0x0000,
        MEETING: 0x0001,
        RECEIVED: 0x0002,
        CANCELLED: 0x0004,
    }

    def from_xml(self, elem, account):
        val = super().from_xml(elem=elem, account=account)
        if val is None:
            return val
        return tuple(name for name, mask in self.STATES.items() if bool(val &amp; mask))


class Base64Field(FieldURIField):
    &#34;&#34;&#34;A field that handles binary data and automatically Base64 encodes and decodes the data.&#34;&#34;&#34;

    value_cls = bytes
    is_complex = True

    def __init__(self, *args, **kwargs):
        if &#34;is_searchable&#34; not in kwargs:
            kwargs[&#34;is_searchable&#34;] = False
        super().__init__(*args, **kwargs)


class MimeContentField(Base64Field):
    &#34;&#34;&#34;Like Base64Field. This element has an optional &#39;CharacterSet&#39; attribute, but it specifies the encoding of the
    base64-encoded string (which doesn&#39;t make sense since base64-encoded strings are always ASCII). We ignore it here
    because the decoded data could be in some other encoding, specified in the &#34;Content-Type&#34; HTTP header.
    &#34;&#34;&#34;


class DateField(FieldURIField):
    &#34;&#34;&#34;A field that handles date values.&#34;&#34;&#34;

    value_cls = EWSDate

    def clean(self, value, version=None):
        # Allow plain datetime.date values as input
        if type(value) is datetime.date:
            value = self.value_cls.from_date(value)
        return super().clean(value=value, version=version)


class DateTimeBackedDateField(DateField):
    &#34;&#34;&#34;A field that acts like a date, but where values are sent to EWS as EWSDateTime.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        # Not all fields assume a default time of 00:00, so make this configurable
        self._default_time = kwargs.pop(&#34;default_time&#34;, datetime.time(0, 0))
        super().__init__(*args, **kwargs)
        # Create internal field to handle datetime-only logic
        self._datetime_field = DateTimeField(*args, **kwargs)

    def date_to_datetime(self, value):
        return self._datetime_field.value_cls.combine(value, self._default_time).replace(tzinfo=UTC)

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None and len(val) == 25:
            # This is a datetime string with timezone info, e.g. &#39;2021-03-01T21:55:54+00:00&#39;. We don&#39;t want to have
            # datetime values converted to UTC before converting to date. EWSDateTime.from_string() insists on
            # converting to UTC, but we don&#39;t have an EWSTimeZone we can convert the timezone info to. Instead, parse
            # the string with .fromisoformat().
            return datetime.datetime.fromisoformat(val).date()
        # Revert to default parsing of datetime strings
        res = self._datetime_field.from_xml(elem=elem, account=account)
        if res is None:
            return res
        return res.date()

    def to_xml(self, value, version):
        # Convert date to datetime
        value = self.date_to_datetime(value)
        return self._datetime_field.to_xml(value=value, version=version)


class TimeField(FieldURIField):
    &#34;&#34;&#34;A field that handles time values.&#34;&#34;&#34;

    value_cls = datetime.time

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None:
            with suppress(ValueError):
                if &#34;:&#34; in val:
                    # Assume a string of the form HH:MM:SS
                    return datetime.datetime.strptime(val, &#34;%H:%M:%S&#34;).time()
                # Assume an integer in minutes since midnight
                return (datetime.datetime(2000, 1, 1) + datetime.timedelta(minutes=int(val))).time()
        return self.default


class TimeDeltaField(FieldURIField):
    &#34;&#34;&#34;A field that handles timedelta values.&#34;&#34;&#34;

    value_cls = datetime.timedelta

    def __init__(self, *args, **kwargs):
        self.min = kwargs.pop(&#34;min&#34;, datetime.timedelta(0))
        self.max = kwargs.pop(&#34;max&#34;, datetime.timedelta(days=1))
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if self.min is not None and value &lt; self.min:
            raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be greater than {self.min}&#34;)
        if self.max is not None and value &gt; self.max:
            raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be less than {self.max}&#34;)
        return super().clean(value, version=version)


class DateTimeField(FieldURIField):
    &#34;&#34;&#34;A field that handles datetime values.&#34;&#34;&#34;

    value_cls = EWSDateTime

    def clean(self, value, version=None):
        if isinstance(value, datetime.datetime):
            if not value.tzinfo:
                raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be timezone aware&#34;)
            if type(value) is datetime.datetime:
                value = self.value_cls.from_datetime(value)
        return super().clean(value, version=version)

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None:
            try:
                return self.value_cls.from_string(val)
            except ValueError as e:
                if isinstance(e, NaiveDateTimeNotAllowed):
                    # We encountered a naive datetime
                    if account:
                        # Convert to timezone-aware datetime using the default timezone of the account
                        tz = account.default_timezone
                        log.info(&#34;Found naive datetime %s on field %s. Assuming timezone %s&#34;, e.local_dt, self.name, tz)
                        return e.local_dt.replace(tzinfo=tz)
                    # There&#39;s nothing we can do but return the naive date. It&#39;s better than assuming e.g. UTC.
                    log.warning(&#34;Returning naive datetime %s on field %s&#34;, e.local_dt, self.name)
                    return e.local_dt
                log.info(&#34;Cannot convert value &#39;%s&#39; on field &#39;%s&#39; to type %s&#34;, val, self.name, self.value_cls)
                return None
        return self.default


class DateOrDateTimeField(DateTimeField):
    &#34;&#34;&#34;This field can handle both EWSDate and EWSDateTime. Used for calendar items where &#39;start&#39; and &#39;end&#39;
    values are conceptually dates when the calendar item is an all-day event, but datetimes in all other cases, and
    for recurrences where the returned &#39;start&#39; and &#39;end&#39; values may be either dates or datetimes depending on whether
    the recurring item is a task or a calendar item.

    For all-day calendar items, we assume both start and end dates are inclusive.

    For filtering kwarg validation and other places where we must decide on a specific class, we settle on datetime.
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Create internal field to handle date-only logic
        self._date_field = DateField(*args, **kwargs)

    def clean(self, value, version=None):
        # Most calendar items will contain datetime values. We can&#39;t access the is_all_day value here, so CalendarItem
        # must handle that sanity check.
        if type(value) in (EWSDate, datetime.date):
            return self._date_field.clean(value=value, version=version)
        return super().clean(value=value, version=version)

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None and len(val) == 16:
            # This is a date format with timezone info, as sent by task recurrences. Eg: &#39;2006-01-09+01:00&#39;
            return self._date_field.from_xml(elem=elem, account=account)
        return super().from_xml(elem=elem, account=account)


class TimeZoneField(FieldURIField):
    &#34;&#34;&#34;A field that handles timezone values.&#34;&#34;&#34;

    value_cls = EWSTimeZone

    def clean(self, value, version=None):
        # Allow other timezone implementations as input
        if value is not None:
            value = self.value_cls.from_timezone(value)
        return super().clean(value=value, version=version)

    def from_xml(self, elem, account):
        field_elem = elem.find(self.response_tag())
        if field_elem is not None:
            ms_id = field_elem.get(&#34;Id&#34;)
            ms_name = field_elem.get(&#34;Name&#34;)
            try:
                return self.value_cls.from_ms_id(ms_id or ms_name)
            except UnknownTimeZone:
                log.warning(
                    &#34;Cannot convert value &#39;%s&#39; on field &#39;%s&#39; to type %s (unknown timezone ID)&#34;,
                    (ms_id or ms_name),
                    self.name,
                    self.value_cls,
                )
                return None
        return self.default

    def to_xml(self, value, version):
        attrs = dict(Id=value.ms_id)
        if value.ms_name:
            attrs[&#34;Name&#34;] = value.ms_name
        return create_element(self.request_tag(), attrs=attrs)


class TextField(FieldURIField):
    &#34;&#34;&#34;A field that stores a string value with no length limit.&#34;&#34;&#34;

    value_cls = str
    is_complex = True


class TextListField(TextField):
    &#34;&#34;&#34;Like TextField, but for lists of text.&#34;&#34;&#34;

    is_list = True

    def __init__(self, *args, **kwargs):
        self.list_elem_name = kwargs.pop(&#34;list_elem_name&#34;, &#34;String&#34;)
        super().__init__(*args, **kwargs)

    def list_elem_request_tag(self):
        return f&#34;t:{self.list_elem_name}&#34;

    def list_elem_response_tag(self):
        return f&#34;{{{self.namespace}}}{self.list_elem_name}&#34;

    def from_xml(self, elem, account):
        iter_elem = elem.find(self.response_tag())
        if iter_elem is not None:
            return get_xml_attrs(iter_elem, self.list_elem_response_tag())
        return self.default

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        for v in value:
            field_elem.append(set_xml_value(create_element(self.list_elem_request_tag()), v, version=version))
        return field_elem


class MessageField(TextField):
    &#34;&#34;&#34;A field that handles the Message element.&#34;&#34;&#34;

    INNER_ELEMENT_NAME = &#34;Message&#34;

    def from_xml(self, elem, account):
        reply = elem.find(self.response_tag())
        if reply is None:
            return None
        message = reply.find(f&#34;{{{TNS}}}{self.INNER_ELEMENT_NAME}&#34;)
        if message is None:
            return None
        return message.text

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        message = create_element(f&#34;t:{self.INNER_ELEMENT_NAME}&#34;)
        message.text = value
        return set_xml_value(field_elem, message, version=version)


class CharField(TextField):
    &#34;&#34;&#34;A field that stores a string value with a limited length.&#34;&#34;&#34;

    is_complex = False

    def __init__(self, *args, **kwargs):
        self.max_length = kwargs.pop(&#34;max_length&#34;, 255)
        if not 1 &lt;= self.max_length &lt;= 255:
            # A field supporting messages longer than 255 chars should be TextField
            raise ValueError(&#34;&#39;max_length&#39; must be in the range 1-255&#34;)
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        value = super().clean(value, version=version)
        if value is not None and len(value) &gt; self.max_length:
            raise ValueError(f&#34;{self.name!r} value {value!r} exceeds length {self.max_length}&#34;)
        return value


class IdField(CharField):
    &#34;&#34;&#34;A field to hold the &#39;Id&#39; and &#39;Changekey&#39; attributes on &#39;ItemId&#39; type items. There is no guaranteed max length,
    but we can assume 512 bytes in practice. See
    https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/ews-identifiers-in-exchange
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.max_length = 512  # This is above the normal 255 limit, but this is actually an attribute, not a field
        self.is_searchable = False
        self.is_attribute = True


class CharListField(TextListField):
    &#34;&#34;&#34;Like TextListField, but for string values with a limited length.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.max_length = kwargs.pop(&#34;max_length&#34;, 255)
        if not 1 &lt;= self.max_length &lt;= 255:
            # A field supporting messages longer than 255 chars should be TextField
            raise ValueError(&#34;&#39;max_length&#39; must be in the range 1-255&#34;)
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        value = super().clean(value, version=version)
        if value is not None:
            for v in value:
                if len(v) &gt; self.max_length:
                    raise ValueError(f&#34;{self.name!r} value {v!r} exceeds length {self.max_length}&#34;)
        return value


class URIField(TextField):
    &#34;&#34;&#34;Helper to mark strings that must conform to xsd:anyURI.
    If we want a URI validator, see https://stackoverflow.com/questions/14466585/is-this-regex-correct-for-xsdanyuri
    &#34;&#34;&#34;


class EmailAddressField(CharField):
    &#34;&#34;&#34;A helper class used for email address string that we can use for email validation.&#34;&#34;&#34;


class CultureField(CharField):
    &#34;&#34;&#34;Helper to mark strings that are # RFC 1766 culture values.&#34;&#34;&#34;


class Choice(SupportedVersionInstanceMixIn):
    &#34;&#34;&#34;Implement versioned choices for the ChoiceField field.&#34;&#34;&#34;

    def __init__(self, value, *args, **kwargs):
        self.value = value
        super().__init__(*args, **kwargs)


class ChoiceField(CharField):
    &#34;&#34;&#34;Like CharField, but restricts the value to a limited set of strings.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.choices = kwargs.pop(&#34;choices&#34;)
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        value = super().clean(value, version=version)
        if value is None:
            return None
        valid_choices = [c.value for c in self.choices]
        if version:
            valid_choices_for_version = self.supported_choices(version=version)
            if value in valid_choices_for_version:
                return value
            if value in valid_choices:
                raise InvalidChoiceForVersion(
                    f&#34;Choice {self.name!r} only supports server versions from {self.supported_from or &#39;*&#39;} to &#34;
                    f&#34;{self.deprecated_from or &#39;*&#39;} (server has {version})&#34;
                )
        else:
            if value in valid_choices:
                return value
        raise ValueError(f&#34;Invalid choice {value!r} for field {self.name!r}. Valid choices are {sorted(valid_choices)}&#34;)

    def supported_choices(self, version):
        return tuple(c.value for c in self.choices if c.supports_version(version))


FREE_BUSY_CHOICES = [
    Choice(&#34;Free&#34;),
    Choice(&#34;Tentative&#34;),
    Choice(&#34;Busy&#34;),
    Choice(&#34;OOF&#34;),
    Choice(&#34;NoData&#34;),
    Choice(&#34;WorkingElsewhere&#34;, supported_from=EXCHANGE_2013),
]


class FreeBusyStatusField(ChoiceField):
    &#34;&#34;&#34;Like ChoiceField, but specifically for Free/Busy values.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        kwargs[&#34;choices&#34;] = set(FREE_BUSY_CHOICES)
        super().__init__(*args, **kwargs)


class BodyField(TextField):
    &#34;&#34;&#34;A TextField with specific requirements for the Item body.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        from .properties import Body

        self.value_cls = Body
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if value is not None and not isinstance(value, self.value_cls):
            value = self.value_cls(value)
        return super().clean(value, version=version)

    def from_xml(self, elem, account):
        from .properties import Body, HTMLBody

        field_elem = elem.find(self.response_tag())
        val = None if field_elem is None else field_elem.text or None
        if val is not None:
            body_type = field_elem.get(&#34;BodyType&#34;)
            return {Body.body_type: Body, HTMLBody.body_type: HTMLBody}[body_type](val)
        return self.default

    def to_xml(self, value, version):
        from .properties import Body, HTMLBody

        body_type = {
            Body: Body.body_type,
            HTMLBody: HTMLBody.body_type,
        }[type(value)]
        field_elem = create_element(self.request_tag(), attrs=dict(BodyType=body_type))
        return set_xml_value(field_elem, value, version=version)


class EWSElementField(FieldURIField):
    &#34;&#34;&#34;A generic field for any EWSElement object.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self._value_cls = kwargs.pop(&#34;value_cls&#34;)
        if &#34;namespace&#34; not in kwargs:
            kwargs[&#34;namespace&#34;] = self.value_cls.NAMESPACE
        super().__init__(*args, **kwargs)

    @property
    def value_cls(self):
        if isinstance(self._value_cls, str):
            # Support &#39;value_cls&#39; as string to allow self-referencing classes. The class must be importable from the
            # top-level module.
            self._value_cls = getattr(import_module(self.__module__.split(&#34;.&#34;)[0]), self._value_cls)
        return self._value_cls

    def from_xml(self, elem, account):
        if self.is_list:
            iter_elem = elem.find(self.response_tag())
            if iter_elem is not None:
                return [
                    self.value_cls.from_xml(elem=e, account=account)
                    for e in iter_elem.findall(self.value_cls.response_tag())
                ]
        else:
            if self.field_uri is None:
                sub_elem = elem.find(self.value_cls.response_tag())
            else:
                sub_elem = elem.find(self.response_tag())
            if sub_elem is not None:
                return self.value_cls.from_xml(elem=sub_elem, account=account)
        return self.default

    def to_xml(self, value, version):
        if self.field_uri is None:
            return value.to_xml(version=version)
        field_elem = create_element(self.request_tag())
        return set_xml_value(field_elem, value, version=version)


class EWSElementListField(EWSElementField):
    &#34;&#34;&#34;Like EWSElementField, but for lists of EWSElement objects.&#34;&#34;&#34;

    is_list = True
    is_complex = True


class TransitionListField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import BaseTransition

        kwargs[&#34;value_cls&#34;] = BaseTransition
        super().__init__(*args, **kwargs)

    def from_xml(self, elem, account):
        iter_elem = elem.find(self.response_tag()) if self.field_uri else elem
        if iter_elem is not None:
            return [
                self.value_cls.transition_model_from_tag(e.tag).from_xml(elem=e, account=account) for e in iter_elem
            ]
        return self.default


class AssociatedCalendarItemIdField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .properties import AssociatedCalendarItemId

        kwargs[&#34;value_cls&#34;] = AssociatedCalendarItemId
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return value.to_xml(version=version)


class RecurrenceField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .recurrence import Recurrence

        kwargs[&#34;value_cls&#34;] = Recurrence
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return value.to_xml(version=version)


class TaskRecurrenceField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .recurrence import TaskRecurrence

        kwargs[&#34;value_cls&#34;] = TaskRecurrence
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return value.to_xml(version=version)


class ReferenceItemIdField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .properties import ReferenceItemId

        kwargs[&#34;value_cls&#34;] = ReferenceItemId
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return value.to_xml(version=version)


class OccurrenceField(EWSElementField):
    is_complex = True


class OccurrenceListField(OccurrenceField):
    is_list = True


class MessageHeaderField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import MessageHeader

        kwargs[&#34;value_cls&#34;] = MessageHeader
        super().__init__(*args, **kwargs)


class BaseEmailField(EWSElementField, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base class for EWSElement classes that have an &#39;email_address&#39; field that we want to provide helpers for.&#34;&#34;&#34;

    is_complex = True  # FindItem only returns the name, not the email address

    def clean(self, value, version=None):
        if isinstance(value, str):
            value = self.value_cls(email_address=value)
        return super().clean(value, version=version)

    def from_xml(self, elem, account):
        if self.field_uri is None:
            sub_elem = elem.find(self.value_cls.response_tag())
        else:
            sub_elem = elem.find(self.response_tag())
        if sub_elem is not None:
            if self.field_uri is not None:
                # We want the nested Mailbox, not the wrapper element
                nested_elem = sub_elem.find(self.value_cls.response_tag())
                if nested_elem is None:
                    raise ValueError(
                        f&#34;Expected XML element {self.value_cls.response_tag()!r} missing on field {self.name!r}&#34;
                    )
                return self.value_cls.from_xml(elem=nested_elem, account=account)
            return self.value_cls.from_xml(elem=sub_elem, account=account)
        return self.default


class EmailField(BaseEmailField):
    def __init__(self, *args, **kwargs):
        from .properties import Email

        kwargs[&#34;value_cls&#34;] = Email
        super().__init__(*args, **kwargs)


class RecipientAddressField(BaseEmailField):
    def __init__(self, *args, **kwargs):
        from .properties import RecipientAddress

        kwargs[&#34;value_cls&#34;] = RecipientAddress
        super().__init__(*args, **kwargs)


class MailboxField(BaseEmailField):
    def __init__(self, *args, **kwargs):
        from .properties import Mailbox

        kwargs[&#34;value_cls&#34;] = Mailbox
        super().__init__(*args, **kwargs)


class MailboxListField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import Mailbox

        kwargs[&#34;value_cls&#34;] = Mailbox
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if value is not None:
            value = [self.value_cls(email_address=s) if isinstance(s, str) else s for s in value]
        return super().clean(value, version=version)


class MemberListField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import Member

        kwargs[&#34;value_cls&#34;] = Member
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        from .properties import Mailbox

        if value is not None:
            value = [self.value_cls(mailbox=Mailbox(email_address=s)) if isinstance(s, str) else s for s in value]
        return super().clean(value, version=version)


class AttendeesField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import Attendee

        kwargs[&#34;value_cls&#34;] = Attendee
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        from .properties import Mailbox

        if value is not None:
            value = [
                self.value_cls(mailbox=Mailbox(email_address=s), response_type=&#34;Accept&#34;) if isinstance(s, str) else s
                for s in value
            ]
        return super().clean(value, version=version)


class AttachmentField(EWSElementListField):
    &#34;&#34;&#34;A field for item attachments.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        from .attachments import Attachment

        kwargs[&#34;value_cls&#34;] = Attachment
        super().__init__(*args, **kwargs)

    def from_xml(self, elem, account):
        from .attachments import FileAttachment, ItemAttachment

        iter_elem = elem.find(self.response_tag())
        # Look for both FileAttachment and ItemAttachment
        if iter_elem is not None:
            attachments = []
            for att_type in (ItemAttachment, FileAttachment):
                attachments.extend(
                    [att_type.from_xml(elem=e, account=account) for e in iter_elem.findall(att_type.response_tag())]
                )
            return attachments
        return self.default


class LabelField(ChoiceField):
    &#34;&#34;&#34;A field to hold the label on an IndexedElement.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.is_attribute = True

    def from_xml(self, elem, account):
        return elem.get(self.field_uri)


class SubField(Field):
    &#34;&#34;&#34;A field to hold the value on an IndexedElement.&#34;&#34;&#34;

    namespace = TNS
    value_cls = str

    def from_xml(self, elem, account):
        return elem.text

    def to_xml(self, value, version):
        return value

    @staticmethod
    def field_uri_xml(field_uri, label):
        from .properties import IndexedFieldURI

        return IndexedFieldURI(field_uri=field_uri, field_index=label).to_xml(version=None)

    def clean(self, value, version=None):
        value = super().clean(value, version=version)
        if self.is_required and not value:
            raise ValueError(f&#34;Value for subfield {self.name!r} must be non-empty&#34;)
        return value

    def __hash__(self):
        return hash(self.name)


class EmailSubField(SubField):
    &#34;&#34;&#34;A field to hold the value on an SingleFieldIndexedElement.&#34;&#34;&#34;

    value_cls = str

    def from_xml(self, elem, account):
        return elem.text or elem.get(&#34;Name&#34;)  # Sometimes elem.text is empty. Exchange saves the same in &#39;Name&#39; attr


class NamedSubField(SubField):
    &#34;&#34;&#34;A field to hold the value on an MultiFieldIndexedElement.&#34;&#34;&#34;

    value_cls = str

    def __init__(self, *args, **kwargs):
        self.field_uri = kwargs.pop(&#34;field_uri&#34;)
        if &#34;:&#34; in self.field_uri:
            raise ValueError(&#34;&#39;field_uri&#39; value must not contain a colon&#34;)
        super().__init__(*args, **kwargs)

    def from_xml(self, elem, account):
        field_elem = elem.find(self.response_tag())
        val = None if field_elem is None else field_elem.text or None
        if val is not None:
            return val
        return self.default

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        return set_xml_value(field_elem, value, version=version)

    def field_uri_xml(self, field_uri, label):
        from .properties import IndexedFieldURI

        return IndexedFieldURI(field_uri=f&#34;{field_uri}:{self.field_uri}&#34;, field_index=label).to_xml(version=None)

    def request_tag(self):
        return f&#34;t:{self.field_uri}&#34;

    def response_tag(self):
        return f&#34;{{{self.namespace}}}{self.field_uri}&#34;


class IndexedField(EWSElementField, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;A base class for all indexed fields.&#34;&#34;&#34;

    PARENT_ELEMENT_NAME = None

    def __init__(self, *args, **kwargs):
        from .indexed_properties import IndexedElement

        value_cls = kwargs[&#34;value_cls&#34;]
        if not issubclass(value_cls, IndexedElement):
            raise TypeError(f&#34;&#39;value_cls&#39; {value_cls!r} must be a subclass of type {IndexedElement}&#34;)
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return set_xml_value(create_element(f&#34;t:{self.PARENT_ELEMENT_NAME}&#34;), value, version=version)

    def response_tag(self):
        return f&#34;{{{self.namespace}}}{self.PARENT_ELEMENT_NAME}&#34;

    def __hash__(self):
        return hash(self.field_uri)


class EmailAddressesField(IndexedField):
    is_list = True
    is_complex = True

    PARENT_ELEMENT_NAME = &#34;EmailAddresses&#34;

    def __init__(self, *args, **kwargs):
        from .indexed_properties import EmailAddress

        kwargs[&#34;value_cls&#34;] = EmailAddress
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if value is not None:
            default_labels = self.value_cls.LABEL_CHOICES
            if len(value) &gt; len(default_labels):
                raise ValueError(f&#34;This field can handle at most {len(default_labels)} values (value: {value})&#34;)
            tmp = []
            for s, default_label in zip(value, default_labels):
                if not isinstance(s, str):
                    tmp.append(s)
                    continue
                tmp.append(self.value_cls(email=s, label=default_label))
            value = tmp
        return super().clean(value, version=version)


class PhoneNumberField(IndexedField):
    is_list = True
    is_complex = True

    PARENT_ELEMENT_NAME = &#34;PhoneNumbers&#34;

    def __init__(self, *args, **kwargs):
        from .indexed_properties import PhoneNumber

        kwargs[&#34;value_cls&#34;] = PhoneNumber
        super().__init__(*args, **kwargs)


class PhysicalAddressField(IndexedField):
    is_list = True
    is_complex = True

    PARENT_ELEMENT_NAME = &#34;PhysicalAddresses&#34;

    def __init__(self, *args, **kwargs):
        from .indexed_properties import PhysicalAddress

        kwargs[&#34;value_cls&#34;] = PhysicalAddress
        super().__init__(*args, **kwargs)


class ExtendedPropertyField(Field):
    is_complex = True

    def __init__(self, *args, **kwargs):
        self.value_cls = kwargs.pop(&#34;value_cls&#34;)
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if value is None:
            if self.is_required:
                raise ValueError(f&#34;{self.name!r} is a required field&#34;)
            return self.default
        if not isinstance(value, self.value_cls):
            # Allow keeping ExtendedProperty field values as their simple Python type, but run clean() anyway
            tmp = self.value_cls(value)
            tmp.clean(version=version)
            return value
        value.clean(version=version)
        return value

    def field_uri_xml(self):
        from .properties import ExtendedFieldURI

        cls = self.value_cls
        return ExtendedFieldURI(
            distinguished_property_set_id=cls.distinguished_property_set_id,
            property_set_id=cls.property_set_id.lower() if cls.property_set_id else None,
            property_tag=cls.property_tag_as_hex(),
            property_name=cls.property_name,
            property_id=value_to_xml_text(cls.property_id) if cls.property_id else None,
            property_type=cls.property_type,
        ).to_xml(version=None)

    def from_xml(self, elem, account):
        extended_properties = elem.findall(self.value_cls.response_tag())
        for extended_property in extended_properties:
            if self.value_cls.is_property_instance(extended_property):
                return self.value_cls.from_xml(elem=extended_property, account=account)
        return self.default

    def to_xml(self, value, version):
        extended_property = create_element(self.value_cls.request_tag())
        set_xml_value(extended_property, self.field_uri_xml(), version=version)
        if isinstance(value, self.value_cls):
            return set_xml_value(extended_property, value, version=version)
        # Allow keeping ExtendedProperty field values as their simple Python type
        return set_xml_value(extended_property, self.value_cls(value), version=version)

    def __hash__(self):
        return hash(self.name)


class ExtendedPropertyListField(ExtendedPropertyField):
    is_list = True


class ItemField(FieldURIField):
    @property
    def value_cls(self):
        from .items import Item

        return Item

    def from_xml(self, elem, account):
        from .items import ITEM_CLASSES

        for item_cls in ITEM_CLASSES:
            item_elem = elem.find(item_cls.response_tag())
            if item_elem is not None:
                return item_cls.from_xml(elem=item_elem, account=account)
        return None

    def to_xml(self, value, version):
        # We don&#39;t want to wrap in an Item element
        return value.to_xml(version=version)


class UnknownEntriesField(CharListField):
    def list_elem_tag(self):
        return f&#34;{{{self.namespace}}}UnknownEntry&#34;


class PermissionSetField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .properties import PermissionSet

        kwargs[&#34;value_cls&#34;] = PermissionSet
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return value.to_xml(version=version)


class EffectiveRightsField(EWSElementField):
    def __init__(self, *args, **kwargs):
        from .properties import EffectiveRights

        kwargs[&#34;value_cls&#34;] = EffectiveRights
        super().__init__(*args, **kwargs)


class RoutingTypeField(ChoiceField):
    def __init__(self, *args, **kwargs):
        kwargs[&#34;choices&#34;] = {Choice(&#34;SMTP&#34;), Choice(&#34;EX&#34;)}
        kwargs[&#34;default&#34;] = &#34;SMTP&#34;
        super().__init__(*args, **kwargs)


class IdElementField(EWSElementField):
    def __init__(self, *args, **kwargs):
        kwargs[&#34;is_searchable&#34;] = False
        kwargs[&#34;is_read_only&#34;] = True
        super().__init__(*args, **kwargs)


class TypeValueField(FieldURIField):
    &#34;&#34;&#34;This field type has no value_cls because values may have many types.&#34;&#34;&#34;

    TYPES_MAP = {
        &#34;Boolean&#34;: bool,
        &#34;Integer32&#34;: int,
        &#34;UnsignedInteger32&#34;: int,
        &#34;Integer64&#34;: int,
        &#34;UnsignedInteger64&#34;: int,
        # Python doesn&#39;t have a single-byte type to represent &#39;Byte&#39;
        &#34;ByteArray&#34;: bytes,
        &#34;String&#34;: str,
        &#34;StringArray&#34;: str,  # A list of strings
        &#34;DateTime&#34;: EWSDateTime,
    }
    TYPES_MAP_REVERSED = {
        bool: &#34;Boolean&#34;,
        int: &#34;Integer64&#34;,
        # Python doesn&#39;t have a single-byte type to represent &#39;Byte&#39;
        bytes: &#34;ByteArray&#34;,
        str: &#34;String&#34;,
        datetime.datetime: &#34;DateTime&#34;,
        EWSDateTime: &#34;DateTime&#34;,
    }

    @classmethod
    def get_type(cls, value):
        if isinstance(value, bytes) and len(value) == 1:
            # This is a single byte. Translate it to the &#39;Byte&#39; type
            return &#34;Byte&#34;
        if is_iterable(value):
            # We don&#39;t allow generators as values, so keep the logic simple
            try:
                first = next(iter(value))
            except StopIteration:
                first = None
            value_type = f&#34;{cls.TYPES_MAP_REVERSED[type(first)]}Array&#34;
            if value_type not in cls.TYPES_MAP:
                raise ValueError(f&#34;{value!r} is not a supported type&#34;)
            return value_type
        return cls.TYPES_MAP_REVERSED[type(value)]

    @classmethod
    def is_array_type(cls, value_type):
        return value_type == &#34;StringArray&#34;

    def clean(self, value, version=None):
        if value is None:
            if self.is_required and self.default is None:
                raise ValueError(f&#34;{self.name!r} is a required field with no default&#34;)
            return self.default
        return value

    def from_xml(self, elem, account):
        field_elem = elem.find(self.response_tag())
        if field_elem is None:
            return self.default
        value_type_str = get_xml_attr(field_elem, f&#34;{{{TNS}}}Type&#34;)
        value = get_xml_attr(field_elem, f&#34;{{{TNS}}}Value&#34;)
        if value_type_str == &#34;Byte&#34;:
            try:
                # The value is an unsigned integer in the range 0 -&gt; 255. Convert it to a single byte
                return xml_text_to_value(value, int).to_bytes(1, &#34;little&#34;, signed=False)
            except OverflowError as e:
                log.warning(&#34;Invalid byte value %r (%e)&#34;, value, e)
                return None
        value_type = self.TYPES_MAP[value_type_str]
        if self.is_array_type(value_type_str):
            return tuple(xml_text_to_value(value=v, value_type=value_type) for v in value.split(&#34; &#34;))
        return xml_text_to_value(value=value, value_type=value_type)

    def to_xml(self, value, version):
        value_type_str = self.get_type(value)
        if value_type_str == &#34;Byte&#34;:
            # A single byte is encoded to an unsigned integer in the range 0 -&gt; 255
            value = int.from_bytes(value, byteorder=&#34;little&#34;, signed=False)
        elif is_iterable(value):
            value = &#34; &#34;.join(value_to_xml_text(v) for v in value)
        field_elem = create_element(self.request_tag())
        field_elem.append(set_xml_value(create_element(&#34;t:Type&#34;), value_type_str, version=version))
        field_elem.append(set_xml_value(create_element(&#34;t:Value&#34;), value, version=version))
        return field_elem


class DictionaryField(FieldURIField):
    value_cls = dict

    def from_xml(self, elem, account):
        from .properties import DictionaryEntry

        iter_elem = elem.find(self.response_tag())
        if iter_elem is not None:
            entries = [
                DictionaryEntry.from_xml(elem=e, account=account)
                for e in iter_elem.findall(DictionaryEntry.response_tag())
            ]
            return {e.key: e.value for e in entries}
        return self.default

    def clean(self, value, version=None):
        if isinstance(value, dict):
            cleaned = {}
            for k, v in value.items():
                if type(k) is datetime.datetime:
                    k = EWSDateTime.from_datetime(k)
                if type(v) is datetime.datetime:
                    v = EWSDateTime.from_datetime(v)
                cleaned[k] = v
            value = cleaned
        return super().clean(value=value, version=version)

    def to_xml(self, value, version):
        from .properties import DictionaryEntry

        field_elem = create_element(self.request_tag())
        entries = [DictionaryEntry(key=k, value=v) for k, v in value.items()]
        return set_xml_value(field_elem, entries, version=version)


class PersonaPhoneNumberField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .properties import PhoneNumber

        kwargs[&#34;value_cls&#34;] = PhoneNumber
        super().__init__(*args, **kwargs)


class BodyContentAttributedValueField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .properties import BodyContentAttributedValue

        kwargs[&#34;value_cls&#34;] = BodyContentAttributedValue
        super().__init__(*args, **kwargs)


class StringAttributedValueField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import StringAttributedValue

        kwargs[&#34;value_cls&#34;] = StringAttributedValue
        super().__init__(*args, **kwargs)


class PhoneNumberAttributedValueField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import PhoneNumberAttributedValue

        kwargs[&#34;value_cls&#34;] = PhoneNumberAttributedValue
        super().__init__(*args, **kwargs)


class EmailAddressAttributedValueField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import EmailAddressAttributedValue

        kwargs[&#34;value_cls&#34;] = EmailAddressAttributedValue
        super().__init__(*args, **kwargs)


class PostalAddressAttributedValueField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import PostalAddressAttributedValue

        kwargs[&#34;value_cls&#34;] = PostalAddressAttributedValue
        super().__init__(*args, **kwargs)


class GenericEventListField(EWSElementField):
    &#34;&#34;&#34;A list field that can contain all subclasses of Event.&#34;&#34;&#34;

    is_list = True

    @property
    def _event_types_map(self):
        return {v.response_tag(): v for v in self.value_classes}

    def __init__(self, *args, **kwargs):
        from .properties import (
            CopiedEvent,
            CreatedEvent,
            DeletedEvent,
            FreeBusyChangedEvent,
            ModifiedEvent,
            MovedEvent,
            NewMailEvent,
            StatusEvent,
        )

        kwargs[&#34;value_cls&#34;] = None  # Parent class requires this kwarg
        kwargs[&#34;namespace&#34;] = None  # Parent class requires this kwarg
        super().__init__(*args, **kwargs)
        self.value_classes = (
            CopiedEvent,
            CreatedEvent,
            DeletedEvent,
            ModifiedEvent,
            MovedEvent,
            NewMailEvent,
            StatusEvent,
            FreeBusyChangedEvent,
        )

    def from_xml(self, elem, account):
        events = []
        for event in elem:
            # This may or may not be an event element. Could also be other child elements of Notification
            try:
                value_cls = self._event_types_map[event.tag]
            except KeyError:
                continue
            events.append(value_cls.from_xml(elem=event, account=account))
        return events or self.default</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="exchangelib.fields.resolve_field_path"><code class="name flex">
<span>def <span class="ident">resolve_field_path</span></span>(<span>field_path, folder, strict=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Take the name of a field, or '__'-delimited path to a subfield, and return the corresponding Field object,
label and SubField object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_field_path(field_path, folder, strict=True):
    &#34;&#34;&#34;Take the name of a field, or &#39;__&#39;-delimited path to a subfield, and return the corresponding Field object,
    label and SubField object.
    &#34;&#34;&#34;
    from .indexed_properties import MultiFieldIndexedElement, SingleFieldIndexedElement

    fieldname, label, subfield_name = split_field_path(field_path)
    field = folder.get_item_field_by_fieldname(fieldname)
    subfield = None
    if isinstance(field, IndexedField):
        if strict and not label:
            raise ValueError(
                f&#34;IndexedField path {field_path!r} must specify label, e.g. &#34;
                f&#34;&#39;{fieldname}__{field.value_cls.get_field_by_fieldname(&#39;label&#39;).default}&#39;&#34;
            )
        valid_labels = field.value_cls.get_field_by_fieldname(&#34;label&#34;).supported_choices(version=folder.account.version)
        if label and label not in valid_labels:
            raise ValueError(
                f&#34;Label {label!r} on IndexedField path {field_path!r} must be one of {sorted(valid_labels)}&#34;
            )
        if issubclass(field.value_cls, MultiFieldIndexedElement):
            if strict and not subfield_name:
                raise ValueError(
                    f&#34;IndexedField path {field_path!r} must specify subfield, e.g. &#34;
                    f&#34;&#39;{fieldname}__{label}__{field.value_cls.FIELDS[1].name}&#39;&#34;
                )

            if subfield_name:
                try:
                    subfield = field.value_cls.get_field_by_fieldname(subfield_name)
                except ValueError:
                    field_names = &#34;, &#34;.join(
                        f.name for f in field.value_cls.supported_fields(version=folder.account.version)
                    )
                    raise ValueError(
                        f&#34;Subfield {subfield_name!r} on IndexedField path {field_path!r} &#34;
                        f&#34;must be one of {sorted(field_names)}&#34;
                    )
        else:
            if not issubclass(field.value_cls, SingleFieldIndexedElement):
                raise InvalidTypeError(&#34;field.value_cls&#34;, field.value_cls, SingleFieldIndexedElement)
            if subfield_name:
                raise ValueError(
                    f&#34;IndexedField path {field_path!r} must not specify subfield, e.g. just {fieldname}__{label}&#39;&#34;
                )
            subfield = field.value_cls.value_field(version=folder.account.version)
    else:
        if label or subfield_name:
            raise ValueError(f&#34;Field path {field_path!r} must not specify label or subfield, e.g. just {fieldname!r}&#34;)
    return field, label, subfield</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.split_field_path"><code class="name flex">
<span>def <span class="ident">split_field_path</span></span>(<span>field_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Split a string path into its field, label and subfield parts.</p>
<p>:param field_path:</p>
<p>:return Examples:
'start' -&gt; ('start', None, None)
'phone_numbers__PrimaryPhone' -&gt; ('phone_numbers', 'PrimaryPhone', None)
'physical_addresses__Home__street' -&gt; ('physical_addresses', 'Home', 'street')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_field_path(field_path):
    &#34;&#34;&#34;Split a string path into its field, label and subfield parts.

    :param field_path:

    :return Examples:
      &#39;start&#39; -&gt; (&#39;start&#39;, None, None)
      &#39;phone_numbers__PrimaryPhone&#39; -&gt; (&#39;phone_numbers&#39;, &#39;PrimaryPhone&#39;, None)
      &#39;physical_addresses__Home__street&#39; -&gt; (&#39;physical_addresses&#39;, &#39;Home&#39;, &#39;street&#39;)
    &#34;&#34;&#34;
    if not isinstance(field_path, str):
        raise InvalidTypeError(&#34;field_path&#34;, field_path, str)
    search_parts = field_path.split(&#34;__&#34;)
    field = search_parts[0]
    try:
        label = search_parts[1]
    except IndexError:
        label = None
    try:
        subfield = search_parts[2]
    except IndexError:
        subfield = None
    return field, label, subfield</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.fields.AppointmentStateField"><code class="flex name class">
<span>class <span class="ident">AppointmentStateField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/appointmentstate">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/appointmentstate</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppointmentStateField(IntegerField):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/appointmentstate&#34;&#34;&#34;

    NONE = &#34;None&#34;
    MEETING = &#34;Meeting&#34;
    RECEIVED = &#34;Received&#34;
    CANCELLED = &#34;Canceled&#34;
    STATES = {
        NONE: 0x0000,
        MEETING: 0x0001,
        RECEIVED: 0x0002,
        CANCELLED: 0x0004,
    }

    def from_xml(self, elem, account):
        val = super().from_xml(elem=elem, account=account)
        if val is None:
            return val
        return tuple(name for name, mask in self.STATES.items() if bool(val &amp; mask))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.IntegerField" href="#exchangelib.fields.IntegerField">IntegerField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.AppointmentStateField.CANCELLED"><code class="name">var <span class="ident">CANCELLED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.AppointmentStateField.MEETING"><code class="name">var <span class="ident">MEETING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.AppointmentStateField.NONE"><code class="name">var <span class="ident">NONE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.AppointmentStateField.RECEIVED"><code class="name">var <span class="ident">RECEIVED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.AppointmentStateField.STATES"><code class="name">var <span class="ident">STATES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.IntegerField" href="#exchangelib.fields.IntegerField">IntegerField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.IntegerField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.IntegerField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.IntegerField.value_cls" href="#exchangelib.fields.IntegerField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.AssociatedCalendarItemIdField"><code class="flex name class">
<span>class <span class="ident">AssociatedCalendarItemIdField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AssociatedCalendarItemIdField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .properties import AssociatedCalendarItemId

        kwargs[&#34;value_cls&#34;] = AssociatedCalendarItemId
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return value.to_xml(version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.AssociatedCalendarItemIdField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.AttachmentField"><code class="flex name class">
<span>class <span class="ident">AttachmentField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field for item attachments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AttachmentField(EWSElementListField):
    &#34;&#34;&#34;A field for item attachments.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        from .attachments import Attachment

        kwargs[&#34;value_cls&#34;] = Attachment
        super().__init__(*args, **kwargs)

    def from_xml(self, elem, account):
        from .attachments import FileAttachment, ItemAttachment

        iter_elem = elem.find(self.response_tag())
        # Look for both FileAttachment and ItemAttachment
        if iter_elem is not None:
            attachments = []
            for att_type in (ItemAttachment, FileAttachment):
                attachments.extend(
                    [att_type.from_xml(elem=e, account=account) for e in iter_elem.findall(att_type.response_tag())]
                )
            return attachments
        return self.default</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.AttendeesField"><code class="flex name class">
<span>class <span class="ident">AttendeesField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EWSElementField, but for lists of EWSElement objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AttendeesField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import Attendee

        kwargs[&#34;value_cls&#34;] = Attendee
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        from .properties import Mailbox

        if value is not None:
            value = [
                self.value_cls(mailbox=Mailbox(email_address=s), response_type=&#34;Accept&#34;) if isinstance(s, str) else s
                for s in value
            ]
        return super().clean(value, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.AttendeesField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    from .properties import Mailbox

    if value is not None:
        value = [
            self.value_cls(mailbox=Mailbox(email_address=s), response_type=&#34;Accept&#34;) if isinstance(s, str) else s
            for s in value
        ]
    return super().clean(value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.Base64Field"><code class="flex name class">
<span>class <span class="ident">Base64Field</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that handles binary data and automatically Base64 encodes and decodes the data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Base64Field(FieldURIField):
    &#34;&#34;&#34;A field that handles binary data and automatically Base64 encodes and decodes the data.&#34;&#34;&#34;

    value_cls = bytes
    is_complex = True

    def __init__(self, *args, **kwargs):
        if &#34;is_searchable&#34; not in kwargs:
            kwargs[&#34;is_searchable&#34;] = False
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.MimeContentField" href="#exchangelib.fields.MimeContentField">MimeContentField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.Base64Field.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.Base64Field.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"><p>bytes(iterable_of_ints) -&gt; bytes
bytes(string, encoding[, errors]) -&gt; bytes
bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer
bytes(int) -&gt; bytes object of size given by the parameter initialized with null bytes
bytes() -&gt; empty bytes object</p>
<p>Construct an immutable array of bytes from:
- an iterable yielding integers in range(256)
- a text string encoded using the specified encoding
- any object implementing the buffer API.
- an integer</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.BaseEmailField"><code class="flex name class">
<span>class <span class="ident">BaseEmailField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for EWSElement classes that have an 'email_address' field that we want to provide helpers for.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseEmailField(EWSElementField, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base class for EWSElement classes that have an &#39;email_address&#39; field that we want to provide helpers for.&#34;&#34;&#34;

    is_complex = True  # FindItem only returns the name, not the email address

    def clean(self, value, version=None):
        if isinstance(value, str):
            value = self.value_cls(email_address=value)
        return super().clean(value, version=version)

    def from_xml(self, elem, account):
        if self.field_uri is None:
            sub_elem = elem.find(self.value_cls.response_tag())
        else:
            sub_elem = elem.find(self.response_tag())
        if sub_elem is not None:
            if self.field_uri is not None:
                # We want the nested Mailbox, not the wrapper element
                nested_elem = sub_elem.find(self.value_cls.response_tag())
                if nested_elem is None:
                    raise ValueError(
                        f&#34;Expected XML element {self.value_cls.response_tag()!r} missing on field {self.name!r}&#34;
                    )
                return self.value_cls.from_xml(elem=nested_elem, account=account)
            return self.value_cls.from_xml(elem=sub_elem, account=account)
        return self.default</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EmailField" href="#exchangelib.fields.EmailField">EmailField</a></li>
<li><a title="exchangelib.fields.MailboxField" href="#exchangelib.fields.MailboxField">MailboxField</a></li>
<li><a title="exchangelib.fields.RecipientAddressField" href="#exchangelib.fields.RecipientAddressField">RecipientAddressField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.BaseEmailField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.BaseEmailField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if isinstance(value, str):
        value = self.value_cls(email_address=value)
    return super().clean(value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.BodyContentAttributedValueField"><code class="flex name class">
<span>class <span class="ident">BodyContentAttributedValueField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BodyContentAttributedValueField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .properties import BodyContentAttributedValue

        kwargs[&#34;value_cls&#34;] = BodyContentAttributedValue
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.BodyContentAttributedValueField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.BodyField"><code class="flex name class">
<span>class <span class="ident">BodyField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A TextField with specific requirements for the Item body.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BodyField(TextField):
    &#34;&#34;&#34;A TextField with specific requirements for the Item body.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        from .properties import Body

        self.value_cls = Body
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if value is not None and not isinstance(value, self.value_cls):
            value = self.value_cls(value)
        return super().clean(value, version=version)

    def from_xml(self, elem, account):
        from .properties import Body, HTMLBody

        field_elem = elem.find(self.response_tag())
        val = None if field_elem is None else field_elem.text or None
        if val is not None:
            body_type = field_elem.get(&#34;BodyType&#34;)
            return {Body.body_type: Body, HTMLBody.body_type: HTMLBody}[body_type](val)
        return self.default

    def to_xml(self, value, version):
        from .properties import Body, HTMLBody

        body_type = {
            Body: Body.body_type,
            HTMLBody: HTMLBody.body_type,
        }[type(value)]
        field_elem = create_element(self.request_tag(), attrs=dict(BodyType=body_type))
        return set_xml_value(field_elem, value, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.BodyField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if value is not None and not isinstance(value, self.value_cls):
        value = self.value_cls(value)
    return super().clean(value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.TextField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.BooleanField"><code class="flex name class">
<span>class <span class="ident">BooleanField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that handles boolean values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BooleanField(FieldURIField):
    &#34;&#34;&#34;A field that handles boolean values.&#34;&#34;&#34;

    value_cls = bool</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.BooleanField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"><p>bool(x) -&gt; bool</p>
<p>Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.CharField"><code class="flex name class">
<span>class <span class="ident">CharField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that stores a string value with a limited length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CharField(TextField):
    &#34;&#34;&#34;A field that stores a string value with a limited length.&#34;&#34;&#34;

    is_complex = False

    def __init__(self, *args, **kwargs):
        self.max_length = kwargs.pop(&#34;max_length&#34;, 255)
        if not 1 &lt;= self.max_length &lt;= 255:
            # A field supporting messages longer than 255 chars should be TextField
            raise ValueError(&#34;&#39;max_length&#39; must be in the range 1-255&#34;)
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        value = super().clean(value, version=version)
        if value is not None and len(value) &gt; self.max_length:
            raise ValueError(f&#34;{self.name!r} value {value!r} exceeds length {self.max_length}&#34;)
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.ChoiceField" href="#exchangelib.fields.ChoiceField">ChoiceField</a></li>
<li><a title="exchangelib.fields.CultureField" href="#exchangelib.fields.CultureField">CultureField</a></li>
<li><a title="exchangelib.fields.EmailAddressField" href="#exchangelib.fields.EmailAddressField">EmailAddressField</a></li>
<li><a title="exchangelib.fields.IdField" href="#exchangelib.fields.IdField">IdField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.CharField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.CharField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    value = super().clean(value, version=version)
    if value is not None and len(value) &gt; self.max_length:
        raise ValueError(f&#34;{self.name!r} value {value!r} exceeds length {self.max_length}&#34;)
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.TextField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.CharListField"><code class="flex name class">
<span>class <span class="ident">CharListField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like TextListField, but for string values with a limited length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CharListField(TextListField):
    &#34;&#34;&#34;Like TextListField, but for string values with a limited length.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.max_length = kwargs.pop(&#34;max_length&#34;, 255)
        if not 1 &lt;= self.max_length &lt;= 255:
            # A field supporting messages longer than 255 chars should be TextField
            raise ValueError(&#34;&#39;max_length&#39; must be in the range 1-255&#34;)
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        value = super().clean(value, version=version)
        if value is not None:
            for v in value:
                if len(v) &gt; self.max_length:
                    raise ValueError(f&#34;{self.name!r} value {v!r} exceeds length {self.max_length}&#34;)
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.TextListField" href="#exchangelib.fields.TextListField">TextListField</a></li>
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.UnknownEntriesField" href="#exchangelib.fields.UnknownEntriesField">UnknownEntriesField</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.CharListField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    value = super().clean(value, version=version)
    if value is not None:
        for v in value:
            if len(v) &gt; self.max_length:
                raise ValueError(f&#34;{self.name!r} value {v!r} exceeds length {self.max_length}&#34;)
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.TextListField" href="#exchangelib.fields.TextListField">TextListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.TextListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextListField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.Choice"><code class="flex name class">
<span>class <span class="ident">Choice</span></span>
<span>(</span><span>value, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement versioned choices for the ChoiceField field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Choice(SupportedVersionInstanceMixIn):
    &#34;&#34;&#34;Implement versioned choices for the ChoiceField field.&#34;&#34;&#34;

    def __init__(self, value, *args, **kwargs):
        self.value = value
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
</dd>
<dt id="exchangelib.fields.ChoiceField"><code class="flex name class">
<span>class <span class="ident">ChoiceField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like CharField, but restricts the value to a limited set of strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChoiceField(CharField):
    &#34;&#34;&#34;Like CharField, but restricts the value to a limited set of strings.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.choices = kwargs.pop(&#34;choices&#34;)
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        value = super().clean(value, version=version)
        if value is None:
            return None
        valid_choices = [c.value for c in self.choices]
        if version:
            valid_choices_for_version = self.supported_choices(version=version)
            if value in valid_choices_for_version:
                return value
            if value in valid_choices:
                raise InvalidChoiceForVersion(
                    f&#34;Choice {self.name!r} only supports server versions from {self.supported_from or &#39;*&#39;} to &#34;
                    f&#34;{self.deprecated_from or &#39;*&#39;} (server has {version})&#34;
                )
        else:
            if value in valid_choices:
                return value
        raise ValueError(f&#34;Invalid choice {value!r} for field {self.name!r}. Valid choices are {sorted(valid_choices)}&#34;)

    def supported_choices(self, version):
        return tuple(c.value for c in self.choices if c.supports_version(version))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></li>
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FreeBusyStatusField" href="#exchangelib.fields.FreeBusyStatusField">FreeBusyStatusField</a></li>
<li><a title="exchangelib.fields.LabelField" href="#exchangelib.fields.LabelField">LabelField</a></li>
<li><a title="exchangelib.fields.RoutingTypeField" href="#exchangelib.fields.RoutingTypeField">RoutingTypeField</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.ChoiceField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    value = super().clean(value, version=version)
    if value is None:
        return None
    valid_choices = [c.value for c in self.choices]
    if version:
        valid_choices_for_version = self.supported_choices(version=version)
        if value in valid_choices_for_version:
            return value
        if value in valid_choices:
            raise InvalidChoiceForVersion(
                f&#34;Choice {self.name!r} only supports server versions from {self.supported_from or &#39;*&#39;} to &#34;
                f&#34;{self.deprecated_from or &#39;*&#39;} (server has {version})&#34;
            )
    else:
        if value in valid_choices:
            return value
    raise ValueError(f&#34;Invalid choice {value!r} for field {self.name!r}. Valid choices are {sorted(valid_choices)}&#34;)</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.ChoiceField.supported_choices"><code class="name flex">
<span>def <span class="ident">supported_choices</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def supported_choices(self, version):
    return tuple(c.value for c in self.choices if c.supports_version(version))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.CharField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.CharField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.CharField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.CultureField"><code class="flex name class">
<span>class <span class="ident">CultureField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to mark strings that are # RFC 1766 culture values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CultureField(CharField):
    &#34;&#34;&#34;Helper to mark strings that are # RFC 1766 culture values.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></li>
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.CharField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.CharField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.CharField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.DateField"><code class="flex name class">
<span>class <span class="ident">DateField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that handles date values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateField(FieldURIField):
    &#34;&#34;&#34;A field that handles date values.&#34;&#34;&#34;

    value_cls = EWSDate

    def clean(self, value, version=None):
        # Allow plain datetime.date values as input
        if type(value) is datetime.date:
            value = self.value_cls.from_date(value)
        return super().clean(value=value, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.DateTimeBackedDateField" href="#exchangelib.fields.DateTimeBackedDateField">DateTimeBackedDateField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.DateField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"><p>Extends the normal date implementation to satisfy EWS.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.DateField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    # Allow plain datetime.date values as input
    if type(value) is datetime.date:
        value = self.value_cls.from_date(value)
    return super().clean(value=value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.DateOrDateTimeField"><code class="flex name class">
<span>class <span class="ident">DateOrDateTimeField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This field can handle both EWSDate and EWSDateTime. Used for calendar items where 'start' and 'end'
values are conceptually dates when the calendar item is an all-day event, but datetimes in all other cases, and
for recurrences where the returned 'start' and 'end' values may be either dates or datetimes depending on whether
the recurring item is a task or a calendar item.</p>
<p>For all-day calendar items, we assume both start and end dates are inclusive.</p>
<p>For filtering kwarg validation and other places where we must decide on a specific class, we settle on datetime.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateOrDateTimeField(DateTimeField):
    &#34;&#34;&#34;This field can handle both EWSDate and EWSDateTime. Used for calendar items where &#39;start&#39; and &#39;end&#39;
    values are conceptually dates when the calendar item is an all-day event, but datetimes in all other cases, and
    for recurrences where the returned &#39;start&#39; and &#39;end&#39; values may be either dates or datetimes depending on whether
    the recurring item is a task or a calendar item.

    For all-day calendar items, we assume both start and end dates are inclusive.

    For filtering kwarg validation and other places where we must decide on a specific class, we settle on datetime.
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Create internal field to handle date-only logic
        self._date_field = DateField(*args, **kwargs)

    def clean(self, value, version=None):
        # Most calendar items will contain datetime values. We can&#39;t access the is_all_day value here, so CalendarItem
        # must handle that sanity check.
        if type(value) in (EWSDate, datetime.date):
            return self._date_field.clean(value=value, version=version)
        return super().clean(value=value, version=version)

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None and len(val) == 16:
            # This is a date format with timezone info, as sent by task recurrences. Eg: &#39;2006-01-09+01:00&#39;
            return self._date_field.from_xml(elem=elem, account=account)
        return super().from_xml(elem=elem, account=account)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.DateTimeField" href="#exchangelib.fields.DateTimeField">DateTimeField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.DateOrDateTimeField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    # Most calendar items will contain datetime values. We can&#39;t access the is_all_day value here, so CalendarItem
    # must handle that sanity check.
    if type(value) in (EWSDate, datetime.date):
        return self._date_field.clean(value=value, version=version)
    return super().clean(value=value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.DateTimeField" href="#exchangelib.fields.DateTimeField">DateTimeField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.DateTimeField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.DateTimeField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.DateTimeField.value_cls" href="#exchangelib.fields.DateTimeField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.DateTimeBackedDateField"><code class="flex name class">
<span>class <span class="ident">DateTimeBackedDateField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that acts like a date, but where values are sent to EWS as EWSDateTime.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateTimeBackedDateField(DateField):
    &#34;&#34;&#34;A field that acts like a date, but where values are sent to EWS as EWSDateTime.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        # Not all fields assume a default time of 00:00, so make this configurable
        self._default_time = kwargs.pop(&#34;default_time&#34;, datetime.time(0, 0))
        super().__init__(*args, **kwargs)
        # Create internal field to handle datetime-only logic
        self._datetime_field = DateTimeField(*args, **kwargs)

    def date_to_datetime(self, value):
        return self._datetime_field.value_cls.combine(value, self._default_time).replace(tzinfo=UTC)

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None and len(val) == 25:
            # This is a datetime string with timezone info, e.g. &#39;2021-03-01T21:55:54+00:00&#39;. We don&#39;t want to have
            # datetime values converted to UTC before converting to date. EWSDateTime.from_string() insists on
            # converting to UTC, but we don&#39;t have an EWSTimeZone we can convert the timezone info to. Instead, parse
            # the string with .fromisoformat().
            return datetime.datetime.fromisoformat(val).date()
        # Revert to default parsing of datetime strings
        res = self._datetime_field.from_xml(elem=elem, account=account)
        if res is None:
            return res
        return res.date()

    def to_xml(self, value, version):
        # Convert date to datetime
        value = self.date_to_datetime(value)
        return self._datetime_field.to_xml(value=value, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.DateField" href="#exchangelib.fields.DateField">DateField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.DateTimeBackedDateField.date_to_datetime"><code class="name flex">
<span>def <span class="ident">date_to_datetime</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date_to_datetime(self, value):
    return self._datetime_field.value_cls.combine(value, self._default_time).replace(tzinfo=UTC)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.DateField" href="#exchangelib.fields.DateField">DateField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.DateField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.DateField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.DateField.value_cls" href="#exchangelib.fields.DateField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.DateTimeField"><code class="flex name class">
<span>class <span class="ident">DateTimeField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that handles datetime values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DateTimeField(FieldURIField):
    &#34;&#34;&#34;A field that handles datetime values.&#34;&#34;&#34;

    value_cls = EWSDateTime

    def clean(self, value, version=None):
        if isinstance(value, datetime.datetime):
            if not value.tzinfo:
                raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be timezone aware&#34;)
            if type(value) is datetime.datetime:
                value = self.value_cls.from_datetime(value)
        return super().clean(value, version=version)

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None:
            try:
                return self.value_cls.from_string(val)
            except ValueError as e:
                if isinstance(e, NaiveDateTimeNotAllowed):
                    # We encountered a naive datetime
                    if account:
                        # Convert to timezone-aware datetime using the default timezone of the account
                        tz = account.default_timezone
                        log.info(&#34;Found naive datetime %s on field %s. Assuming timezone %s&#34;, e.local_dt, self.name, tz)
                        return e.local_dt.replace(tzinfo=tz)
                    # There&#39;s nothing we can do but return the naive date. It&#39;s better than assuming e.g. UTC.
                    log.warning(&#34;Returning naive datetime %s on field %s&#34;, e.local_dt, self.name)
                    return e.local_dt
                log.info(&#34;Cannot convert value &#39;%s&#39; on field &#39;%s&#39; to type %s&#34;, val, self.name, self.value_cls)
                return None
        return self.default</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.DateOrDateTimeField" href="#exchangelib.fields.DateOrDateTimeField">DateOrDateTimeField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.DateTimeField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"><p>Extends the normal datetime implementation to satisfy EWS.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.DateTimeField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if isinstance(value, datetime.datetime):
        if not value.tzinfo:
            raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be timezone aware&#34;)
        if type(value) is datetime.datetime:
            value = self.value_cls.from_datetime(value)
    return super().clean(value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.DecimalField"><code class="flex name class">
<span>class <span class="ident">DecimalField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that handles decimal values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DecimalField(IntegerField):
    &#34;&#34;&#34;A field that handles decimal values.&#34;&#34;&#34;

    value_cls = Decimal</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.IntegerField" href="#exchangelib.fields.IntegerField">IntegerField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.IntegerField" href="#exchangelib.fields.IntegerField">IntegerField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.IntegerField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.IntegerField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.IntegerField.value_cls" href="#exchangelib.fields.IntegerField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.DictionaryField"><code class="flex name class">
<span>class <span class="ident">DictionaryField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that has a FieldURI value in EWS. This means it's value is contained in an XML element or attribute. It
may additionally be a label for searching, filtering and limiting fields. In that case, the FieldURI format will be
'itemtype:FieldName'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DictionaryField(FieldURIField):
    value_cls = dict

    def from_xml(self, elem, account):
        from .properties import DictionaryEntry

        iter_elem = elem.find(self.response_tag())
        if iter_elem is not None:
            entries = [
                DictionaryEntry.from_xml(elem=e, account=account)
                for e in iter_elem.findall(DictionaryEntry.response_tag())
            ]
            return {e.key: e.value for e in entries}
        return self.default

    def clean(self, value, version=None):
        if isinstance(value, dict):
            cleaned = {}
            for k, v in value.items():
                if type(k) is datetime.datetime:
                    k = EWSDateTime.from_datetime(k)
                if type(v) is datetime.datetime:
                    v = EWSDateTime.from_datetime(v)
                cleaned[k] = v
            value = cleaned
        return super().clean(value=value, version=version)

    def to_xml(self, value, version):
        from .properties import DictionaryEntry

        field_elem = create_element(self.request_tag())
        entries = [DictionaryEntry(key=k, value=v) for k, v in value.items()]
        return set_xml_value(field_elem, entries, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.DictionaryField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.DictionaryField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if isinstance(value, dict):
        cleaned = {}
        for k, v in value.items():
            if type(k) is datetime.datetime:
                k = EWSDateTime.from_datetime(k)
            if type(v) is datetime.datetime:
                v = EWSDateTime.from_datetime(v)
            cleaned[k] = v
        value = cleaned
    return super().clean(value=value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.EWSElementField"><code class="flex name class">
<span>class <span class="ident">EWSElementField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EWSElementField(FieldURIField):
    &#34;&#34;&#34;A generic field for any EWSElement object.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self._value_cls = kwargs.pop(&#34;value_cls&#34;)
        if &#34;namespace&#34; not in kwargs:
            kwargs[&#34;namespace&#34;] = self.value_cls.NAMESPACE
        super().__init__(*args, **kwargs)

    @property
    def value_cls(self):
        if isinstance(self._value_cls, str):
            # Support &#39;value_cls&#39; as string to allow self-referencing classes. The class must be importable from the
            # top-level module.
            self._value_cls = getattr(import_module(self.__module__.split(&#34;.&#34;)[0]), self._value_cls)
        return self._value_cls

    def from_xml(self, elem, account):
        if self.is_list:
            iter_elem = elem.find(self.response_tag())
            if iter_elem is not None:
                return [
                    self.value_cls.from_xml(elem=e, account=account)
                    for e in iter_elem.findall(self.value_cls.response_tag())
                ]
        else:
            if self.field_uri is None:
                sub_elem = elem.find(self.value_cls.response_tag())
            else:
                sub_elem = elem.find(self.response_tag())
            if sub_elem is not None:
                return self.value_cls.from_xml(elem=sub_elem, account=account)
        return self.default

    def to_xml(self, value, version):
        if self.field_uri is None:
            return value.to_xml(version=version)
        field_elem = create_element(self.request_tag())
        return set_xml_value(field_elem, value, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.AssociatedCalendarItemIdField" href="#exchangelib.fields.AssociatedCalendarItemIdField">AssociatedCalendarItemIdField</a></li>
<li><a title="exchangelib.fields.BaseEmailField" href="#exchangelib.fields.BaseEmailField">BaseEmailField</a></li>
<li><a title="exchangelib.fields.BodyContentAttributedValueField" href="#exchangelib.fields.BodyContentAttributedValueField">BodyContentAttributedValueField</a></li>
<li><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></li>
<li><a title="exchangelib.fields.EffectiveRightsField" href="#exchangelib.fields.EffectiveRightsField">EffectiveRightsField</a></li>
<li><a title="exchangelib.fields.GenericEventListField" href="#exchangelib.fields.GenericEventListField">GenericEventListField</a></li>
<li><a title="exchangelib.fields.IdElementField" href="#exchangelib.fields.IdElementField">IdElementField</a></li>
<li><a title="exchangelib.fields.IndexedField" href="#exchangelib.fields.IndexedField">IndexedField</a></li>
<li><a title="exchangelib.fields.OccurrenceField" href="#exchangelib.fields.OccurrenceField">OccurrenceField</a></li>
<li><a title="exchangelib.fields.PermissionSetField" href="#exchangelib.fields.PermissionSetField">PermissionSetField</a></li>
<li><a title="exchangelib.fields.PersonaPhoneNumberField" href="#exchangelib.fields.PersonaPhoneNumberField">PersonaPhoneNumberField</a></li>
<li><a title="exchangelib.fields.RecurrenceField" href="#exchangelib.fields.RecurrenceField">RecurrenceField</a></li>
<li><a title="exchangelib.fields.ReferenceItemIdField" href="#exchangelib.fields.ReferenceItemIdField">ReferenceItemIdField</a></li>
<li><a title="exchangelib.fields.TaskRecurrenceField" href="#exchangelib.fields.TaskRecurrenceField">TaskRecurrenceField</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.fields.EWSElementField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value_cls(self):
    if isinstance(self._value_cls, str):
        # Support &#39;value_cls&#39; as string to allow self-referencing classes. The class must be importable from the
        # top-level module.
        self._value_cls = getattr(import_module(self.__module__.split(&#34;.&#34;)[0]), self._value_cls)
    return self._value_cls</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.EWSElementListField"><code class="flex name class">
<span>class <span class="ident">EWSElementListField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EWSElementField, but for lists of EWSElement objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EWSElementListField(EWSElementField):
    &#34;&#34;&#34;Like EWSElementField, but for lists of EWSElement objects.&#34;&#34;&#34;

    is_list = True
    is_complex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.AttachmentField" href="#exchangelib.fields.AttachmentField">AttachmentField</a></li>
<li><a title="exchangelib.fields.AttendeesField" href="#exchangelib.fields.AttendeesField">AttendeesField</a></li>
<li><a title="exchangelib.fields.EmailAddressAttributedValueField" href="#exchangelib.fields.EmailAddressAttributedValueField">EmailAddressAttributedValueField</a></li>
<li><a title="exchangelib.fields.MailboxListField" href="#exchangelib.fields.MailboxListField">MailboxListField</a></li>
<li><a title="exchangelib.fields.MemberListField" href="#exchangelib.fields.MemberListField">MemberListField</a></li>
<li><a title="exchangelib.fields.MessageHeaderField" href="#exchangelib.fields.MessageHeaderField">MessageHeaderField</a></li>
<li><a title="exchangelib.fields.PhoneNumberAttributedValueField" href="#exchangelib.fields.PhoneNumberAttributedValueField">PhoneNumberAttributedValueField</a></li>
<li><a title="exchangelib.fields.PostalAddressAttributedValueField" href="#exchangelib.fields.PostalAddressAttributedValueField">PostalAddressAttributedValueField</a></li>
<li><a title="exchangelib.fields.StringAttributedValueField" href="#exchangelib.fields.StringAttributedValueField">StringAttributedValueField</a></li>
<li><a title="exchangelib.fields.TransitionListField" href="#exchangelib.fields.TransitionListField">TransitionListField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.EWSElementListField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.EWSElementListField.is_list"><code class="name">var <span class="ident">is_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.EffectiveRightsField"><code class="flex name class">
<span>class <span class="ident">EffectiveRightsField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EffectiveRightsField(EWSElementField):
    def __init__(self, *args, **kwargs):
        from .properties import EffectiveRights

        kwargs[&#34;value_cls&#34;] = EffectiveRights
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.EmailAddressAttributedValueField"><code class="flex name class">
<span>class <span class="ident">EmailAddressAttributedValueField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EWSElementField, but for lists of EWSElement objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmailAddressAttributedValueField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import EmailAddressAttributedValue

        kwargs[&#34;value_cls&#34;] = EmailAddressAttributedValue
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.EmailAddressField"><code class="flex name class">
<span>class <span class="ident">EmailAddressField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A helper class used for email address string that we can use for email validation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmailAddressField(CharField):
    &#34;&#34;&#34;A helper class used for email address string that we can use for email validation.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></li>
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.CharField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.CharField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.CharField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.EmailAddressesField"><code class="flex name class">
<span>class <span class="ident">EmailAddressesField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A base class for all indexed fields.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmailAddressesField(IndexedField):
    is_list = True
    is_complex = True

    PARENT_ELEMENT_NAME = &#34;EmailAddresses&#34;

    def __init__(self, *args, **kwargs):
        from .indexed_properties import EmailAddress

        kwargs[&#34;value_cls&#34;] = EmailAddress
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if value is not None:
            default_labels = self.value_cls.LABEL_CHOICES
            if len(value) &gt; len(default_labels):
                raise ValueError(f&#34;This field can handle at most {len(default_labels)} values (value: {value})&#34;)
            tmp = []
            for s, default_label in zip(value, default_labels):
                if not isinstance(s, str):
                    tmp.append(s)
                    continue
                tmp.append(self.value_cls(email=s, label=default_label))
            value = tmp
        return super().clean(value, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.IndexedField" href="#exchangelib.fields.IndexedField">IndexedField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.EmailAddressesField.PARENT_ELEMENT_NAME"><code class="name">var <span class="ident">PARENT_ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.EmailAddressesField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.EmailAddressesField.is_list"><code class="name">var <span class="ident">is_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.EmailAddressesField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if value is not None:
        default_labels = self.value_cls.LABEL_CHOICES
        if len(value) &gt; len(default_labels):
            raise ValueError(f&#34;This field can handle at most {len(default_labels)} values (value: {value})&#34;)
        tmp = []
        for s, default_label in zip(value, default_labels):
            if not isinstance(s, str):
                tmp.append(s)
                continue
            tmp.append(self.value_cls(email=s, label=default_label))
        value = tmp
    return super().clean(value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.IndexedField" href="#exchangelib.fields.IndexedField">IndexedField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.IndexedField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.IndexedField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.EmailField"><code class="flex name class">
<span>class <span class="ident">EmailField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for EWSElement classes that have an 'email_address' field that we want to provide helpers for.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmailField(BaseEmailField):
    def __init__(self, *args, **kwargs):
        from .properties import Email

        kwargs[&#34;value_cls&#34;] = Email
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.BaseEmailField" href="#exchangelib.fields.BaseEmailField">BaseEmailField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.BaseEmailField" href="#exchangelib.fields.BaseEmailField">BaseEmailField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.BaseEmailField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.BaseEmailField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.EmailSubField"><code class="flex name class">
<span>class <span class="ident">EmailSubField</span></span>
<span>(</span><span>name=None, is_required=False, is_required_after_save=False, is_read_only=False, is_read_only_after_send=False, is_searchable=True, is_attribute=False, default=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field to hold the value on an SingleFieldIndexedElement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmailSubField(SubField):
    &#34;&#34;&#34;A field to hold the value on an SingleFieldIndexedElement.&#34;&#34;&#34;

    value_cls = str

    def from_xml(self, elem, account):
        return elem.text or elem.get(&#34;Name&#34;)  # Sometimes elem.text is empty. Exchange saves the same in &#39;Name&#39; attr</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.SubField" href="#exchangelib.fields.SubField">SubField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.SubField" href="#exchangelib.fields.SubField">SubField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.SubField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.SubField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.SubField.value_cls" href="#exchangelib.fields.SubField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.EnumAsIntField"><code class="flex name class">
<span>class <span class="ident">EnumAsIntField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EnumField, but communicates values with EWS in integers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumAsIntField(EnumField):
    &#34;&#34;&#34;Like EnumField, but communicates values with EWS in integers.&#34;&#34;&#34;

    def from_xml(self, elem, account):
        return super(EnumField, self).from_xml(elem=elem, account=account)

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        return set_xml_value(field_elem, value, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EnumField" href="#exchangelib.fields.EnumField">EnumField</a></li>
<li><a title="exchangelib.fields.IntegerField" href="#exchangelib.fields.IntegerField">IntegerField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EnumField" href="#exchangelib.fields.EnumField">EnumField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EnumField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EnumField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.EnumField.value_cls" href="#exchangelib.fields.IntegerField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.EnumField"><code class="flex name class">
<span>class <span class="ident">EnumField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field type where you can enter either the 1-based index in an enum (tuple), or the enum value. Values will be
stored internally as integers but output in XML as strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumField(IntegerField):
    &#34;&#34;&#34;A field type where you can enter either the 1-based index in an enum (tuple), or the enum value. Values will be
    stored internally as integers but output in XML as strings.
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.enum = kwargs.pop(&#34;enum&#34;)
        # Set different min/max defaults than IntegerField
        if &#34;max&#34; in kwargs:
            raise AttributeError(&#34;EnumField does not support the &#39;max&#39; attribute&#34;)
        kwargs[&#34;min&#34;] = kwargs.pop(&#34;min&#34;, 1)
        kwargs[&#34;max&#34;] = kwargs[&#34;min&#34;] + len(self.enum) - 1
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if self.is_list:
            value = list(value)  # Convert to something we can index
            for i, v in enumerate(value):
                if isinstance(v, str):
                    if v not in self.enum:
                        raise ValueError(f&#34;List value {v!r} on field {self.name!r} must be one of {sorted(self.enum)}&#34;)
                    value[i] = self.enum.index(v) + 1
            if not value:
                raise ValueError(f&#34;Value {value!r} on field {self.name!r} must not be empty&#34;)
            if len(value) &gt; len(set(value)):
                raise ValueError(f&#34;List entries {value!r} on field {self.name!r} must be unique&#34;)
        else:
            if isinstance(value, str):
                if value not in self.enum:
                    raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be one of {sorted(self.enum)}&#34;)
                value = self.enum.index(value) + 1
        return super().clean(value, version=version)

    def as_string(self, value):
        # Converts an integer in the enum to its equivalent string
        if self.is_list:
            return [self.enum[v - 1] for v in sorted(value)]
        return self.enum[value - 1]

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None:
            try:
                if self.is_list:
                    return [self.enum.index(v) + 1 for v in val.split(&#34; &#34;)]
                return self.enum.index(val) + 1
            except ValueError:
                log.warning(&#34;Cannot convert value &#39;%s&#39; on field &#39;%s&#39; to type %s&#34;, val, self.name, self.value_cls)
                return None
        return self.default

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        if self.is_list:
            return set_xml_value(field_elem, &#34; &#34;.join(self.as_string(value)), version=version)
        return set_xml_value(field_elem, self.as_string(value), version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.IntegerField" href="#exchangelib.fields.IntegerField">IntegerField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EnumAsIntField" href="#exchangelib.fields.EnumAsIntField">EnumAsIntField</a></li>
<li><a title="exchangelib.fields.EnumListField" href="#exchangelib.fields.EnumListField">EnumListField</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.EnumField.as_string"><code class="name flex">
<span>def <span class="ident">as_string</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_string(self, value):
    # Converts an integer in the enum to its equivalent string
    if self.is_list:
        return [self.enum[v - 1] for v in sorted(value)]
    return self.enum[value - 1]</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.EnumField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if self.is_list:
        value = list(value)  # Convert to something we can index
        for i, v in enumerate(value):
            if isinstance(v, str):
                if v not in self.enum:
                    raise ValueError(f&#34;List value {v!r} on field {self.name!r} must be one of {sorted(self.enum)}&#34;)
                value[i] = self.enum.index(v) + 1
        if not value:
            raise ValueError(f&#34;Value {value!r} on field {self.name!r} must not be empty&#34;)
        if len(value) &gt; len(set(value)):
            raise ValueError(f&#34;List entries {value!r} on field {self.name!r} must be unique&#34;)
    else:
        if isinstance(value, str):
            if value not in self.enum:
                raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be one of {sorted(self.enum)}&#34;)
            value = self.enum.index(value) + 1
    return super().clean(value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.IntegerField" href="#exchangelib.fields.IntegerField">IntegerField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.IntegerField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.IntegerField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.IntegerField.value_cls" href="#exchangelib.fields.IntegerField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.EnumListField"><code class="flex name class">
<span>class <span class="ident">EnumListField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EnumField, but for lists of enum values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumListField(EnumField):
    &#34;&#34;&#34;Like EnumField, but for lists of enum values.&#34;&#34;&#34;

    is_list = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EnumField" href="#exchangelib.fields.EnumField">EnumField</a></li>
<li><a title="exchangelib.fields.IntegerField" href="#exchangelib.fields.IntegerField">IntegerField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.WeekdaysField" href="#exchangelib.fields.WeekdaysField">WeekdaysField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.EnumListField.is_list"><code class="name">var <span class="ident">is_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EnumField" href="#exchangelib.fields.EnumField">EnumField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EnumField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EnumField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.EnumField.value_cls" href="#exchangelib.fields.IntegerField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.ExtendedPropertyField"><code class="flex name class">
<span>class <span class="ident">ExtendedPropertyField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds information related to an item field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtendedPropertyField(Field):
    is_complex = True

    def __init__(self, *args, **kwargs):
        self.value_cls = kwargs.pop(&#34;value_cls&#34;)
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if value is None:
            if self.is_required:
                raise ValueError(f&#34;{self.name!r} is a required field&#34;)
            return self.default
        if not isinstance(value, self.value_cls):
            # Allow keeping ExtendedProperty field values as their simple Python type, but run clean() anyway
            tmp = self.value_cls(value)
            tmp.clean(version=version)
            return value
        value.clean(version=version)
        return value

    def field_uri_xml(self):
        from .properties import ExtendedFieldURI

        cls = self.value_cls
        return ExtendedFieldURI(
            distinguished_property_set_id=cls.distinguished_property_set_id,
            property_set_id=cls.property_set_id.lower() if cls.property_set_id else None,
            property_tag=cls.property_tag_as_hex(),
            property_name=cls.property_name,
            property_id=value_to_xml_text(cls.property_id) if cls.property_id else None,
            property_type=cls.property_type,
        ).to_xml(version=None)

    def from_xml(self, elem, account):
        extended_properties = elem.findall(self.value_cls.response_tag())
        for extended_property in extended_properties:
            if self.value_cls.is_property_instance(extended_property):
                return self.value_cls.from_xml(elem=extended_property, account=account)
        return self.default

    def to_xml(self, value, version):
        extended_property = create_element(self.value_cls.request_tag())
        set_xml_value(extended_property, self.field_uri_xml(), version=version)
        if isinstance(value, self.value_cls):
            return set_xml_value(extended_property, value, version=version)
        # Allow keeping ExtendedProperty field values as their simple Python type
        return set_xml_value(extended_property, self.value_cls(value), version=version)

    def __hash__(self):
        return hash(self.name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.ExtendedPropertyListField" href="#exchangelib.fields.ExtendedPropertyListField">ExtendedPropertyListField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.ExtendedPropertyField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.ExtendedPropertyField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if value is None:
        if self.is_required:
            raise ValueError(f&#34;{self.name!r} is a required field&#34;)
        return self.default
    if not isinstance(value, self.value_cls):
        # Allow keeping ExtendedProperty field values as their simple Python type, but run clean() anyway
        tmp = self.value_cls(value)
        tmp.clean(version=version)
        return value
    value.clean(version=version)
    return value</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.ExtendedPropertyField.field_uri_xml"><code class="name flex">
<span>def <span class="ident">field_uri_xml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field_uri_xml(self):
    from .properties import ExtendedFieldURI

    cls = self.value_cls
    return ExtendedFieldURI(
        distinguished_property_set_id=cls.distinguished_property_set_id,
        property_set_id=cls.property_set_id.lower() if cls.property_set_id else None,
        property_tag=cls.property_tag_as_hex(),
        property_name=cls.property_name,
        property_id=value_to_xml_text(cls.property_id) if cls.property_id else None,
        property_type=cls.property_type,
    ).to_xml(version=None)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.Field.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.Field.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.ExtendedPropertyListField"><code class="flex name class">
<span>class <span class="ident">ExtendedPropertyListField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds information related to an item field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtendedPropertyListField(ExtendedPropertyField):
    is_list = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.ExtendedPropertyField" href="#exchangelib.fields.ExtendedPropertyField">ExtendedPropertyField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.ExtendedPropertyListField.is_list"><code class="name">var <span class="ident">is_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.ExtendedPropertyField" href="#exchangelib.fields.ExtendedPropertyField">ExtendedPropertyField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.ExtendedPropertyField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.ExtendedPropertyField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.Field"><code class="flex name class">
<span>class <span class="ident">Field</span></span>
<span>(</span><span>name=None, is_required=False, is_required_after_save=False, is_read_only=False, is_read_only_after_send=False, is_searchable=True, is_attribute=False, default=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds information related to an item field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Field(SupportedVersionInstanceMixIn, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Holds information related to an item field.&#34;&#34;&#34;

    value_cls = None
    is_list = False
    # Is the field a complex EWS type? Quoting the EWS FindItem docs:
    #
    #   The FindItem operation returns only the first 512 bytes of any streamable property. For Unicode, it returns
    #   the first 255 characters by using a null-terminated Unicode string. It does not return any of the message
    #   body formats or the recipient lists.
    #
    is_complex = False

    def __init__(
        self,
        name=None,
        is_required=False,
        is_required_after_save=False,
        is_read_only=False,
        is_read_only_after_send=False,
        is_searchable=True,
        is_attribute=False,
        default=None,
        *args,
        **kwargs,
    ):
        self.name = name  # Usually set by the EWSMeta metaclass
        self.default = default  # Default value if none is given
        self.is_required = is_required
        # Some fields cannot be deleted on update. Default to True if &#39;is_required&#39; is set
        self.is_required_after_save = is_required or is_required_after_save
        self.is_read_only = is_read_only
        # Set this for fields that raise ErrorInvalidPropertyUpdateSentMessage on update after send. Default to True
        # if &#39;is_read_only&#39; is set
        self.is_read_only_after_send = is_read_only or is_read_only_after_send
        # Define whether the field can be used in a QuerySet. For some reason, EWS disallows searching on some fields,
        # instead throwing ErrorInvalidValueForProperty
        self.is_searchable = is_searchable
        # When true, this field is treated as an XML attribute instead of an element
        self.is_attribute = is_attribute
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if version and not self.supports_version(version):
            raise InvalidFieldForVersion(
                f&#34;Field {self.name!r} does not support EWS builds prior to {self.supported_from} (server has {version})&#34;
            )
        if value is None:
            if self.is_required and self.default is None:
                raise ValueError(f&#34;{self.name!r} is a required field with no default&#34;)
            return self.default
        if self.is_list:
            if not is_iterable(value):
                raise TypeError(f&#34;Field {self.name!r} value {value!r} must be of type {list}&#34;)
            for v in value:
                if not isinstance(v, self.value_cls):
                    raise TypeError(f&#34;Field {self.name!r} value {v!r} must be of type {self.value_cls}&#34;)
                if hasattr(v, &#34;clean&#34;):
                    v.clean(version=version)
        else:
            if not isinstance(value, self.value_cls):
                raise TypeError(f&#34;Field {self.name!r} value {value!r} must be of type {self.value_cls}&#34;)
            if hasattr(value, &#34;clean&#34;):
                value.clean(version=version)
        return value

    @abc.abstractmethod
    def from_xml(self, elem, account):
        &#34;&#34;&#34;Read a value from the given element&#34;&#34;&#34;

    @abc.abstractmethod
    def to_xml(self, value, version):
        &#34;&#34;&#34;Convert this field to an XML element&#34;&#34;&#34;

    def __eq__(self, other):
        return hash(self) == hash(other)

    @abc.abstractmethod
    def __hash__(self):
        &#34;&#34;&#34;Field instances must be hashable&#34;&#34;&#34;

    def __repr__(self):
        args_str = &#34;, &#34;.join(
            f&#34;{f}={getattr(self, f)!r}&#34; for f in (&#34;name&#34;, &#34;value_cls&#34;, &#34;is_list&#34;, &#34;is_complex&#34;, &#34;default&#34;)
        )
        return f&#34;{self.__class__.__name__}({args_str})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.ExtendedPropertyField" href="#exchangelib.fields.ExtendedPropertyField">ExtendedPropertyField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.SubField" href="#exchangelib.fields.SubField">SubField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.Field.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.Field.is_list"><code class="name">var <span class="ident">is_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.Field.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.Field.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if version and not self.supports_version(version):
        raise InvalidFieldForVersion(
            f&#34;Field {self.name!r} does not support EWS builds prior to {self.supported_from} (server has {version})&#34;
        )
    if value is None:
        if self.is_required and self.default is None:
            raise ValueError(f&#34;{self.name!r} is a required field with no default&#34;)
        return self.default
    if self.is_list:
        if not is_iterable(value):
            raise TypeError(f&#34;Field {self.name!r} value {value!r} must be of type {list}&#34;)
        for v in value:
            if not isinstance(v, self.value_cls):
                raise TypeError(f&#34;Field {self.name!r} value {v!r} must be of type {self.value_cls}&#34;)
            if hasattr(v, &#34;clean&#34;):
                v.clean(version=version)
    else:
        if not isinstance(value, self.value_cls):
            raise TypeError(f&#34;Field {self.name!r} value {value!r} must be of type {self.value_cls}&#34;)
        if hasattr(value, &#34;clean&#34;):
            value.clean(version=version)
    return value</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.Field.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>self, elem, account)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a value from the given element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def from_xml(self, elem, account):
    &#34;&#34;&#34;Read a value from the given element&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.Field.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self, value, version)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert this field to an XML element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def to_xml(self, value, version):
    &#34;&#34;&#34;Convert this field to an XML element&#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.fields.FieldOrder"><code class="flex name class">
<span>class <span class="ident">FieldOrder</span></span>
<span>(</span><span>field_path, reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds values needed to call server-side sorting on a single field path.</p>
<p>:param field_path: A FieldPath instance
:param reverse: A bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldOrder:
    &#34;&#34;&#34;Holds values needed to call server-side sorting on a single field path.&#34;&#34;&#34;

    def __init__(self, field_path, reverse=False):
        &#34;&#34;&#34;

        :param field_path: A FieldPath instance
        :param reverse: A bool
        &#34;&#34;&#34;
        self.field_path = field_path
        self.reverse = reverse

    @classmethod
    def from_string(cls, field_path, folder):
        return cls(
            field_path=FieldPath.from_string(field_path=field_path.lstrip(&#34;-&#34;), folder=folder, strict=True),
            reverse=field_path.startswith(&#34;-&#34;),
        )

    def to_xml(self):
        field_order = create_element(&#34;t:FieldOrder&#34;, attrs=dict(Order=&#34;Descending&#34; if self.reverse else &#34;Ascending&#34;))
        field_order.append(self.field_path.to_xml())
        return field_order</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.fields.FieldOrder.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>field_path, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, field_path, folder):
    return cls(
        field_path=FieldPath.from_string(field_path=field_path.lstrip(&#34;-&#34;), folder=folder, strict=True),
        reverse=field_path.startswith(&#34;-&#34;),
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.FieldOrder.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self):
    field_order = create_element(&#34;t:FieldOrder&#34;, attrs=dict(Order=&#34;Descending&#34; if self.reverse else &#34;Ascending&#34;))
    field_order.append(self.field_path.to_xml())
    return field_order</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.fields.FieldPath"><code class="flex name class">
<span>class <span class="ident">FieldPath</span></span>
<span>(</span><span>field, label=None, subfield=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds values needed to point to a single field. For indexed properties, we allow setting either field,
field and label, or field, label and subfield. This allows pointing to either the full indexed property set, a
property with a specific label, or a particular subfield field on that property.</p>
<p>:param field: A FieldURIField or ExtendedPropertyField instance
:param label: a str
:param subfield: A SubField instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldPath:
    &#34;&#34;&#34;Holds values needed to point to a single field. For indexed properties, we allow setting either field,
    field and label, or field, label and subfield. This allows pointing to either the full indexed property set, a
    property with a specific label, or a particular subfield field on that property.
    &#34;&#34;&#34;

    def __init__(self, field, label=None, subfield=None):
        &#34;&#34;&#34;

        :param field: A FieldURIField or ExtendedPropertyField instance
        :param label: a str
        :param subfield: A SubField instance
        &#34;&#34;&#34;
        # &#39;label&#39; and &#39;subfield&#39; are only used for IndexedField fields
        self.field = field
        self.label = label
        self.subfield = subfield

    @classmethod
    def from_string(cls, field_path, folder, strict=False):
        field, label, subfield = resolve_field_path(field_path, folder=folder, strict=strict)
        return cls(field=field, label=label, subfield=subfield)

    def get_value(self, item):
        # For indexed properties, get either the full property set, the property with matching label, or a particular
        # subfield.
        if self.label:
            for sub_item in getattr(item, self.field.name):
                if sub_item.label == self.label:
                    if self.subfield:
                        return getattr(sub_item, self.subfield.name)
                    return sub_item
            return None  # No item with this label
        return getattr(item, self.field.name)

    def get_sort_value(self, item):
        # For fields that allow values of different types, we need to return a value that is
        val = self.get_value(item)
        if isinstance(self.field, DateOrDateTimeField) and isinstance(val, EWSDate):
            return item.date_to_datetime(field_name=self.field.name)
        return val

    def to_xml(self):
        if isinstance(self.field, IndexedField):
            if not self.label or not self.subfield:
                raise ValueError(f&#34;Field path for indexed field {self.field.name!r} is missing label and/or subfield&#34;)
            return self.subfield.field_uri_xml(field_uri=self.field.field_uri, label=self.label)
        return self.field.field_uri_xml()

    def expand(self, version):
        # If this path does not point to a specific subfield on an indexed property, return all the possible path
        # combinations for this field path.
        if isinstance(self.field, IndexedField):
            labels = (
                [self.label]
                if self.label
                else self.field.value_cls.get_field_by_fieldname(&#34;label&#34;).supported_choices(version=version)
            )
            subfields = [self.subfield] if self.subfield else self.field.value_cls.supported_fields(version=version)
            for label in labels:
                for subfield in subfields:
                    yield FieldPath(field=self.field, label=label, subfield=subfield)
        else:
            yield self

    @property
    def path(self):
        if self.label:
            from .indexed_properties import SingleFieldIndexedElement

            if issubclass(self.field.value_cls, SingleFieldIndexedElement) or not self.subfield:
                return f&#34;{self.field.name}__{self.label}&#34;
            return f&#34;{self.field.name}__{self.label}__{self.subfield.name}&#34;
        return self.field.name

    def __eq__(self, other):
        return hash(self) == hash(other)

    def __str__(self):
        return self.path

    def __repr__(self):
        return self.__class__.__name__ + repr((self.field, self.label, self.subfield))

    def __hash__(self):
        return hash((self.field, self.label, self.subfield))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.fields.FieldPath.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>field_path, folder, strict=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, field_path, folder, strict=False):
    field, label, subfield = resolve_field_path(field_path, folder=folder, strict=strict)
    return cls(field=field, label=label, subfield=subfield)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.fields.FieldPath.path"><code class="name">var <span class="ident">path</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self):
    if self.label:
        from .indexed_properties import SingleFieldIndexedElement

        if issubclass(self.field.value_cls, SingleFieldIndexedElement) or not self.subfield:
            return f&#34;{self.field.name}__{self.label}&#34;
        return f&#34;{self.field.name}__{self.label}__{self.subfield.name}&#34;
    return self.field.name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.FieldPath.expand"><code class="name flex">
<span>def <span class="ident">expand</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expand(self, version):
    # If this path does not point to a specific subfield on an indexed property, return all the possible path
    # combinations for this field path.
    if isinstance(self.field, IndexedField):
        labels = (
            [self.label]
            if self.label
            else self.field.value_cls.get_field_by_fieldname(&#34;label&#34;).supported_choices(version=version)
        )
        subfields = [self.subfield] if self.subfield else self.field.value_cls.supported_fields(version=version)
        for label in labels:
            for subfield in subfields:
                yield FieldPath(field=self.field, label=label, subfield=subfield)
    else:
        yield self</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.FieldPath.get_sort_value"><code class="name flex">
<span>def <span class="ident">get_sort_value</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sort_value(self, item):
    # For fields that allow values of different types, we need to return a value that is
    val = self.get_value(item)
    if isinstance(self.field, DateOrDateTimeField) and isinstance(val, EWSDate):
        return item.date_to_datetime(field_name=self.field.name)
    return val</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.FieldPath.get_value"><code class="name flex">
<span>def <span class="ident">get_value</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value(self, item):
    # For indexed properties, get either the full property set, the property with matching label, or a particular
    # subfield.
    if self.label:
        for sub_item in getattr(item, self.field.name):
            if sub_item.label == self.label:
                if self.subfield:
                    return getattr(sub_item, self.subfield.name)
                return sub_item
        return None  # No item with this label
    return getattr(item, self.field.name)</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.FieldPath.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self):
    if isinstance(self.field, IndexedField):
        if not self.label or not self.subfield:
            raise ValueError(f&#34;Field path for indexed field {self.field.name!r} is missing label and/or subfield&#34;)
        return self.subfield.field_uri_xml(field_uri=self.field.field_uri, label=self.label)
    return self.field.field_uri_xml()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.fields.FieldURIField"><code class="flex name class">
<span>class <span class="ident">FieldURIField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that has a FieldURI value in EWS. This means it's value is contained in an XML element or attribute. It
may additionally be a label for searching, filtering and limiting fields. In that case, the FieldURI format will be
'itemtype:FieldName'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldURIField(Field):
    &#34;&#34;&#34;A field that has a FieldURI value in EWS. This means it&#39;s value is contained in an XML element or attribute. It
    may additionally be a label for searching, filtering and limiting fields. In that case, the FieldURI format will be
    &#39;itemtype:FieldName&#39;
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.field_uri = kwargs.pop(&#34;field_uri&#34;, None)
        self.namespace = kwargs.pop(&#34;namespace&#34;, TNS)
        super().__init__(*args, **kwargs)
        # See all valid FieldURI values at
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/fielduri
        # The field_uri has a prefix when the FieldURI points to an Item field.
        if self.field_uri is None:
            self.field_uri_postfix = None
        elif &#34;:&#34; in self.field_uri:
            self.field_uri_postfix = self.field_uri.split(&#34;:&#34;)[1]
        else:
            self.field_uri_postfix = self.field_uri

    def _get_val_from_elem(self, elem):
        if self.is_attribute:
            return elem.get(self.field_uri) or None
        return get_xml_attr(elem, self.response_tag())

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None:
            try:
                return xml_text_to_value(val, self.value_cls)
            except (ValueError, InvalidOperation):
                log.warning(&#34;Cannot convert value &#39;%s&#39; on field &#39;%s&#39; to type %s&#34;, val, self.name, self.value_cls)
                return None
        return self.default

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        return set_xml_value(field_elem, value, version=version)

    def field_uri_xml(self):
        from .properties import FieldURI

        if not self.field_uri:
            raise ValueError(f&#34;&#39;field_uri&#39; value is missing on field &#39;{self.name}&#39;&#34;)
        return FieldURI(field_uri=self.field_uri).to_xml(version=None)

    def request_tag(self):
        if not self.field_uri_postfix:
            raise ValueError(f&#34;&#39;field_uri_postfix&#39; value is missing on field &#39;{self.name}&#39;&#34;)
        return f&#34;t:{self.field_uri_postfix}&#34;

    def response_tag(self):
        if not self.field_uri_postfix:
            raise ValueError(f&#34;&#39;field_uri_postfix&#39; value is missing on field &#39;{self.name}&#39;&#34;)
        return f&#34;{{{self.namespace}}}{self.field_uri_postfix}&#34;

    def __hash__(self):
        return hash(self.field_uri)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.Base64Field" href="#exchangelib.fields.Base64Field">Base64Field</a></li>
<li><a title="exchangelib.fields.BooleanField" href="#exchangelib.fields.BooleanField">BooleanField</a></li>
<li><a title="exchangelib.fields.DateField" href="#exchangelib.fields.DateField">DateField</a></li>
<li><a title="exchangelib.fields.DateTimeField" href="#exchangelib.fields.DateTimeField">DateTimeField</a></li>
<li><a title="exchangelib.fields.DictionaryField" href="#exchangelib.fields.DictionaryField">DictionaryField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.IntegerField" href="#exchangelib.fields.IntegerField">IntegerField</a></li>
<li><a title="exchangelib.fields.ItemField" href="#exchangelib.fields.ItemField">ItemField</a></li>
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.TimeDeltaField" href="#exchangelib.fields.TimeDeltaField">TimeDeltaField</a></li>
<li><a title="exchangelib.fields.TimeField" href="#exchangelib.fields.TimeField">TimeField</a></li>
<li><a title="exchangelib.fields.TimeZoneField" href="#exchangelib.fields.TimeZoneField">TimeZoneField</a></li>
<li><a title="exchangelib.fields.TypeValueField" href="#exchangelib.fields.TypeValueField">TypeValueField</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.FieldURIField.field_uri_xml"><code class="name flex">
<span>def <span class="ident">field_uri_xml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field_uri_xml(self):
    from .properties import FieldURI

    if not self.field_uri:
        raise ValueError(f&#34;&#39;field_uri&#39; value is missing on field &#39;{self.name}&#39;&#34;)
    return FieldURI(field_uri=self.field_uri).to_xml(version=None)</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.FieldURIField.request_tag"><code class="name flex">
<span>def <span class="ident">request_tag</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_tag(self):
    if not self.field_uri_postfix:
        raise ValueError(f&#34;&#39;field_uri_postfix&#39; value is missing on field &#39;{self.name}&#39;&#34;)
    return f&#34;t:{self.field_uri_postfix}&#34;</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.FieldURIField.response_tag"><code class="name flex">
<span>def <span class="ident">response_tag</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def response_tag(self):
    if not self.field_uri_postfix:
        raise ValueError(f&#34;&#39;field_uri_postfix&#39; value is missing on field &#39;{self.name}&#39;&#34;)
    return f&#34;{{{self.namespace}}}{self.field_uri_postfix}&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.Field.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.Field.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.FreeBusyStatusField"><code class="flex name class">
<span>class <span class="ident">FreeBusyStatusField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like ChoiceField, but specifically for Free/Busy values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FreeBusyStatusField(ChoiceField):
    &#34;&#34;&#34;Like ChoiceField, but specifically for Free/Busy values.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        kwargs[&#34;choices&#34;] = set(FREE_BUSY_CHOICES)
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.ChoiceField" href="#exchangelib.fields.ChoiceField">ChoiceField</a></li>
<li><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></li>
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.ChoiceField" href="#exchangelib.fields.ChoiceField">ChoiceField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.ChoiceField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.ChoiceField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.ChoiceField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.GenericEventListField"><code class="flex name class">
<span>class <span class="ident">GenericEventListField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A list field that can contain all subclasses of Event.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericEventListField(EWSElementField):
    &#34;&#34;&#34;A list field that can contain all subclasses of Event.&#34;&#34;&#34;

    is_list = True

    @property
    def _event_types_map(self):
        return {v.response_tag(): v for v in self.value_classes}

    def __init__(self, *args, **kwargs):
        from .properties import (
            CopiedEvent,
            CreatedEvent,
            DeletedEvent,
            FreeBusyChangedEvent,
            ModifiedEvent,
            MovedEvent,
            NewMailEvent,
            StatusEvent,
        )

        kwargs[&#34;value_cls&#34;] = None  # Parent class requires this kwarg
        kwargs[&#34;namespace&#34;] = None  # Parent class requires this kwarg
        super().__init__(*args, **kwargs)
        self.value_classes = (
            CopiedEvent,
            CreatedEvent,
            DeletedEvent,
            ModifiedEvent,
            MovedEvent,
            NewMailEvent,
            StatusEvent,
            FreeBusyChangedEvent,
        )

    def from_xml(self, elem, account):
        events = []
        for event in elem:
            # This may or may not be an event element. Could also be other child elements of Notification
            try:
                value_cls = self._event_types_map[event.tag]
            except KeyError:
                continue
            events.append(value_cls.from_xml(elem=event, account=account))
        return events or self.default</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.GenericEventListField.is_list"><code class="name">var <span class="ident">is_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.IdElementField"><code class="flex name class">
<span>class <span class="ident">IdElementField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IdElementField(EWSElementField):
    def __init__(self, *args, **kwargs):
        kwargs[&#34;is_searchable&#34;] = False
        kwargs[&#34;is_read_only&#34;] = True
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.IdField"><code class="flex name class">
<span>class <span class="ident">IdField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field to hold the 'Id' and 'Changekey' attributes on 'ItemId' type items. There is no guaranteed max length,
but we can assume 512 bytes in practice. See
<a href="https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/ews-identifiers-in-exchange">https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/ews-identifiers-in-exchange</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IdField(CharField):
    &#34;&#34;&#34;A field to hold the &#39;Id&#39; and &#39;Changekey&#39; attributes on &#39;ItemId&#39; type items. There is no guaranteed max length,
    but we can assume 512 bytes in practice. See
    https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/ews-identifiers-in-exchange
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.max_length = 512  # This is above the normal 255 limit, but this is actually an attribute, not a field
        self.is_searchable = False
        self.is_attribute = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></li>
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.CharField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.CharField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.CharField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.IndexedField"><code class="flex name class">
<span>class <span class="ident">IndexedField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A base class for all indexed fields.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IndexedField(EWSElementField, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;A base class for all indexed fields.&#34;&#34;&#34;

    PARENT_ELEMENT_NAME = None

    def __init__(self, *args, **kwargs):
        from .indexed_properties import IndexedElement

        value_cls = kwargs[&#34;value_cls&#34;]
        if not issubclass(value_cls, IndexedElement):
            raise TypeError(f&#34;&#39;value_cls&#39; {value_cls!r} must be a subclass of type {IndexedElement}&#34;)
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return set_xml_value(create_element(f&#34;t:{self.PARENT_ELEMENT_NAME}&#34;), value, version=version)

    def response_tag(self):
        return f&#34;{{{self.namespace}}}{self.PARENT_ELEMENT_NAME}&#34;

    def __hash__(self):
        return hash(self.field_uri)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EmailAddressesField" href="#exchangelib.fields.EmailAddressesField">EmailAddressesField</a></li>
<li><a title="exchangelib.fields.PhoneNumberField" href="#exchangelib.fields.PhoneNumberField">PhoneNumberField</a></li>
<li><a title="exchangelib.fields.PhysicalAddressField" href="#exchangelib.fields.PhysicalAddressField">PhysicalAddressField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.IndexedField.PARENT_ELEMENT_NAME"><code class="name">var <span class="ident">PARENT_ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.IndexedField.response_tag"><code class="name flex">
<span>def <span class="ident">response_tag</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def response_tag(self):
    return f&#34;{{{self.namespace}}}{self.PARENT_ELEMENT_NAME}&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.IntegerField"><code class="flex name class">
<span>class <span class="ident">IntegerField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that handles integer values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IntegerField(FieldURIField):
    &#34;&#34;&#34;A field that handles integer values.&#34;&#34;&#34;

    value_cls = int

    def __init__(self, *args, **kwargs):
        self.min = kwargs.pop(&#34;min&#34;, None)
        self.max = kwargs.pop(&#34;max&#34;, None)
        super().__init__(*args, **kwargs)

    def _clean_single_value(self, v):
        if self.min is not None and v &lt; self.min:
            raise ValueError(f&#34;Value {v!r} on field {self.name!r} must be greater than {self.min}&#34;)
        if self.max is not None and v &gt; self.max:
            raise ValueError(f&#34;Value {v!r} on field {self.name!r} must be less than {self.max}&#34;)

    def clean(self, value, version=None):
        value = super().clean(value, version=version)
        if value is not None:
            if self.is_list:
                for v in value:
                    self._clean_single_value(v)
            else:
                self._clean_single_value(value)
        return value</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.AppointmentStateField" href="#exchangelib.fields.AppointmentStateField">AppointmentStateField</a></li>
<li><a title="exchangelib.fields.DecimalField" href="#exchangelib.fields.DecimalField">DecimalField</a></li>
<li><a title="exchangelib.fields.EnumField" href="#exchangelib.fields.EnumField">EnumField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.IntegerField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"><p>int([x]) -&gt; integer
int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments
are given.
If x is a number, return x.<strong>int</strong>().
For floating point
numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.
The literal can be preceded by '+' or '-' and be surrounded
by whitespace.
The base defaults to 10.
Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; int('0b100', base=0)
4
</code></pre></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.IntegerField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    value = super().clean(value, version=version)
    if value is not None:
        if self.is_list:
            for v in value:
                self._clean_single_value(v)
        else:
            self._clean_single_value(value)
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.InvalidChoiceForVersion"><code class="flex name class">
<span>class <span class="ident">InvalidChoiceForVersion</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Used when a value is not valid for an enum-type field.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidChoiceForVersion(ValueError):
    &#34;&#34;&#34;Used when a value is not valid for an enum-type field.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="exchangelib.fields.InvalidField"><code class="flex name class">
<span>class <span class="ident">InvalidField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Used when a field name does not match any defined fields.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidField(ValueError):
    &#34;&#34;&#34;Used when a field name does not match any defined fields.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="exchangelib.fields.InvalidFieldForVersion"><code class="flex name class">
<span>class <span class="ident">InvalidFieldForVersion</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Used when a field is not supported on the given Exchange version.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidFieldForVersion(ValueError):
    &#34;&#34;&#34;Used when a field is not supported on the given Exchange version.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.ValueError</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="exchangelib.fields.ItemField"><code class="flex name class">
<span>class <span class="ident">ItemField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that has a FieldURI value in EWS. This means it's value is contained in an XML element or attribute. It
may additionally be a label for searching, filtering and limiting fields. In that case, the FieldURI format will be
'itemtype:FieldName'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ItemField(FieldURIField):
    @property
    def value_cls(self):
        from .items import Item

        return Item

    def from_xml(self, elem, account):
        from .items import ITEM_CLASSES

        for item_cls in ITEM_CLASSES:
            item_elem = elem.find(item_cls.response_tag())
            if item_elem is not None:
                return item_cls.from_xml(elem=item_elem, account=account)
        return None

    def to_xml(self, value, version):
        # We don&#39;t want to wrap in an Item element
        return value.to_xml(version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.fields.ItemField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value_cls(self):
    from .items import Item

    return Item</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.LabelField"><code class="flex name class">
<span>class <span class="ident">LabelField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field to hold the label on an IndexedElement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabelField(ChoiceField):
    &#34;&#34;&#34;A field to hold the label on an IndexedElement.&#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.is_attribute = True

    def from_xml(self, elem, account):
        return elem.get(self.field_uri)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.ChoiceField" href="#exchangelib.fields.ChoiceField">ChoiceField</a></li>
<li><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></li>
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.ChoiceField" href="#exchangelib.fields.ChoiceField">ChoiceField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.ChoiceField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.ChoiceField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.ChoiceField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.MailboxField"><code class="flex name class">
<span>class <span class="ident">MailboxField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for EWSElement classes that have an 'email_address' field that we want to provide helpers for.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MailboxField(BaseEmailField):
    def __init__(self, *args, **kwargs):
        from .properties import Mailbox

        kwargs[&#34;value_cls&#34;] = Mailbox
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.BaseEmailField" href="#exchangelib.fields.BaseEmailField">BaseEmailField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.BaseEmailField" href="#exchangelib.fields.BaseEmailField">BaseEmailField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.BaseEmailField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.BaseEmailField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.MailboxListField"><code class="flex name class">
<span>class <span class="ident">MailboxListField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EWSElementField, but for lists of EWSElement objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MailboxListField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import Mailbox

        kwargs[&#34;value_cls&#34;] = Mailbox
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if value is not None:
            value = [self.value_cls(email_address=s) if isinstance(s, str) else s for s in value]
        return super().clean(value, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.MailboxListField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if value is not None:
        value = [self.value_cls(email_address=s) if isinstance(s, str) else s for s in value]
    return super().clean(value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.MemberListField"><code class="flex name class">
<span>class <span class="ident">MemberListField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EWSElementField, but for lists of EWSElement objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemberListField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import Member

        kwargs[&#34;value_cls&#34;] = Member
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        from .properties import Mailbox

        if value is not None:
            value = [self.value_cls(mailbox=Mailbox(email_address=s)) if isinstance(s, str) else s for s in value]
        return super().clean(value, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.MemberListField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    from .properties import Mailbox

    if value is not None:
        value = [self.value_cls(mailbox=Mailbox(email_address=s)) if isinstance(s, str) else s for s in value]
    return super().clean(value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.MessageField"><code class="flex name class">
<span>class <span class="ident">MessageField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that handles the Message element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageField(TextField):
    &#34;&#34;&#34;A field that handles the Message element.&#34;&#34;&#34;

    INNER_ELEMENT_NAME = &#34;Message&#34;

    def from_xml(self, elem, account):
        reply = elem.find(self.response_tag())
        if reply is None:
            return None
        message = reply.find(f&#34;{{{TNS}}}{self.INNER_ELEMENT_NAME}&#34;)
        if message is None:
            return None
        return message.text

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        message = create_element(f&#34;t:{self.INNER_ELEMENT_NAME}&#34;)
        message.text = value
        return set_xml_value(field_elem, message, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.MessageField.INNER_ELEMENT_NAME"><code class="name">var <span class="ident">INNER_ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.TextField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.MessageHeaderField"><code class="flex name class">
<span>class <span class="ident">MessageHeaderField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EWSElementField, but for lists of EWSElement objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessageHeaderField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import MessageHeader

        kwargs[&#34;value_cls&#34;] = MessageHeader
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.MimeContentField"><code class="flex name class">
<span>class <span class="ident">MimeContentField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like Base64Field. This element has an optional 'CharacterSet' attribute, but it specifies the encoding of the
base64-encoded string (which doesn't make sense since base64-encoded strings are always ASCII). We ignore it here
because the decoded data could be in some other encoding, specified in the "Content-Type" HTTP header.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MimeContentField(Base64Field):
    &#34;&#34;&#34;Like Base64Field. This element has an optional &#39;CharacterSet&#39; attribute, but it specifies the encoding of the
    base64-encoded string (which doesn&#39;t make sense since base64-encoded strings are always ASCII). We ignore it here
    because the decoded data could be in some other encoding, specified in the &#34;Content-Type&#34; HTTP header.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.Base64Field" href="#exchangelib.fields.Base64Field">Base64Field</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.Base64Field" href="#exchangelib.fields.Base64Field">Base64Field</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.Base64Field.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.Base64Field.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.Base64Field.value_cls" href="#exchangelib.fields.Base64Field.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.NamedSubField"><code class="flex name class">
<span>class <span class="ident">NamedSubField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field to hold the value on an MultiFieldIndexedElement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NamedSubField(SubField):
    &#34;&#34;&#34;A field to hold the value on an MultiFieldIndexedElement.&#34;&#34;&#34;

    value_cls = str

    def __init__(self, *args, **kwargs):
        self.field_uri = kwargs.pop(&#34;field_uri&#34;)
        if &#34;:&#34; in self.field_uri:
            raise ValueError(&#34;&#39;field_uri&#39; value must not contain a colon&#34;)
        super().__init__(*args, **kwargs)

    def from_xml(self, elem, account):
        field_elem = elem.find(self.response_tag())
        val = None if field_elem is None else field_elem.text or None
        if val is not None:
            return val
        return self.default

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        return set_xml_value(field_elem, value, version=version)

    def field_uri_xml(self, field_uri, label):
        from .properties import IndexedFieldURI

        return IndexedFieldURI(field_uri=f&#34;{field_uri}:{self.field_uri}&#34;, field_index=label).to_xml(version=None)

    def request_tag(self):
        return f&#34;t:{self.field_uri}&#34;

    def response_tag(self):
        return f&#34;{{{self.namespace}}}{self.field_uri}&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.SubField" href="#exchangelib.fields.SubField">SubField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.NamedSubField.field_uri_xml"><code class="name flex">
<span>def <span class="ident">field_uri_xml</span></span>(<span>self, field_uri, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def field_uri_xml(self, field_uri, label):
    from .properties import IndexedFieldURI

    return IndexedFieldURI(field_uri=f&#34;{field_uri}:{self.field_uri}&#34;, field_index=label).to_xml(version=None)</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.NamedSubField.request_tag"><code class="name flex">
<span>def <span class="ident">request_tag</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def request_tag(self):
    return f&#34;t:{self.field_uri}&#34;</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.NamedSubField.response_tag"><code class="name flex">
<span>def <span class="ident">response_tag</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def response_tag(self):
    return f&#34;{{{self.namespace}}}{self.field_uri}&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.SubField" href="#exchangelib.fields.SubField">SubField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.SubField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.SubField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.SubField.value_cls" href="#exchangelib.fields.SubField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.OccurrenceField"><code class="flex name class">
<span>class <span class="ident">OccurrenceField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OccurrenceField(EWSElementField):
    is_complex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.OccurrenceListField" href="#exchangelib.fields.OccurrenceListField">OccurrenceListField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.OccurrenceField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.OccurrenceListField"><code class="flex name class">
<span>class <span class="ident">OccurrenceListField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OccurrenceListField(OccurrenceField):
    is_list = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.OccurrenceField" href="#exchangelib.fields.OccurrenceField">OccurrenceField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.OccurrenceListField.is_list"><code class="name">var <span class="ident">is_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.OccurrenceField" href="#exchangelib.fields.OccurrenceField">OccurrenceField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.OccurrenceField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.OccurrenceField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.PermissionSetField"><code class="flex name class">
<span>class <span class="ident">PermissionSetField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PermissionSetField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .properties import PermissionSet

        kwargs[&#34;value_cls&#34;] = PermissionSet
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return value.to_xml(version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.PermissionSetField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.PersonaPhoneNumberField"><code class="flex name class">
<span>class <span class="ident">PersonaPhoneNumberField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PersonaPhoneNumberField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .properties import PhoneNumber

        kwargs[&#34;value_cls&#34;] = PhoneNumber
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.PersonaPhoneNumberField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.PhoneNumberAttributedValueField"><code class="flex name class">
<span>class <span class="ident">PhoneNumberAttributedValueField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EWSElementField, but for lists of EWSElement objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhoneNumberAttributedValueField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import PhoneNumberAttributedValue

        kwargs[&#34;value_cls&#34;] = PhoneNumberAttributedValue
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.PhoneNumberField"><code class="flex name class">
<span>class <span class="ident">PhoneNumberField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A base class for all indexed fields.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhoneNumberField(IndexedField):
    is_list = True
    is_complex = True

    PARENT_ELEMENT_NAME = &#34;PhoneNumbers&#34;

    def __init__(self, *args, **kwargs):
        from .indexed_properties import PhoneNumber

        kwargs[&#34;value_cls&#34;] = PhoneNumber
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.IndexedField" href="#exchangelib.fields.IndexedField">IndexedField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.PhoneNumberField.PARENT_ELEMENT_NAME"><code class="name">var <span class="ident">PARENT_ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.PhoneNumberField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.PhoneNumberField.is_list"><code class="name">var <span class="ident">is_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.IndexedField" href="#exchangelib.fields.IndexedField">IndexedField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.IndexedField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.IndexedField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.PhysicalAddressField"><code class="flex name class">
<span>class <span class="ident">PhysicalAddressField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A base class for all indexed fields.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhysicalAddressField(IndexedField):
    is_list = True
    is_complex = True

    PARENT_ELEMENT_NAME = &#34;PhysicalAddresses&#34;

    def __init__(self, *args, **kwargs):
        from .indexed_properties import PhysicalAddress

        kwargs[&#34;value_cls&#34;] = PhysicalAddress
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.IndexedField" href="#exchangelib.fields.IndexedField">IndexedField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.PhysicalAddressField.PARENT_ELEMENT_NAME"><code class="name">var <span class="ident">PARENT_ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.PhysicalAddressField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.PhysicalAddressField.is_list"><code class="name">var <span class="ident">is_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.IndexedField" href="#exchangelib.fields.IndexedField">IndexedField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.IndexedField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.IndexedField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.PostalAddressAttributedValueField"><code class="flex name class">
<span>class <span class="ident">PostalAddressAttributedValueField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EWSElementField, but for lists of EWSElement objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PostalAddressAttributedValueField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import PostalAddressAttributedValue

        kwargs[&#34;value_cls&#34;] = PostalAddressAttributedValue
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.RecipientAddressField"><code class="flex name class">
<span>class <span class="ident">RecipientAddressField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for EWSElement classes that have an 'email_address' field that we want to provide helpers for.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecipientAddressField(BaseEmailField):
    def __init__(self, *args, **kwargs):
        from .properties import RecipientAddress

        kwargs[&#34;value_cls&#34;] = RecipientAddress
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.BaseEmailField" href="#exchangelib.fields.BaseEmailField">BaseEmailField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.BaseEmailField" href="#exchangelib.fields.BaseEmailField">BaseEmailField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.BaseEmailField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.BaseEmailField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.RecurrenceField"><code class="flex name class">
<span>class <span class="ident">RecurrenceField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecurrenceField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .recurrence import Recurrence

        kwargs[&#34;value_cls&#34;] = Recurrence
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return value.to_xml(version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.RecurrenceField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.ReferenceItemIdField"><code class="flex name class">
<span>class <span class="ident">ReferenceItemIdField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReferenceItemIdField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .properties import ReferenceItemId

        kwargs[&#34;value_cls&#34;] = ReferenceItemId
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return value.to_xml(version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.ReferenceItemIdField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.RoutingTypeField"><code class="flex name class">
<span>class <span class="ident">RoutingTypeField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like CharField, but restricts the value to a limited set of strings.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoutingTypeField(ChoiceField):
    def __init__(self, *args, **kwargs):
        kwargs[&#34;choices&#34;] = {Choice(&#34;SMTP&#34;), Choice(&#34;EX&#34;)}
        kwargs[&#34;default&#34;] = &#34;SMTP&#34;
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.ChoiceField" href="#exchangelib.fields.ChoiceField">ChoiceField</a></li>
<li><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></li>
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.ChoiceField" href="#exchangelib.fields.ChoiceField">ChoiceField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.ChoiceField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.ChoiceField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.ChoiceField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.StringAttributedValueField"><code class="flex name class">
<span>class <span class="ident">StringAttributedValueField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EWSElementField, but for lists of EWSElement objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringAttributedValueField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import StringAttributedValue

        kwargs[&#34;value_cls&#34;] = StringAttributedValue
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.SubField"><code class="flex name class">
<span>class <span class="ident">SubField</span></span>
<span>(</span><span>name=None, is_required=False, is_required_after_save=False, is_read_only=False, is_read_only_after_send=False, is_searchable=True, is_attribute=False, default=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field to hold the value on an IndexedElement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SubField(Field):
    &#34;&#34;&#34;A field to hold the value on an IndexedElement.&#34;&#34;&#34;

    namespace = TNS
    value_cls = str

    def from_xml(self, elem, account):
        return elem.text

    def to_xml(self, value, version):
        return value

    @staticmethod
    def field_uri_xml(field_uri, label):
        from .properties import IndexedFieldURI

        return IndexedFieldURI(field_uri=field_uri, field_index=label).to_xml(version=None)

    def clean(self, value, version=None):
        value = super().clean(value, version=version)
        if self.is_required and not value:
            raise ValueError(f&#34;Value for subfield {self.name!r} must be non-empty&#34;)
        return value

    def __hash__(self):
        return hash(self.name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EmailSubField" href="#exchangelib.fields.EmailSubField">EmailSubField</a></li>
<li><a title="exchangelib.fields.NamedSubField" href="#exchangelib.fields.NamedSubField">NamedSubField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.SubField.namespace"><code class="name">var <span class="ident">namespace</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.SubField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.fields.SubField.field_uri_xml"><code class="name flex">
<span>def <span class="ident">field_uri_xml</span></span>(<span>field_uri, label)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def field_uri_xml(field_uri, label):
    from .properties import IndexedFieldURI

    return IndexedFieldURI(field_uri=field_uri, field_index=label).to_xml(version=None)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.SubField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    value = super().clean(value, version=version)
    if self.is_required and not value:
        raise ValueError(f&#34;Value for subfield {self.name!r} must be non-empty&#34;)
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.Field.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.Field.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.TaskRecurrenceField"><code class="flex name class">
<span>class <span class="ident">TaskRecurrenceField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic field for any EWSElement object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskRecurrenceField(EWSElementField):
    is_complex = True

    def __init__(self, *args, **kwargs):
        from .recurrence import TaskRecurrence

        kwargs[&#34;value_cls&#34;] = TaskRecurrence
        super().__init__(*args, **kwargs)

    def to_xml(self, value, version):
        return value.to_xml(version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.TaskRecurrenceField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.TextField"><code class="flex name class">
<span>class <span class="ident">TextField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that stores a string value with no length limit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextField(FieldURIField):
    &#34;&#34;&#34;A field that stores a string value with no length limit.&#34;&#34;&#34;

    value_cls = str
    is_complex = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.BodyField" href="#exchangelib.fields.BodyField">BodyField</a></li>
<li><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></li>
<li><a title="exchangelib.fields.MessageField" href="#exchangelib.fields.MessageField">MessageField</a></li>
<li><a title="exchangelib.fields.TextListField" href="#exchangelib.fields.TextListField">TextListField</a></li>
<li><a title="exchangelib.fields.URIField" href="#exchangelib.fields.URIField">URIField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.TextField.is_complex"><code class="name">var <span class="ident">is_complex</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.TextField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.TextListField"><code class="flex name class">
<span>class <span class="ident">TextListField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like TextField, but for lists of text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextListField(TextField):
    &#34;&#34;&#34;Like TextField, but for lists of text.&#34;&#34;&#34;

    is_list = True

    def __init__(self, *args, **kwargs):
        self.list_elem_name = kwargs.pop(&#34;list_elem_name&#34;, &#34;String&#34;)
        super().__init__(*args, **kwargs)

    def list_elem_request_tag(self):
        return f&#34;t:{self.list_elem_name}&#34;

    def list_elem_response_tag(self):
        return f&#34;{{{self.namespace}}}{self.list_elem_name}&#34;

    def from_xml(self, elem, account):
        iter_elem = elem.find(self.response_tag())
        if iter_elem is not None:
            return get_xml_attrs(iter_elem, self.list_elem_response_tag())
        return self.default

    def to_xml(self, value, version):
        field_elem = create_element(self.request_tag())
        for v in value:
            field_elem.append(set_xml_value(create_element(self.list_elem_request_tag()), v, version=version))
        return field_elem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.CharListField" href="#exchangelib.fields.CharListField">CharListField</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.TextListField.is_list"><code class="name">var <span class="ident">is_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.TextListField.list_elem_request_tag"><code class="name flex">
<span>def <span class="ident">list_elem_request_tag</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_elem_request_tag(self):
    return f&#34;t:{self.list_elem_name}&#34;</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.TextListField.list_elem_response_tag"><code class="name flex">
<span>def <span class="ident">list_elem_response_tag</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_elem_response_tag(self):
    return f&#34;{{{self.namespace}}}{self.list_elem_name}&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.TextField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.TimeDeltaField"><code class="flex name class">
<span>class <span class="ident">TimeDeltaField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that handles timedelta values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeDeltaField(FieldURIField):
    &#34;&#34;&#34;A field that handles timedelta values.&#34;&#34;&#34;

    value_cls = datetime.timedelta

    def __init__(self, *args, **kwargs):
        self.min = kwargs.pop(&#34;min&#34;, datetime.timedelta(0))
        self.max = kwargs.pop(&#34;max&#34;, datetime.timedelta(days=1))
        super().__init__(*args, **kwargs)

    def clean(self, value, version=None):
        if self.min is not None and value &lt; self.min:
            raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be greater than {self.min}&#34;)
        if self.max is not None and value &gt; self.max:
            raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be less than {self.max}&#34;)
        return super().clean(value, version=version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.TimeDeltaField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"><p>Difference between two datetime values.</p>
<p>timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)</p>
<p>All arguments are optional and default to 0.
Arguments may be integers or floats, and may be positive or negative.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.TimeDeltaField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if self.min is not None and value &lt; self.min:
        raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be greater than {self.min}&#34;)
    if self.max is not None and value &gt; self.max:
        raise ValueError(f&#34;Value {value!r} on field {self.name!r} must be less than {self.max}&#34;)
    return super().clean(value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.TimeField"><code class="flex name class">
<span>class <span class="ident">TimeField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that handles time values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeField(FieldURIField):
    &#34;&#34;&#34;A field that handles time values.&#34;&#34;&#34;

    value_cls = datetime.time

    def from_xml(self, elem, account):
        val = self._get_val_from_elem(elem)
        if val is not None:
            with suppress(ValueError):
                if &#34;:&#34; in val:
                    # Assume a string of the form HH:MM:SS
                    return datetime.datetime.strptime(val, &#34;%H:%M:%S&#34;).time()
                # Assume an integer in minutes since midnight
                return (datetime.datetime(2000, 1, 1) + datetime.timedelta(minutes=int(val))).time()
        return self.default</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.TimeField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"><p>time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) &ndash;&gt; a time object</p>
<p>All arguments are optional. tzinfo may be None, or an instance of
a tzinfo subclass. The remaining arguments may be ints.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.TimeZoneField"><code class="flex name class">
<span>class <span class="ident">TimeZoneField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A field that handles timezone values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeZoneField(FieldURIField):
    &#34;&#34;&#34;A field that handles timezone values.&#34;&#34;&#34;

    value_cls = EWSTimeZone

    def clean(self, value, version=None):
        # Allow other timezone implementations as input
        if value is not None:
            value = self.value_cls.from_timezone(value)
        return super().clean(value=value, version=version)

    def from_xml(self, elem, account):
        field_elem = elem.find(self.response_tag())
        if field_elem is not None:
            ms_id = field_elem.get(&#34;Id&#34;)
            ms_name = field_elem.get(&#34;Name&#34;)
            try:
                return self.value_cls.from_ms_id(ms_id or ms_name)
            except UnknownTimeZone:
                log.warning(
                    &#34;Cannot convert value &#39;%s&#39; on field &#39;%s&#39; to type %s (unknown timezone ID)&#34;,
                    (ms_id or ms_name),
                    self.name,
                    self.value_cls,
                )
                return None
        return self.default

    def to_xml(self, value, version):
        attrs = dict(Id=value.ms_id)
        if value.ms_name:
            attrs[&#34;Name&#34;] = value.ms_name
        return create_element(self.request_tag(), attrs=attrs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.TimeZoneField.value_cls"><code class="name">var <span class="ident">value_cls</span></code></dt>
<dd>
<div class="desc"><p>Represents a time zone as expected by the EWS TimezoneContext / TimezoneDefinition XML element, and returned by
services.GetServerTimeZones.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.TimeZoneField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    # Allow other timezone implementations as input
    if value is not None:
        value = self.value_cls.from_timezone(value)
    return super().clean(value=value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.TransitionListField"><code class="flex name class">
<span>class <span class="ident">TransitionListField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EWSElementField, but for lists of EWSElement objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransitionListField(EWSElementListField):
    def __init__(self, *args, **kwargs):
        from .properties import BaseTransition

        kwargs[&#34;value_cls&#34;] = BaseTransition
        super().__init__(*args, **kwargs)

    def from_xml(self, elem, account):
        iter_elem = elem.find(self.response_tag()) if self.field_uri else elem
        if iter_elem is not None:
            return [
                self.value_cls.transition_model_from_tag(e.tag).from_xml(elem=e, account=account) for e in iter_elem
            ]
        return self.default</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></li>
<li><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EWSElementListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.TypeValueField"><code class="flex name class">
<span>class <span class="ident">TypeValueField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This field type has no value_cls because values may have many types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TypeValueField(FieldURIField):
    &#34;&#34;&#34;This field type has no value_cls because values may have many types.&#34;&#34;&#34;

    TYPES_MAP = {
        &#34;Boolean&#34;: bool,
        &#34;Integer32&#34;: int,
        &#34;UnsignedInteger32&#34;: int,
        &#34;Integer64&#34;: int,
        &#34;UnsignedInteger64&#34;: int,
        # Python doesn&#39;t have a single-byte type to represent &#39;Byte&#39;
        &#34;ByteArray&#34;: bytes,
        &#34;String&#34;: str,
        &#34;StringArray&#34;: str,  # A list of strings
        &#34;DateTime&#34;: EWSDateTime,
    }
    TYPES_MAP_REVERSED = {
        bool: &#34;Boolean&#34;,
        int: &#34;Integer64&#34;,
        # Python doesn&#39;t have a single-byte type to represent &#39;Byte&#39;
        bytes: &#34;ByteArray&#34;,
        str: &#34;String&#34;,
        datetime.datetime: &#34;DateTime&#34;,
        EWSDateTime: &#34;DateTime&#34;,
    }

    @classmethod
    def get_type(cls, value):
        if isinstance(value, bytes) and len(value) == 1:
            # This is a single byte. Translate it to the &#39;Byte&#39; type
            return &#34;Byte&#34;
        if is_iterable(value):
            # We don&#39;t allow generators as values, so keep the logic simple
            try:
                first = next(iter(value))
            except StopIteration:
                first = None
            value_type = f&#34;{cls.TYPES_MAP_REVERSED[type(first)]}Array&#34;
            if value_type not in cls.TYPES_MAP:
                raise ValueError(f&#34;{value!r} is not a supported type&#34;)
            return value_type
        return cls.TYPES_MAP_REVERSED[type(value)]

    @classmethod
    def is_array_type(cls, value_type):
        return value_type == &#34;StringArray&#34;

    def clean(self, value, version=None):
        if value is None:
            if self.is_required and self.default is None:
                raise ValueError(f&#34;{self.name!r} is a required field with no default&#34;)
            return self.default
        return value

    def from_xml(self, elem, account):
        field_elem = elem.find(self.response_tag())
        if field_elem is None:
            return self.default
        value_type_str = get_xml_attr(field_elem, f&#34;{{{TNS}}}Type&#34;)
        value = get_xml_attr(field_elem, f&#34;{{{TNS}}}Value&#34;)
        if value_type_str == &#34;Byte&#34;:
            try:
                # The value is an unsigned integer in the range 0 -&gt; 255. Convert it to a single byte
                return xml_text_to_value(value, int).to_bytes(1, &#34;little&#34;, signed=False)
            except OverflowError as e:
                log.warning(&#34;Invalid byte value %r (%e)&#34;, value, e)
                return None
        value_type = self.TYPES_MAP[value_type_str]
        if self.is_array_type(value_type_str):
            return tuple(xml_text_to_value(value=v, value_type=value_type) for v in value.split(&#34; &#34;))
        return xml_text_to_value(value=value, value_type=value_type)

    def to_xml(self, value, version):
        value_type_str = self.get_type(value)
        if value_type_str == &#34;Byte&#34;:
            # A single byte is encoded to an unsigned integer in the range 0 -&gt; 255
            value = int.from_bytes(value, byteorder=&#34;little&#34;, signed=False)
        elif is_iterable(value):
            value = &#34; &#34;.join(value_to_xml_text(v) for v in value)
        field_elem = create_element(self.request_tag())
        field_elem.append(set_xml_value(create_element(&#34;t:Type&#34;), value_type_str, version=version))
        field_elem.append(set_xml_value(create_element(&#34;t:Value&#34;), value, version=version))
        return field_elem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.fields.TypeValueField.TYPES_MAP"><code class="name">var <span class="ident">TYPES_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.fields.TypeValueField.TYPES_MAP_REVERSED"><code class="name">var <span class="ident">TYPES_MAP_REVERSED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.fields.TypeValueField.get_type"><code class="name flex">
<span>def <span class="ident">get_type</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_type(cls, value):
    if isinstance(value, bytes) and len(value) == 1:
        # This is a single byte. Translate it to the &#39;Byte&#39; type
        return &#34;Byte&#34;
    if is_iterable(value):
        # We don&#39;t allow generators as values, so keep the logic simple
        try:
            first = next(iter(value))
        except StopIteration:
            first = None
        value_type = f&#34;{cls.TYPES_MAP_REVERSED[type(first)]}Array&#34;
        if value_type not in cls.TYPES_MAP:
            raise ValueError(f&#34;{value!r} is not a supported type&#34;)
        return value_type
    return cls.TYPES_MAP_REVERSED[type(value)]</code></pre>
</details>
</dd>
<dt id="exchangelib.fields.TypeValueField.is_array_type"><code class="name flex">
<span>def <span class="ident">is_array_type</span></span>(<span>value_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_array_type(cls, value_type):
    return value_type == &#34;StringArray&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.TypeValueField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if value is None:
        if self.is_required and self.default is None:
            raise ValueError(f&#34;{self.name!r} is a required field with no default&#34;)
        return self.default
    return value</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.FieldURIField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.URIField"><code class="flex name class">
<span>class <span class="ident">URIField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to mark strings that must conform to xsd:anyURI.
If we want a URI validator, see <a href="https://stackoverflow.com/questions/14466585/is-this-regex-correct-for-xsdanyuri">https://stackoverflow.com/questions/14466585/is-this-regex-correct-for-xsdanyuri</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class URIField(TextField):
    &#34;&#34;&#34;Helper to mark strings that must conform to xsd:anyURI.
    If we want a URI validator, see https://stackoverflow.com/questions/14466585/is-this-regex-correct-for-xsdanyuri
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.TextField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.TextField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.UnknownEntriesField"><code class="flex name class">
<span>class <span class="ident">UnknownEntriesField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like TextListField, but for string values with a limited length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnknownEntriesField(CharListField):
    def list_elem_tag(self):
        return f&#34;{{{self.namespace}}}UnknownEntry&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.CharListField" href="#exchangelib.fields.CharListField">CharListField</a></li>
<li><a title="exchangelib.fields.TextListField" href="#exchangelib.fields.TextListField">TextListField</a></li>
<li><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.UnknownEntriesField.list_elem_tag"><code class="name flex">
<span>def <span class="ident">list_elem_tag</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_elem_tag(self):
    return f&#34;{{{self.namespace}}}UnknownEntry&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.CharListField" href="#exchangelib.fields.CharListField">CharListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.CharListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.CharListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.CharListField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.fields.WeekdaysField"><code class="flex name class">
<span>class <span class="ident">WeekdaysField</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like EnumListField, allow a single value instead of a 1-element list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WeekdaysField(EnumListField):
    &#34;&#34;&#34;Like EnumListField, allow a single value instead of a 1-element list.&#34;&#34;&#34;

    def clean(self, value, version=None):
        if isinstance(value, (int, str)):
            value = [value]
        return super().clean(value, version)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.fields.EnumListField" href="#exchangelib.fields.EnumListField">EnumListField</a></li>
<li><a title="exchangelib.fields.EnumField" href="#exchangelib.fields.EnumField">EnumField</a></li>
<li><a title="exchangelib.fields.IntegerField" href="#exchangelib.fields.IntegerField">IntegerField</a></li>
<li><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></li>
<li><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></li>
<li><a title="exchangelib.version.SupportedVersionInstanceMixIn" href="version.html#exchangelib.version.SupportedVersionInstanceMixIn">SupportedVersionInstanceMixIn</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.fields.WeekdaysField.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, value, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, value, version=None):
    if isinstance(value, (int, str)):
        value = [value]
    return super().clean(value, version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.fields.EnumListField" href="#exchangelib.fields.EnumListField">EnumListField</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.fields.EnumListField.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.EnumListField.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.EnumListField.value_cls" href="#exchangelib.fields.IntegerField.value_cls">value_cls</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exchangelib" href="index.html">exchangelib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="exchangelib.fields.resolve_field_path" href="#exchangelib.fields.resolve_field_path">resolve_field_path</a></code></li>
<li><code><a title="exchangelib.fields.split_field_path" href="#exchangelib.fields.split_field_path">split_field_path</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.fields.AppointmentStateField" href="#exchangelib.fields.AppointmentStateField">AppointmentStateField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.AppointmentStateField.CANCELLED" href="#exchangelib.fields.AppointmentStateField.CANCELLED">CANCELLED</a></code></li>
<li><code><a title="exchangelib.fields.AppointmentStateField.MEETING" href="#exchangelib.fields.AppointmentStateField.MEETING">MEETING</a></code></li>
<li><code><a title="exchangelib.fields.AppointmentStateField.NONE" href="#exchangelib.fields.AppointmentStateField.NONE">NONE</a></code></li>
<li><code><a title="exchangelib.fields.AppointmentStateField.RECEIVED" href="#exchangelib.fields.AppointmentStateField.RECEIVED">RECEIVED</a></code></li>
<li><code><a title="exchangelib.fields.AppointmentStateField.STATES" href="#exchangelib.fields.AppointmentStateField.STATES">STATES</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.AssociatedCalendarItemIdField" href="#exchangelib.fields.AssociatedCalendarItemIdField">AssociatedCalendarItemIdField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.AssociatedCalendarItemIdField.is_complex" href="#exchangelib.fields.AssociatedCalendarItemIdField.is_complex">is_complex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.AttachmentField" href="#exchangelib.fields.AttachmentField">AttachmentField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.AttendeesField" href="#exchangelib.fields.AttendeesField">AttendeesField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.AttendeesField.clean" href="#exchangelib.fields.AttendeesField.clean">clean</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.Base64Field" href="#exchangelib.fields.Base64Field">Base64Field</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.Base64Field.is_complex" href="#exchangelib.fields.Base64Field.is_complex">is_complex</a></code></li>
<li><code><a title="exchangelib.fields.Base64Field.value_cls" href="#exchangelib.fields.Base64Field.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.BaseEmailField" href="#exchangelib.fields.BaseEmailField">BaseEmailField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.BaseEmailField.clean" href="#exchangelib.fields.BaseEmailField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.BaseEmailField.is_complex" href="#exchangelib.fields.BaseEmailField.is_complex">is_complex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.BodyContentAttributedValueField" href="#exchangelib.fields.BodyContentAttributedValueField">BodyContentAttributedValueField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.BodyContentAttributedValueField.is_complex" href="#exchangelib.fields.BodyContentAttributedValueField.is_complex">is_complex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.BodyField" href="#exchangelib.fields.BodyField">BodyField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.BodyField.clean" href="#exchangelib.fields.BodyField.clean">clean</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.BooleanField" href="#exchangelib.fields.BooleanField">BooleanField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.BooleanField.value_cls" href="#exchangelib.fields.BooleanField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.CharField" href="#exchangelib.fields.CharField">CharField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.CharField.clean" href="#exchangelib.fields.CharField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.CharField.is_complex" href="#exchangelib.fields.CharField.is_complex">is_complex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.CharListField" href="#exchangelib.fields.CharListField">CharListField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.CharListField.clean" href="#exchangelib.fields.CharListField.clean">clean</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.Choice" href="#exchangelib.fields.Choice">Choice</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.ChoiceField" href="#exchangelib.fields.ChoiceField">ChoiceField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.ChoiceField.clean" href="#exchangelib.fields.ChoiceField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.ChoiceField.supported_choices" href="#exchangelib.fields.ChoiceField.supported_choices">supported_choices</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.CultureField" href="#exchangelib.fields.CultureField">CultureField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.DateField" href="#exchangelib.fields.DateField">DateField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.DateField.clean" href="#exchangelib.fields.DateField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.DateField.value_cls" href="#exchangelib.fields.DateField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.DateOrDateTimeField" href="#exchangelib.fields.DateOrDateTimeField">DateOrDateTimeField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.DateOrDateTimeField.clean" href="#exchangelib.fields.DateOrDateTimeField.clean">clean</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.DateTimeBackedDateField" href="#exchangelib.fields.DateTimeBackedDateField">DateTimeBackedDateField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.DateTimeBackedDateField.date_to_datetime" href="#exchangelib.fields.DateTimeBackedDateField.date_to_datetime">date_to_datetime</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.DateTimeField" href="#exchangelib.fields.DateTimeField">DateTimeField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.DateTimeField.clean" href="#exchangelib.fields.DateTimeField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.DateTimeField.value_cls" href="#exchangelib.fields.DateTimeField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.DecimalField" href="#exchangelib.fields.DecimalField">DecimalField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.DictionaryField" href="#exchangelib.fields.DictionaryField">DictionaryField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.DictionaryField.clean" href="#exchangelib.fields.DictionaryField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.DictionaryField.value_cls" href="#exchangelib.fields.DictionaryField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.EWSElementField" href="#exchangelib.fields.EWSElementField">EWSElementField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.EWSElementField.value_cls" href="#exchangelib.fields.EWSElementField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.EWSElementListField" href="#exchangelib.fields.EWSElementListField">EWSElementListField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.EWSElementListField.is_complex" href="#exchangelib.fields.EWSElementListField.is_complex">is_complex</a></code></li>
<li><code><a title="exchangelib.fields.EWSElementListField.is_list" href="#exchangelib.fields.EWSElementListField.is_list">is_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.EffectiveRightsField" href="#exchangelib.fields.EffectiveRightsField">EffectiveRightsField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.EmailAddressAttributedValueField" href="#exchangelib.fields.EmailAddressAttributedValueField">EmailAddressAttributedValueField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.EmailAddressField" href="#exchangelib.fields.EmailAddressField">EmailAddressField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.EmailAddressesField" href="#exchangelib.fields.EmailAddressesField">EmailAddressesField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.EmailAddressesField.PARENT_ELEMENT_NAME" href="#exchangelib.fields.EmailAddressesField.PARENT_ELEMENT_NAME">PARENT_ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.fields.EmailAddressesField.clean" href="#exchangelib.fields.EmailAddressesField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.EmailAddressesField.is_complex" href="#exchangelib.fields.EmailAddressesField.is_complex">is_complex</a></code></li>
<li><code><a title="exchangelib.fields.EmailAddressesField.is_list" href="#exchangelib.fields.EmailAddressesField.is_list">is_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.EmailField" href="#exchangelib.fields.EmailField">EmailField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.EmailSubField" href="#exchangelib.fields.EmailSubField">EmailSubField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.EnumAsIntField" href="#exchangelib.fields.EnumAsIntField">EnumAsIntField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.EnumField" href="#exchangelib.fields.EnumField">EnumField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.EnumField.as_string" href="#exchangelib.fields.EnumField.as_string">as_string</a></code></li>
<li><code><a title="exchangelib.fields.EnumField.clean" href="#exchangelib.fields.EnumField.clean">clean</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.EnumListField" href="#exchangelib.fields.EnumListField">EnumListField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.EnumListField.is_list" href="#exchangelib.fields.EnumListField.is_list">is_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.ExtendedPropertyField" href="#exchangelib.fields.ExtendedPropertyField">ExtendedPropertyField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.ExtendedPropertyField.clean" href="#exchangelib.fields.ExtendedPropertyField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.ExtendedPropertyField.field_uri_xml" href="#exchangelib.fields.ExtendedPropertyField.field_uri_xml">field_uri_xml</a></code></li>
<li><code><a title="exchangelib.fields.ExtendedPropertyField.is_complex" href="#exchangelib.fields.ExtendedPropertyField.is_complex">is_complex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.ExtendedPropertyListField" href="#exchangelib.fields.ExtendedPropertyListField">ExtendedPropertyListField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.ExtendedPropertyListField.is_list" href="#exchangelib.fields.ExtendedPropertyListField.is_list">is_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.Field" href="#exchangelib.fields.Field">Field</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.fields.Field.clean" href="#exchangelib.fields.Field.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.Field.from_xml" href="#exchangelib.fields.Field.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.fields.Field.is_complex" href="#exchangelib.fields.Field.is_complex">is_complex</a></code></li>
<li><code><a title="exchangelib.fields.Field.is_list" href="#exchangelib.fields.Field.is_list">is_list</a></code></li>
<li><code><a title="exchangelib.fields.Field.to_xml" href="#exchangelib.fields.Field.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.fields.Field.value_cls" href="#exchangelib.fields.Field.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.FieldOrder" href="#exchangelib.fields.FieldOrder">FieldOrder</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.FieldOrder.from_string" href="#exchangelib.fields.FieldOrder.from_string">from_string</a></code></li>
<li><code><a title="exchangelib.fields.FieldOrder.to_xml" href="#exchangelib.fields.FieldOrder.to_xml">to_xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.FieldPath" href="#exchangelib.fields.FieldPath">FieldPath</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.fields.FieldPath.expand" href="#exchangelib.fields.FieldPath.expand">expand</a></code></li>
<li><code><a title="exchangelib.fields.FieldPath.from_string" href="#exchangelib.fields.FieldPath.from_string">from_string</a></code></li>
<li><code><a title="exchangelib.fields.FieldPath.get_sort_value" href="#exchangelib.fields.FieldPath.get_sort_value">get_sort_value</a></code></li>
<li><code><a title="exchangelib.fields.FieldPath.get_value" href="#exchangelib.fields.FieldPath.get_value">get_value</a></code></li>
<li><code><a title="exchangelib.fields.FieldPath.path" href="#exchangelib.fields.FieldPath.path">path</a></code></li>
<li><code><a title="exchangelib.fields.FieldPath.to_xml" href="#exchangelib.fields.FieldPath.to_xml">to_xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.FieldURIField" href="#exchangelib.fields.FieldURIField">FieldURIField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.FieldURIField.field_uri_xml" href="#exchangelib.fields.FieldURIField.field_uri_xml">field_uri_xml</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.request_tag" href="#exchangelib.fields.FieldURIField.request_tag">request_tag</a></code></li>
<li><code><a title="exchangelib.fields.FieldURIField.response_tag" href="#exchangelib.fields.FieldURIField.response_tag">response_tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.FreeBusyStatusField" href="#exchangelib.fields.FreeBusyStatusField">FreeBusyStatusField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.GenericEventListField" href="#exchangelib.fields.GenericEventListField">GenericEventListField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.GenericEventListField.is_list" href="#exchangelib.fields.GenericEventListField.is_list">is_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.IdElementField" href="#exchangelib.fields.IdElementField">IdElementField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.IdField" href="#exchangelib.fields.IdField">IdField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.IndexedField" href="#exchangelib.fields.IndexedField">IndexedField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.IndexedField.PARENT_ELEMENT_NAME" href="#exchangelib.fields.IndexedField.PARENT_ELEMENT_NAME">PARENT_ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.fields.IndexedField.response_tag" href="#exchangelib.fields.IndexedField.response_tag">response_tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.IntegerField" href="#exchangelib.fields.IntegerField">IntegerField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.IntegerField.clean" href="#exchangelib.fields.IntegerField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.IntegerField.value_cls" href="#exchangelib.fields.IntegerField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.InvalidChoiceForVersion" href="#exchangelib.fields.InvalidChoiceForVersion">InvalidChoiceForVersion</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.InvalidField" href="#exchangelib.fields.InvalidField">InvalidField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.InvalidFieldForVersion" href="#exchangelib.fields.InvalidFieldForVersion">InvalidFieldForVersion</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.ItemField" href="#exchangelib.fields.ItemField">ItemField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.ItemField.value_cls" href="#exchangelib.fields.ItemField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.LabelField" href="#exchangelib.fields.LabelField">LabelField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.MailboxField" href="#exchangelib.fields.MailboxField">MailboxField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.MailboxListField" href="#exchangelib.fields.MailboxListField">MailboxListField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.MailboxListField.clean" href="#exchangelib.fields.MailboxListField.clean">clean</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.MemberListField" href="#exchangelib.fields.MemberListField">MemberListField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.MemberListField.clean" href="#exchangelib.fields.MemberListField.clean">clean</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.MessageField" href="#exchangelib.fields.MessageField">MessageField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.MessageField.INNER_ELEMENT_NAME" href="#exchangelib.fields.MessageField.INNER_ELEMENT_NAME">INNER_ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.MessageHeaderField" href="#exchangelib.fields.MessageHeaderField">MessageHeaderField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.MimeContentField" href="#exchangelib.fields.MimeContentField">MimeContentField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.NamedSubField" href="#exchangelib.fields.NamedSubField">NamedSubField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.NamedSubField.field_uri_xml" href="#exchangelib.fields.NamedSubField.field_uri_xml">field_uri_xml</a></code></li>
<li><code><a title="exchangelib.fields.NamedSubField.request_tag" href="#exchangelib.fields.NamedSubField.request_tag">request_tag</a></code></li>
<li><code><a title="exchangelib.fields.NamedSubField.response_tag" href="#exchangelib.fields.NamedSubField.response_tag">response_tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.OccurrenceField" href="#exchangelib.fields.OccurrenceField">OccurrenceField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.OccurrenceField.is_complex" href="#exchangelib.fields.OccurrenceField.is_complex">is_complex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.OccurrenceListField" href="#exchangelib.fields.OccurrenceListField">OccurrenceListField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.OccurrenceListField.is_list" href="#exchangelib.fields.OccurrenceListField.is_list">is_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.PermissionSetField" href="#exchangelib.fields.PermissionSetField">PermissionSetField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.PermissionSetField.is_complex" href="#exchangelib.fields.PermissionSetField.is_complex">is_complex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.PersonaPhoneNumberField" href="#exchangelib.fields.PersonaPhoneNumberField">PersonaPhoneNumberField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.PersonaPhoneNumberField.is_complex" href="#exchangelib.fields.PersonaPhoneNumberField.is_complex">is_complex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.PhoneNumberAttributedValueField" href="#exchangelib.fields.PhoneNumberAttributedValueField">PhoneNumberAttributedValueField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.PhoneNumberField" href="#exchangelib.fields.PhoneNumberField">PhoneNumberField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.PhoneNumberField.PARENT_ELEMENT_NAME" href="#exchangelib.fields.PhoneNumberField.PARENT_ELEMENT_NAME">PARENT_ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.fields.PhoneNumberField.is_complex" href="#exchangelib.fields.PhoneNumberField.is_complex">is_complex</a></code></li>
<li><code><a title="exchangelib.fields.PhoneNumberField.is_list" href="#exchangelib.fields.PhoneNumberField.is_list">is_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.PhysicalAddressField" href="#exchangelib.fields.PhysicalAddressField">PhysicalAddressField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.PhysicalAddressField.PARENT_ELEMENT_NAME" href="#exchangelib.fields.PhysicalAddressField.PARENT_ELEMENT_NAME">PARENT_ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.fields.PhysicalAddressField.is_complex" href="#exchangelib.fields.PhysicalAddressField.is_complex">is_complex</a></code></li>
<li><code><a title="exchangelib.fields.PhysicalAddressField.is_list" href="#exchangelib.fields.PhysicalAddressField.is_list">is_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.PostalAddressAttributedValueField" href="#exchangelib.fields.PostalAddressAttributedValueField">PostalAddressAttributedValueField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.RecipientAddressField" href="#exchangelib.fields.RecipientAddressField">RecipientAddressField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.RecurrenceField" href="#exchangelib.fields.RecurrenceField">RecurrenceField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.RecurrenceField.is_complex" href="#exchangelib.fields.RecurrenceField.is_complex">is_complex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.ReferenceItemIdField" href="#exchangelib.fields.ReferenceItemIdField">ReferenceItemIdField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.ReferenceItemIdField.is_complex" href="#exchangelib.fields.ReferenceItemIdField.is_complex">is_complex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.RoutingTypeField" href="#exchangelib.fields.RoutingTypeField">RoutingTypeField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.StringAttributedValueField" href="#exchangelib.fields.StringAttributedValueField">StringAttributedValueField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.SubField" href="#exchangelib.fields.SubField">SubField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.SubField.clean" href="#exchangelib.fields.SubField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.SubField.field_uri_xml" href="#exchangelib.fields.SubField.field_uri_xml">field_uri_xml</a></code></li>
<li><code><a title="exchangelib.fields.SubField.namespace" href="#exchangelib.fields.SubField.namespace">namespace</a></code></li>
<li><code><a title="exchangelib.fields.SubField.value_cls" href="#exchangelib.fields.SubField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.TaskRecurrenceField" href="#exchangelib.fields.TaskRecurrenceField">TaskRecurrenceField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.TaskRecurrenceField.is_complex" href="#exchangelib.fields.TaskRecurrenceField.is_complex">is_complex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.TextField" href="#exchangelib.fields.TextField">TextField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.TextField.is_complex" href="#exchangelib.fields.TextField.is_complex">is_complex</a></code></li>
<li><code><a title="exchangelib.fields.TextField.value_cls" href="#exchangelib.fields.TextField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.TextListField" href="#exchangelib.fields.TextListField">TextListField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.TextListField.is_list" href="#exchangelib.fields.TextListField.is_list">is_list</a></code></li>
<li><code><a title="exchangelib.fields.TextListField.list_elem_request_tag" href="#exchangelib.fields.TextListField.list_elem_request_tag">list_elem_request_tag</a></code></li>
<li><code><a title="exchangelib.fields.TextListField.list_elem_response_tag" href="#exchangelib.fields.TextListField.list_elem_response_tag">list_elem_response_tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.TimeDeltaField" href="#exchangelib.fields.TimeDeltaField">TimeDeltaField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.TimeDeltaField.clean" href="#exchangelib.fields.TimeDeltaField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.TimeDeltaField.value_cls" href="#exchangelib.fields.TimeDeltaField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.TimeField" href="#exchangelib.fields.TimeField">TimeField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.TimeField.value_cls" href="#exchangelib.fields.TimeField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.TimeZoneField" href="#exchangelib.fields.TimeZoneField">TimeZoneField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.TimeZoneField.clean" href="#exchangelib.fields.TimeZoneField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.TimeZoneField.value_cls" href="#exchangelib.fields.TimeZoneField.value_cls">value_cls</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.TransitionListField" href="#exchangelib.fields.TransitionListField">TransitionListField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.TypeValueField" href="#exchangelib.fields.TypeValueField">TypeValueField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.TypeValueField.TYPES_MAP" href="#exchangelib.fields.TypeValueField.TYPES_MAP">TYPES_MAP</a></code></li>
<li><code><a title="exchangelib.fields.TypeValueField.TYPES_MAP_REVERSED" href="#exchangelib.fields.TypeValueField.TYPES_MAP_REVERSED">TYPES_MAP_REVERSED</a></code></li>
<li><code><a title="exchangelib.fields.TypeValueField.clean" href="#exchangelib.fields.TypeValueField.clean">clean</a></code></li>
<li><code><a title="exchangelib.fields.TypeValueField.get_type" href="#exchangelib.fields.TypeValueField.get_type">get_type</a></code></li>
<li><code><a title="exchangelib.fields.TypeValueField.is_array_type" href="#exchangelib.fields.TypeValueField.is_array_type">is_array_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.URIField" href="#exchangelib.fields.URIField">URIField</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.fields.UnknownEntriesField" href="#exchangelib.fields.UnknownEntriesField">UnknownEntriesField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.UnknownEntriesField.list_elem_tag" href="#exchangelib.fields.UnknownEntriesField.list_elem_tag">list_elem_tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.fields.WeekdaysField" href="#exchangelib.fields.WeekdaysField">WeekdaysField</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.fields.WeekdaysField.clean" href="#exchangelib.fields.WeekdaysField.clean">clean</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
