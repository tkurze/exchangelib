<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exchangelib API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>exchangelib</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .account import Account, Identity
from .attachments import FileAttachment, ItemAttachment
from .autodiscover import discover
from .configuration import Configuration, O365InteractiveConfiguration
from .credentials import (
    DELEGATE,
    IMPERSONATION,
    Credentials,
    OAuth2AuthorizationCodeCredentials,
    OAuth2Credentials,
    OAuth2LegacyCredentials,
)
from .ewsdatetime import UTC, UTC_NOW, EWSDate, EWSDateTime, EWSTimeZone
from .extended_properties import ExtendedProperty
from .folders import DEEP, SHALLOW, Folder, FolderCollection, RootOfHierarchy
from .items import (
    AcceptItem,
    CalendarItem,
    CancelCalendarItem,
    Contact,
    DeclineItem,
    DistributionList,
    ForwardItem,
    Message,
    PostItem,
    PostReplyItem,
    ReplyAllToItem,
    ReplyToItem,
    Task,
    TentativelyAcceptItem,
)
from .properties import UID, Attendee, Body, DLMailbox, HTMLBody, ItemId, Mailbox, Room, RoomList
from .protocol import BaseProtocol, FailFast, FaultTolerance, NoVerifyHTTPAdapter, TLSClientAuth
from .restriction import Q
from .settings import OofSettings
from .transport import BASIC, CBA, DIGEST, GSSAPI, NTLM, OAUTH2, SSPI
from .version import Build, Version

__version__ = &#34;5.4.3&#34;

__all__ = [
    &#34;AcceptItem&#34;,
    &#34;Account&#34;,
    &#34;Attendee&#34;,
    &#34;BASIC&#34;,
    &#34;BaseProtocol&#34;,
    &#34;Body&#34;,
    &#34;Build&#34;,
    &#34;CBA&#34;,
    &#34;CalendarItem&#34;,
    &#34;CancelCalendarItem&#34;,
    &#34;Configuration&#34;,
    &#34;Contact&#34;,
    &#34;Credentials&#34;,
    &#34;DEEP&#34;,
    &#34;DELEGATE&#34;,
    &#34;DIGEST&#34;,
    &#34;DLMailbox&#34;,
    &#34;DeclineItem&#34;,
    &#34;DistributionList&#34;,
    &#34;EWSDate&#34;,
    &#34;EWSDateTime&#34;,
    &#34;EWSTimeZone&#34;,
    &#34;ExtendedProperty&#34;,
    &#34;FailFast&#34;,
    &#34;FaultTolerance&#34;,
    &#34;FileAttachment&#34;,
    &#34;Folder&#34;,
    &#34;FolderCollection&#34;,
    &#34;ForwardItem&#34;,
    &#34;GSSAPI&#34;,
    &#34;HTMLBody&#34;,
    &#34;IMPERSONATION&#34;,
    &#34;Identity&#34;,
    &#34;ItemAttachment&#34;,
    &#34;ItemId&#34;,
    &#34;Mailbox&#34;,
    &#34;Message&#34;,
    &#34;NTLM&#34;,
    &#34;NoVerifyHTTPAdapter&#34;,
    &#34;O365InteractiveConfiguration&#34;,
    &#34;OAUTH2&#34;,
    &#34;OAuth2AuthorizationCodeCredentials&#34;,
    &#34;OAuth2Credentials&#34;,
    &#34;OAuth2LegacyCredentials&#34;,
    &#34;OofSettings&#34;,
    &#34;PostItem&#34;,
    &#34;PostReplyItem&#34;,
    &#34;Q&#34;,
    &#34;ReplyAllToItem&#34;,
    &#34;ReplyToItem&#34;,
    &#34;Room&#34;,
    &#34;RoomList&#34;,
    &#34;RootOfHierarchy&#34;,
    &#34;SHALLOW&#34;,
    &#34;SSPI&#34;,
    &#34;TLSClientAuth&#34;,
    &#34;Task&#34;,
    &#34;TentativelyAcceptItem&#34;,
    &#34;UID&#34;,
    &#34;UTC&#34;,
    &#34;UTC_NOW&#34;,
    &#34;Version&#34;,
    &#34;__version__&#34;,
    &#34;close_connections&#34;,
    &#34;discover&#34;,
]

# Set a default user agent, e.g. &#34;exchangelib/3.1.1 (python-requests/2.22.0)&#34;
import requests.utils

BaseProtocol.USERAGENT = f&#34;{__name__}/{__version__} ({requests.utils.default_user_agent()})&#34;


def close_connections():
    from .autodiscover import close_connections as close_autodiscover_connections
    from .protocol import close_connections as close_protocol_connections

    close_autodiscover_connections()
    close_protocol_connections()</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="exchangelib.account" href="account.html">exchangelib.account</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.attachments" href="attachments.html">exchangelib.attachments</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.autodiscover" href="autodiscover/index.html">exchangelib.autodiscover</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.configuration" href="configuration.html">exchangelib.configuration</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.credentials" href="credentials.html">exchangelib.credentials</a></code></dt>
<dd>
<div class="desc"><p>Implements an Exchange user object and access types. Exchange provides two different ways of granting access for a
login to a specific account …</p></div>
</dd>
<dt><code class="name"><a title="exchangelib.errors" href="errors.html">exchangelib.errors</a></code></dt>
<dd>
<div class="desc"><p>Stores errors specific to this package, and mirrors all the possible errors that EWS can return.</p></div>
</dd>
<dt><code class="name"><a title="exchangelib.ewsdatetime" href="ewsdatetime.html">exchangelib.ewsdatetime</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.extended_properties" href="extended_properties.html">exchangelib.extended_properties</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.fields" href="fields.html">exchangelib.fields</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.folders" href="folders/index.html">exchangelib.folders</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.indexed_properties" href="indexed_properties.html">exchangelib.indexed_properties</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.items" href="items/index.html">exchangelib.items</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.properties" href="properties.html">exchangelib.properties</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.protocol" href="protocol.html">exchangelib.protocol</a></code></dt>
<dd>
<div class="desc"><p>A protocol is an endpoint for EWS service connections. It contains all necessary information to make HTTPS connections …</p></div>
</dd>
<dt><code class="name"><a title="exchangelib.queryset" href="queryset.html">exchangelib.queryset</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.recurrence" href="recurrence.html">exchangelib.recurrence</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.restriction" href="restriction.html">exchangelib.restriction</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services" href="services/index.html">exchangelib.services</a></code></dt>
<dd>
<div class="desc"><p>Implement a selection of EWS services (operations) …</p></div>
</dd>
<dt><code class="name"><a title="exchangelib.settings" href="settings.html">exchangelib.settings</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.transport" href="transport.html">exchangelib.transport</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.util" href="util.html">exchangelib.util</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.version" href="version.html">exchangelib.version</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.winzone" href="winzone.html">exchangelib.winzone</a></code></dt>
<dd>
<div class="desc"><p>A dict to translate from IANA location name to Windows timezone name. Translations taken from CLDR_WINZONE_URL</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="exchangelib.UTC_NOW"><code class="name flex">
<span>def <span class="ident">UTC_NOW</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">UTC_NOW = lambda: EWSDateTime.now(tz=UTC)  # noqa: E731</code></pre>
</details>
</dd>
<dt id="exchangelib.close_connections"><code class="name flex">
<span>def <span class="ident">close_connections</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_connections():
    from .autodiscover import close_connections as close_autodiscover_connections
    from .protocol import close_connections as close_protocol_connections

    close_autodiscover_connections()
    close_protocol_connections()</code></pre>
</details>
</dd>
<dt id="exchangelib.discover"><code class="name flex">
<span>def <span class="ident">discover</span></span>(<span>email, credentials=None, auth_type=None, retry_policy=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover(email, credentials=None, auth_type=None, retry_policy=None):
    ad_response, protocol = Autodiscovery(email=email, credentials=credentials).discover()
    protocol.config.auth_typ = auth_type
    protocol.config.retry_policy = retry_policy
    return ad_response, protocol</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.AcceptItem"><code class="flex name class">
<span>class <span class="ident">AcceptItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/acceptitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/acceptitem</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AcceptItem(BaseMeetingReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/acceptitem&#34;&#34;&#34;

    ELEMENT_NAME = &#34;AcceptItem&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.AcceptItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Account"><code class="flex name class">
<span>class <span class="ident">Account</span></span>
<span>(</span><span>primary_smtp_address, fullname=None, access_type=None, autodiscover=False, credentials=None, config=None, locale=None, default_timezone=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Models an Exchange server user account.</p>
<p>:param primary_smtp_address: The primary email address associated with the account on the Exchange server
:param fullname: The full name of the account. Optional. (Default value = None)
:param access_type: The access type granted to 'credentials' for this account. Valid options are 'delegate'
and 'impersonation'. 'delegate' is default if 'credentials' is set. Otherwise, 'impersonation' is default.
:param autodiscover: Whether to look up the EWS endpoint automatically using the autodiscover protocol.
(Default value = False)
:param credentials: A Credentials object containing valid credentials for this account. (Default value = None)
:param config: A Configuration object containing EWS endpoint information. Required if autodiscover is disabled
(Default value = None)
:param locale: The locale of the user, e.g. 'en_US'. Defaults to the locale of the host, if available.
:param default_timezone: EWS may return some datetime values without timezone information. In this case, we will
assume values to be in the provided timezone. Defaults to the timezone of the host.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Account:
    &#34;&#34;&#34;Models an Exchange server user account.&#34;&#34;&#34;

    def __init__(
        self,
        primary_smtp_address,
        fullname=None,
        access_type=None,
        autodiscover=False,
        credentials=None,
        config=None,
        locale=None,
        default_timezone=None,
    ):
        &#34;&#34;&#34;

        :param primary_smtp_address: The primary email address associated with the account on the Exchange server
        :param fullname: The full name of the account. Optional. (Default value = None)
        :param access_type: The access type granted to &#39;credentials&#39; for this account. Valid options are &#39;delegate&#39;
            and &#39;impersonation&#39;. &#39;delegate&#39; is default if &#39;credentials&#39; is set. Otherwise, &#39;impersonation&#39; is default.
        :param autodiscover: Whether to look up the EWS endpoint automatically using the autodiscover protocol.
            (Default value = False)
        :param credentials: A Credentials object containing valid credentials for this account. (Default value = None)
        :param config: A Configuration object containing EWS endpoint information. Required if autodiscover is disabled
            (Default value = None)
        :param locale: The locale of the user, e.g. &#39;en_US&#39;. Defaults to the locale of the host, if available.
        :param default_timezone: EWS may return some datetime values without timezone information. In this case, we will
            assume values to be in the provided timezone. Defaults to the timezone of the host.
        :return:
        &#34;&#34;&#34;
        if &#34;@&#34; not in primary_smtp_address:
            raise ValueError(f&#34;primary_smtp_address {primary_smtp_address!r} is not an email address&#34;)
        self.fullname = fullname
        # Assume delegate access if individual credentials are provided. Else, assume service user with impersonation
        self.access_type = access_type or (DELEGATE if credentials else IMPERSONATION)
        if self.access_type not in ACCESS_TYPES:
            raise InvalidEnumValue(&#34;access_type&#34;, self.access_type, ACCESS_TYPES)
        try:
            # get_locale() might not be able to determine the locale
            self.locale = locale or stdlib_locale.getlocale()[0] or None
        except ValueError as e:
            # getlocale() may throw ValueError if it fails to parse the system locale
            log.warning(&#34;Failed to get locale (%s)&#34;, e)
            self.locale = None
        if not isinstance(self.locale, (type(None), str)):
            raise InvalidTypeError(&#34;locale&#34;, self.locale, str)
        if default_timezone:
            try:
                self.default_timezone = EWSTimeZone.from_timezone(default_timezone)
            except TypeError:
                raise InvalidTypeError(&#34;default_timezone&#34;, default_timezone, EWSTimeZone)
        else:
            try:
                self.default_timezone = EWSTimeZone.localzone()
            except (ValueError, UnknownTimeZone) as e:
                # There is no translation from local timezone name to Windows timezone name, or e failed to find the
                # local timezone.
                log.warning(&#34;%s. Fallback to UTC&#34;, e.args[0])
                self.default_timezone = UTC
        if not isinstance(config, (Configuration, type(None))):
            raise InvalidTypeError(&#34;config&#34;, config, Configuration)
        if autodiscover:
            if config:
                auth_type, retry_policy, version, max_connections = (
                    config.auth_type,
                    config.retry_policy,
                    config.version,
                    config.max_connections,
                )
                if not credentials:
                    credentials = config.credentials
            else:
                auth_type, retry_policy, version, max_connections = None, None, None, None
            self.ad_response, self.protocol = Autodiscovery(
                email=primary_smtp_address, credentials=credentials
            ).discover()
            # Let&#39;s not use the auth_package hint from the AD response. It could be incorrect and we can just guess.
            self.protocol.config.auth_type = auth_type
            if retry_policy:
                self.protocol.config.retry_policy = retry_policy
            if version:
                self.protocol.config.version = version
            self.protocol.max_connections = max_connections
            primary_smtp_address = self.ad_response.autodiscover_smtp_address
        else:
            if not config:
                raise AttributeError(&#34;non-autodiscover requires a config&#34;)
            self.ad_response = None
            self.protocol = Protocol(config=config)

        # Other ways of identifying the account can be added later
        self.identity = Identity(primary_smtp_address=primary_smtp_address)

        # For maintaining affinity in e.g. subscriptions
        self.affinity_cookie = None

        # We may need to override the default server version on a per-account basis because Microsoft may report one
        # server version up-front but delegate account requests to an older backend server. Create a new instance to
        # avoid changing the protocol version.
        self.version = self.protocol.version.copy()
        log.debug(&#34;Added account: %s&#34;, self)

    @property
    def primary_smtp_address(self):
        return self.identity.primary_smtp_address

    @threaded_cached_property
    def admin_audit_logs(self):
        return self.root.get_default_folder(AdminAuditLogs)

    @threaded_cached_property
    def archive_deleted_items(self):
        return self.archive_root.get_default_folder(ArchiveDeletedItems)

    @threaded_cached_property
    def archive_inbox(self):
        return self.archive_root.get_default_folder(ArchiveInbox)

    @threaded_cached_property
    def archive_msg_folder_root(self):
        return self.archive_root.get_default_folder(ArchiveMsgFolderRoot)

    @threaded_cached_property
    def archive_recoverable_items_deletions(self):
        return self.archive_root.get_default_folder(ArchiveRecoverableItemsDeletions)

    @threaded_cached_property
    def archive_recoverable_items_purges(self):
        return self.archive_root.get_default_folder(ArchiveRecoverableItemsPurges)

    @threaded_cached_property
    def archive_recoverable_items_root(self):
        return self.archive_root.get_default_folder(ArchiveRecoverableItemsRoot)

    @threaded_cached_property
    def archive_recoverable_items_versions(self):
        return self.archive_root.get_default_folder(ArchiveRecoverableItemsVersions)

    @threaded_cached_property
    def archive_root(self):
        return ArchiveRoot.get_distinguished(account=self)

    @threaded_cached_property
    def calendar(self):
        # If the account contains a shared calendar from a different user, that calendar will be in the folder list.
        # Attempt not to return one of those. An account may not always have a calendar called &#34;Calendar&#34;, but a
        # Calendar folder with a localized name instead. Return that, if it&#39;s available, but always prefer any
        # distinguished folder returned by the server.
        return self.root.get_default_folder(Calendar)

    @threaded_cached_property
    def conflicts(self):
        return self.root.get_default_folder(Conflicts)

    @threaded_cached_property
    def contacts(self):
        return self.root.get_default_folder(Contacts)

    @threaded_cached_property
    def conversation_history(self):
        return self.root.get_default_folder(ConversationHistory)

    @threaded_cached_property
    def directory(self):
        return self.root.get_default_folder(Directory)

    @threaded_cached_property
    def drafts(self):
        return self.root.get_default_folder(Drafts)

    @threaded_cached_property
    def favorites(self):
        return self.root.get_default_folder(Favorites)

    @threaded_cached_property
    def im_contact_list(self):
        return self.root.get_default_folder(IMContactList)

    @threaded_cached_property
    def inbox(self):
        return self.root.get_default_folder(Inbox)

    @threaded_cached_property
    def journal(self):
        return self.root.get_default_folder(Journal)

    @threaded_cached_property
    def junk(self):
        return self.root.get_default_folder(JunkEmail)

    @threaded_cached_property
    def local_failures(self):
        return self.root.get_default_folder(LocalFailures)

    @threaded_cached_property
    def msg_folder_root(self):
        return self.root.get_default_folder(MsgFolderRoot)

    @threaded_cached_property
    def my_contacts(self):
        return self.root.get_default_folder(MyContacts)

    @threaded_cached_property
    def notes(self):
        return self.root.get_default_folder(Notes)

    @threaded_cached_property
    def outbox(self):
        return self.root.get_default_folder(Outbox)

    @threaded_cached_property
    def people_connect(self):
        return self.root.get_default_folder(PeopleConnect)

    @threaded_cached_property
    def public_folders_root(self):
        return PublicFoldersRoot.get_distinguished(account=self)

    @threaded_cached_property
    def quick_contacts(self):
        return self.root.get_default_folder(QuickContacts)

    @threaded_cached_property
    def recipient_cache(self):
        return self.root.get_default_folder(RecipientCache)

    @threaded_cached_property
    def recoverable_items_deletions(self):
        return self.root.get_default_folder(RecoverableItemsDeletions)

    @threaded_cached_property
    def recoverable_items_purges(self):
        return self.root.get_default_folder(RecoverableItemsPurges)

    @threaded_cached_property
    def recoverable_items_root(self):
        return self.root.get_default_folder(RecoverableItemsRoot)

    @threaded_cached_property
    def recoverable_items_versions(self):
        return self.root.get_default_folder(RecoverableItemsVersions)

    @threaded_cached_property
    def root(self):
        return Root.get_distinguished(account=self)

    @threaded_cached_property
    def search_folders(self):
        return self.root.get_default_folder(SearchFolders)

    @threaded_cached_property
    def sent(self):
        return self.root.get_default_folder(SentItems)

    @threaded_cached_property
    def server_failures(self):
        return self.root.get_default_folder(ServerFailures)

    @threaded_cached_property
    def sync_issues(self):
        return self.root.get_default_folder(SyncIssues)

    @threaded_cached_property
    def tasks(self):
        return self.root.get_default_folder(Tasks)

    @threaded_cached_property
    def todo_search(self):
        return self.root.get_default_folder(ToDoSearch)

    @threaded_cached_property
    def trash(self):
        return self.root.get_default_folder(DeletedItems)

    @threaded_cached_property
    def voice_mail(self):
        return self.root.get_default_folder(VoiceMail)

    @property
    def domain(self):
        return get_domain(self.primary_smtp_address)

    @property
    def oof_settings(self):
        # We don&#39;t want to cache this property because then we can&#39;t easily get updates. &#39;threaded_cached_property&#39;
        # supports the &#39;del self.oof_settings&#39; syntax to invalidate the cache, but does not support custom setter
        # methods. Having a non-cached service call here goes against the assumption that properties are cheap, but the
        # alternative is to create get_oof_settings() and set_oof_settings(), and that&#39;s just too Java-ish for my taste.
        return GetUserOofSettings(account=self).get(
            mailbox=Mailbox(email_address=self.primary_smtp_address),
        )

    @oof_settings.setter
    def oof_settings(self, value):
        SetUserOofSettings(account=self).get(
            oof_settings=value,
            mailbox=Mailbox(email_address=self.primary_smtp_address),
        )

    def _consume_item_service(self, service_cls, items, chunk_size, kwargs):
        if isinstance(items, QuerySet):
            # We just want an iterator over the results
            items = iter(items)
        is_empty, items = peek(items)
        if is_empty:
            # We accept generators, so it&#39;s not always convenient for caller to know up-front if &#39;ids&#39; is empty. Allow
            # empty &#39;ids&#39; and return early.
            return
        kwargs[&#34;items&#34;] = items
        yield from service_cls(account=self, chunk_size=chunk_size).call(**kwargs)

    def export(self, items, chunk_size=None):
        &#34;&#34;&#34;Return export strings of the given items.

        :param items: An iterable containing the Items we want to export
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: A list of strings, the exported representation of the object
        &#34;&#34;&#34;
        return list(self._consume_item_service(service_cls=ExportItems, items=items, chunk_size=chunk_size, kwargs={}))

    def upload(self, data, chunk_size=None):
        &#34;&#34;&#34;Upload objects retrieved from an export to the given folders.

        :param data: An iterable of tuples containing the folder we want to upload the data to and the string outputs of
            exports. If you want to update items instead of create, the data must be a tuple of
            (ItemId, is_associated, data) values.
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: A list of tuples with the new ids and changekeys

          Example:
          account.upload([
              (account.inbox, &#34;AABBCC...&#34;),
              (account.inbox, (ItemId(&#39;AA&#39;, &#39;BB&#39;), False, &#34;XXYYZZ...&#34;)),
              (account.inbox, ((&#39;CC&#39;, &#39;DD&#39;), None, &#34;XXYYZZ...&#34;)),
              (account.calendar, &#34;ABCXYZ...&#34;),
          ])
          -&gt; [(&#34;idA&#34;, &#34;changekey&#34;), (&#34;idB&#34;, &#34;changekey&#34;), (&#34;idC&#34;, &#34;changekey&#34;)]
        &#34;&#34;&#34;
        items = ((f, (None, False, d) if isinstance(d, str) else d) for f, d in data)
        return list(self._consume_item_service(service_cls=UploadItems, items=items, chunk_size=chunk_size, kwargs={}))

    def bulk_create(
        self, folder, items, message_disposition=SAVE_ONLY, send_meeting_invitations=SEND_TO_NONE, chunk_size=None
    ):
        &#34;&#34;&#34;Create new items in &#39;folder&#39;.

        :param folder: the folder to create the items in
        :param items: an iterable of Item objects
        :param message_disposition: only applicable to Message items. Possible values are specified in
            MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
        :param send_meeting_invitations: only applicable to CalendarItem items. Possible values are specified in
            SEND_MEETING_INVITATIONS_CHOICES (Default value = SEND_TO_NONE)
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: a list of either BulkCreateResult or exception instances in the same order as the input. The returned
          BulkCreateResult objects are normal Item objects except they only contain the &#39;id&#39; and &#39;changekey&#39;
          of the created item, and the &#39;id&#39; of any attachments that were also created.
        &#34;&#34;&#34;
        if isinstance(items, QuerySet):
            # bulk_create() on a queryset does not make sense because it returns items that have already been created
            raise ValueError(&#34;Cannot bulk create items from a QuerySet&#34;)
        log.debug(
            &#34;Adding items for %s (folder %s, message_disposition: %s, send_meeting_invitations: %s)&#34;,
            self,
            folder,
            message_disposition,
            send_meeting_invitations,
        )
        return list(
            self._consume_item_service(
                service_cls=CreateItem,
                items=items,
                chunk_size=chunk_size,
                kwargs=dict(
                    folder=folder,
                    message_disposition=message_disposition,
                    send_meeting_invitations=send_meeting_invitations,
                ),
            )
        )

    def bulk_update(
        self,
        items,
        conflict_resolution=AUTO_RESOLVE,
        message_disposition=SAVE_ONLY,
        send_meeting_invitations_or_cancellations=SEND_TO_NONE,
        suppress_read_receipts=True,
        chunk_size=None,
    ):
        &#34;&#34;&#34;Bulk update existing items.

        :param items: a list of (Item, fieldnames) tuples, where &#39;Item&#39; is an Item object, and &#39;fieldnames&#39; is a list
            containing the attributes on this Item object that we want to be updated.
        :param conflict_resolution: Possible values are specified in CONFLICT_RESOLUTION_CHOICES
            (Default value = AUTO_RESOLVE)
        :param message_disposition: only applicable to Message items. Possible values are specified in
            MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
        :param send_meeting_invitations_or_cancellations: only applicable to CalendarItem items. Possible values are
            specified in SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES (Default value = SEND_TO_NONE)
        :param suppress_read_receipts: nly supported from Exchange 2013. True or False (Default value = True)
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: a list of either (id, changekey) tuples or exception instances, in the same order as the input
        &#34;&#34;&#34;
        # bulk_update() on a queryset does not make sense because there would be no opportunity to alter the items. In
        # fact, it could be dangerous if the queryset contains an &#39;.only()&#39;. This would wipe out certain fields
        # entirely.
        if isinstance(items, QuerySet):
            raise ValueError(&#34;Cannot bulk update on a queryset&#34;)
        log.debug(
            &#34;Updating items for %s (conflict_resolution %s, message_disposition: %s, send_meeting_invitations: %s)&#34;,
            self,
            conflict_resolution,
            message_disposition,
            send_meeting_invitations_or_cancellations,
        )
        return list(
            self._consume_item_service(
                service_cls=UpdateItem,
                items=items,
                chunk_size=chunk_size,
                kwargs=dict(
                    conflict_resolution=conflict_resolution,
                    message_disposition=message_disposition,
                    send_meeting_invitations_or_cancellations=send_meeting_invitations_or_cancellations,
                    suppress_read_receipts=suppress_read_receipts,
                ),
            )
        )

    def bulk_delete(
        self,
        ids,
        delete_type=HARD_DELETE,
        send_meeting_cancellations=SEND_TO_NONE,
        affected_task_occurrences=ALL_OCCURRENCES,
        suppress_read_receipts=True,
        chunk_size=None,
    ):
        &#34;&#34;&#34;Bulk delete items.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param delete_type: the type of delete to perform. Possible values are specified in DELETE_TYPE_CHOICES
            (Default value = HARD_DELETE)
        :param send_meeting_cancellations: only applicable to CalendarItem. Possible values are specified in
            SEND_MEETING_CANCELLATIONS_CHOICES. (Default value = SEND_TO_NONE)
        :param affected_task_occurrences: only applicable for recurring Task items. Possible values are specified in
            AFFECTED_TASK_OCCURRENCES_CHOICES. (Default value = ALL_OCCURRENCES)
        :param suppress_read_receipts: only supported from Exchange 2013. True or False. (Default value = True)
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: a list of either True or exception instances, in the same order as the input
        &#34;&#34;&#34;
        log.debug(
            &#34;Deleting items for %s (delete_type: %s, send_meeting_invitations: %s, affected_task_occurrences: %s)&#34;,
            self,
            delete_type,
            send_meeting_cancellations,
            affected_task_occurrences,
        )
        return list(
            self._consume_item_service(
                service_cls=DeleteItem,
                items=ids,
                chunk_size=chunk_size,
                kwargs=dict(
                    delete_type=delete_type,
                    send_meeting_cancellations=send_meeting_cancellations,
                    affected_task_occurrences=affected_task_occurrences,
                    suppress_read_receipts=suppress_read_receipts,
                ),
            )
        )

    def bulk_send(self, ids, save_copy=True, copy_to_folder=None, chunk_size=None):
        &#34;&#34;&#34;Send existing draft messages. If requested, save a copy in &#39;copy_to_folder&#39;.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param save_copy: If true, saves a copy of the message (Default value = True)
        :param copy_to_folder: If requested, save a copy of the message in this folder. Default is the Sent folder
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: Status for each send operation, in the same order as the input
        &#34;&#34;&#34;
        if copy_to_folder and not save_copy:
            raise AttributeError(&#34;&#39;save_copy&#39; must be True when &#39;copy_to_folder&#39; is set&#34;)
        if save_copy and not copy_to_folder:
            copy_to_folder = self.sent  # &#39;Sent&#39; is default EWS behaviour
        return list(
            self._consume_item_service(
                service_cls=SendItem,
                items=ids,
                chunk_size=chunk_size,
                kwargs=dict(
                    saved_item_folder=copy_to_folder,
                ),
            )
        )

    def bulk_copy(self, ids, to_folder, chunk_size=None):
        &#34;&#34;&#34;Copy items to another folder.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param to_folder: The destination folder of the copy operation
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: Status for each send operation, in the same order as the input
        &#34;&#34;&#34;
        return list(
            self._consume_item_service(
                service_cls=CopyItem,
                items=ids,
                chunk_size=chunk_size,
                kwargs=dict(
                    to_folder=to_folder,
                ),
            )
        )

    def bulk_move(self, ids, to_folder, chunk_size=None):
        &#34;&#34;&#34;Move items to another folder.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param to_folder: The destination folder of the copy operation
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: The new IDs of the moved items, in the same order as the input. If &#39;to_folder&#39; is a public folder or a
          folder in a different mailbox, an empty list is returned.
        &#34;&#34;&#34;
        return list(
            self._consume_item_service(
                service_cls=MoveItem,
                items=ids,
                chunk_size=chunk_size,
                kwargs=dict(
                    to_folder=to_folder,
                ),
            )
        )

    def bulk_archive(self, ids, to_folder, chunk_size=None):
        &#34;&#34;&#34;Archive items to a folder in the archive mailbox. An archive mailbox must be enabled in order for this
        to work.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param to_folder: The destination folder of the archive operation
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: A list containing True or an exception instance in stable order of the requested items
        &#34;&#34;&#34;
        return list(
            self._consume_item_service(
                service_cls=ArchiveItem,
                items=ids,
                chunk_size=chunk_size,
                kwargs=dict(
                    to_folder=to_folder,
                ),
            )
        )

    def bulk_mark_as_junk(self, ids, is_junk, move_item, chunk_size=None):
        &#34;&#34;&#34;Mark or un-mark message items as junk email and add or remove the sender from the blocked sender list.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param is_junk: Whether the messages are junk or not
        :param move_item: Whether to move the messages to the junk folder or not
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: A list containing the new IDs of the moved items, if items were moved, or True, or an exception
          instance, in stable order of the requested items.
        &#34;&#34;&#34;
        return list(
            self._consume_item_service(
                service_cls=MarkAsJunk,
                items=ids,
                chunk_size=chunk_size,
                kwargs=dict(
                    is_junk=is_junk,
                    move_item=move_item,
                ),
            )
        )

    def fetch(self, ids, folder=None, only_fields=None, chunk_size=None):
        &#34;&#34;&#34;Fetch items by ID.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param folder: used for validating &#39;only_fields&#39; (Default value = None)
        :param only_fields: A list of string or FieldPath items specifying the fields to fetch. Default to all fields
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: A generator of Item objects, in the same order as the input
        &#34;&#34;&#34;
        validation_folder = folder or Folder(root=self.root)  # Default to a folder type that supports all item types
        # &#39;ids&#39; could be an unevaluated QuerySet, e.g. if we ended up here via `fetch(ids=some_folder.filter(...))`. In
        # that case, we want to use its iterator. Otherwise, peek() will start a count() which is wasteful because we
        # need the item IDs immediately afterwards. iterator() will only do the bare minimum.
        if only_fields is None:
            # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
            additional_fields = {
                FieldPath(field=f) for f in validation_folder.allowed_item_fields(version=self.version)
            }
        else:
            for field in only_fields:
                validation_folder.validate_item_field(field=field, version=self.version)
            # Remove ItemId and ChangeKey. We get them unconditionally
            additional_fields = {
                f for f in validation_folder.normalize_fields(fields=only_fields) if not f.field.is_attribute
            }
        # Always use IdOnly here, because AllProperties doesn&#39;t actually get *all* properties
        yield from self._consume_item_service(
            service_cls=GetItem,
            items=ids,
            chunk_size=chunk_size,
            kwargs=dict(
                additional_fields=additional_fields,
                shape=ID_ONLY,
            ),
        )

    def fetch_personas(self, ids):
        &#34;&#34;&#34;Fetch personas by ID.

        :param ids: an iterable of either (id, changekey) tuples or Persona objects.
        :return: A generator of Persona objects, in the same order as the input
        &#34;&#34;&#34;
        if isinstance(ids, QuerySet):
            # We just want an iterator over the results
            ids = iter(ids)
        is_empty, ids = peek(ids)
        if is_empty:
            # We accept generators, so it&#39;s not always convenient for caller to know up-front if &#39;ids&#39; is empty. Allow
            # empty &#39;ids&#39; and return early.
            return
        yield from GetPersona(account=self).call(personas=ids)

    @property
    def mail_tips(self):
        &#34;&#34;&#34;See self.oof_settings about caching considerations.&#34;&#34;&#34;
        return GetMailTips(protocol=self.protocol).get(
            sending_as=SendingAs(email_address=self.primary_smtp_address),
            recipients=[Mailbox(email_address=self.primary_smtp_address)],
            mail_tips_requested=&#34;All&#34;,
        )

    @property
    def delegates(self):
        &#34;&#34;&#34;Return a list of DelegateUser objects representing the delegates that are set on this account.&#34;&#34;&#34;
        return list(GetDelegate(account=self).call(user_ids=None, include_permissions=True))

    @property
    def rules(self):
        &#34;&#34;&#34;Return a list of Rule objects representing the rules that are set on this account.&#34;&#34;&#34;
        return list(GetInboxRules(account=self).call())

    def create_rule(self, rule: Rule):
        &#34;&#34;&#34;Create an Inbox rule.

        :param rule: The rule to create. Must have at least &#39;display_name&#39; set.
        :return: None if success, else raises an error.
        &#34;&#34;&#34;
        CreateInboxRule(account=self).get(rule=rule, remove_outlook_rule_blob=True)
        # After creating the rule, query all rules,
        # find the rule that was just created, and return its ID.
        try:
            rule.id = {i.display_name: i for i in GetInboxRules(account=self).call()}[rule.display_name].id
        except KeyError:
            raise ResponseMessageError(f&#34;Failed to create rule ({rule.display_name})!&#34;)

    def set_rule(self, rule: Rule):
        &#34;&#34;&#34;Modify an Inbox rule.

        :param rule: The rule to set. Must have an ID.
        :return: None if success, else raises an error.
        &#34;&#34;&#34;
        SetInboxRule(account=self).get(rule=rule)

    def delete_rule(self, rule: Rule):
        &#34;&#34;&#34;Delete an Inbox rule.

        :param rule: The rule to delete. Must have an ID.
        :return: None if success, else raises an error.
        &#34;&#34;&#34;
        if not rule.id:
            raise ValueError(&#34;Rule must have an ID&#34;)
        DeleteInboxRule(account=self).get(rule=rule)
        rule.id = None

    def subscribe_to_pull(self, event_types=None, watermark=None, timeout=60):
        &#34;&#34;&#34;Create a pull subscription.

        :param event_types: List of event types to subscribe to. Possible values defined in SubscribeToPull.EVENT_TYPES
        :param watermark: An event bookmark as returned by some sync services
        :param timeout: Timeout of the subscription, in minutes. Timeout is reset when the server receives a
        GetEvents request for this subscription.
        :return: The subscription ID and a watermark
        &#34;&#34;&#34;
        if event_types is None:
            event_types = SubscribeToPull.EVENT_TYPES
        return SubscribeToPull(account=self).get(
            folders=None,
            event_types=event_types,
            watermark=watermark,
            timeout=timeout,
        )

    def subscribe_to_push(self, callback_url, event_types=None, watermark=None, status_frequency=1):
        &#34;&#34;&#34;Create a push subscription.

        :param callback_url: A client-defined URL that the server will call
        :param event_types: List of event types to subscribe to. Possible values defined in SubscribeToPush.EVENT_TYPES
        :param watermark: An event bookmark as returned by some sync services
        :param status_frequency: The frequency, in minutes, that the callback URL will be called with.
        :return: The subscription ID and a watermark
        &#34;&#34;&#34;
        if event_types is None:
            event_types = SubscribeToPush.EVENT_TYPES
        return SubscribeToPush(account=self).get(
            folders=None,
            event_types=event_types,
            watermark=watermark,
            status_frequency=status_frequency,
            url=callback_url,
        )

    def subscribe_to_streaming(self, event_types=None):
        &#34;&#34;&#34;Create a streaming subscription.

        :param event_types: List of event types to subscribe to. Possible values defined in SubscribeToPush.EVENT_TYPES
        :return: The subscription ID
        &#34;&#34;&#34;
        if event_types is None:
            event_types = SubscribeToStreaming.EVENT_TYPES
        return SubscribeToStreaming(account=self).get(folders=None, event_types=event_types)

    def pull_subscription(self, **kwargs):
        return PullSubscription(target=self, **kwargs)

    def push_subscription(self, **kwargs):
        return PushSubscription(target=self, **kwargs)

    def streaming_subscription(self, **kwargs):
        return StreamingSubscription(target=self, **kwargs)

    def unsubscribe(self, subscription_id):
        &#34;&#34;&#34;Unsubscribe. Only applies to pull and streaming notifications.

        :param subscription_id: A subscription ID as acquired by .subscribe_to_[pull|streaming]()
        :return: True

        This method doesn&#39;t need the current collection instance, but it makes sense to keep the method along the other
        sync methods.
        &#34;&#34;&#34;
        return Unsubscribe(account=self).get(subscription_id=subscription_id)

    def __str__(self):
        if self.fullname:
            return f&#34;{self.primary_smtp_address} ({self.fullname})&#34;
        return self.primary_smtp_address</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Account.admin_audit_logs"><code class="name">var <span class="ident">admin_audit_logs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_deleted_items"><code class="name">var <span class="ident">archive_deleted_items</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_inbox"><code class="name">var <span class="ident">archive_inbox</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_msg_folder_root"><code class="name">var <span class="ident">archive_msg_folder_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_recoverable_items_deletions"><code class="name">var <span class="ident">archive_recoverable_items_deletions</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_recoverable_items_purges"><code class="name">var <span class="ident">archive_recoverable_items_purges</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_recoverable_items_root"><code class="name">var <span class="ident">archive_recoverable_items_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_recoverable_items_versions"><code class="name">var <span class="ident">archive_recoverable_items_versions</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_root"><code class="name">var <span class="ident">archive_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.calendar"><code class="name">var <span class="ident">calendar</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.conflicts"><code class="name">var <span class="ident">conflicts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.contacts"><code class="name">var <span class="ident">contacts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.conversation_history"><code class="name">var <span class="ident">conversation_history</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.delegates"><code class="name">var <span class="ident">delegates</span></code></dt>
<dd>
<div class="desc"><p>Return a list of DelegateUser objects representing the delegates that are set on this account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def delegates(self):
    &#34;&#34;&#34;Return a list of DelegateUser objects representing the delegates that are set on this account.&#34;&#34;&#34;
    return list(GetDelegate(account=self).call(user_ids=None, include_permissions=True))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.directory"><code class="name">var <span class="ident">directory</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.domain"><code class="name">var <span class="ident">domain</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def domain(self):
    return get_domain(self.primary_smtp_address)</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.drafts"><code class="name">var <span class="ident">drafts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.favorites"><code class="name">var <span class="ident">favorites</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.im_contact_list"><code class="name">var <span class="ident">im_contact_list</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.inbox"><code class="name">var <span class="ident">inbox</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.journal"><code class="name">var <span class="ident">journal</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.junk"><code class="name">var <span class="ident">junk</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.local_failures"><code class="name">var <span class="ident">local_failures</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.mail_tips"><code class="name">var <span class="ident">mail_tips</span></code></dt>
<dd>
<div class="desc"><p>See self.oof_settings about caching considerations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mail_tips(self):
    &#34;&#34;&#34;See self.oof_settings about caching considerations.&#34;&#34;&#34;
    return GetMailTips(protocol=self.protocol).get(
        sending_as=SendingAs(email_address=self.primary_smtp_address),
        recipients=[Mailbox(email_address=self.primary_smtp_address)],
        mail_tips_requested=&#34;All&#34;,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.msg_folder_root"><code class="name">var <span class="ident">msg_folder_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.my_contacts"><code class="name">var <span class="ident">my_contacts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.notes"><code class="name">var <span class="ident">notes</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.oof_settings"><code class="name">var <span class="ident">oof_settings</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def oof_settings(self):
    # We don&#39;t want to cache this property because then we can&#39;t easily get updates. &#39;threaded_cached_property&#39;
    # supports the &#39;del self.oof_settings&#39; syntax to invalidate the cache, but does not support custom setter
    # methods. Having a non-cached service call here goes against the assumption that properties are cheap, but the
    # alternative is to create get_oof_settings() and set_oof_settings(), and that&#39;s just too Java-ish for my taste.
    return GetUserOofSettings(account=self).get(
        mailbox=Mailbox(email_address=self.primary_smtp_address),
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.outbox"><code class="name">var <span class="ident">outbox</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.people_connect"><code class="name">var <span class="ident">people_connect</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.primary_smtp_address"><code class="name">var <span class="ident">primary_smtp_address</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def primary_smtp_address(self):
    return self.identity.primary_smtp_address</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.public_folders_root"><code class="name">var <span class="ident">public_folders_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.quick_contacts"><code class="name">var <span class="ident">quick_contacts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.recipient_cache"><code class="name">var <span class="ident">recipient_cache</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.recoverable_items_deletions"><code class="name">var <span class="ident">recoverable_items_deletions</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.recoverable_items_purges"><code class="name">var <span class="ident">recoverable_items_purges</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.recoverable_items_root"><code class="name">var <span class="ident">recoverable_items_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.recoverable_items_versions"><code class="name">var <span class="ident">recoverable_items_versions</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.root"><code class="name">var <span class="ident">root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.rules"><code class="name">var <span class="ident">rules</span></code></dt>
<dd>
<div class="desc"><p>Return a list of Rule objects representing the rules that are set on this account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def rules(self):
    &#34;&#34;&#34;Return a list of Rule objects representing the rules that are set on this account.&#34;&#34;&#34;
    return list(GetInboxRules(account=self).call())</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.search_folders"><code class="name">var <span class="ident">search_folders</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.sent"><code class="name">var <span class="ident">sent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.server_failures"><code class="name">var <span class="ident">server_failures</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.sync_issues"><code class="name">var <span class="ident">sync_issues</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.tasks"><code class="name">var <span class="ident">tasks</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.todo_search"><code class="name">var <span class="ident">todo_search</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.trash"><code class="name">var <span class="ident">trash</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.voice_mail"><code class="name">var <span class="ident">voice_mail</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Account.bulk_archive"><code class="name flex">
<span>def <span class="ident">bulk_archive</span></span>(<span>self, ids, to_folder, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Archive items to a folder in the archive mailbox. An archive mailbox must be enabled in order for this
to work.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param to_folder: The destination folder of the archive operation
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: A list containing True or an exception instance in stable order of the requested items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_archive(self, ids, to_folder, chunk_size=None):
    &#34;&#34;&#34;Archive items to a folder in the archive mailbox. An archive mailbox must be enabled in order for this
    to work.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param to_folder: The destination folder of the archive operation
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: A list containing True or an exception instance in stable order of the requested items
    &#34;&#34;&#34;
    return list(
        self._consume_item_service(
            service_cls=ArchiveItem,
            items=ids,
            chunk_size=chunk_size,
            kwargs=dict(
                to_folder=to_folder,
            ),
        )
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_copy"><code class="name flex">
<span>def <span class="ident">bulk_copy</span></span>(<span>self, ids, to_folder, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy items to another folder.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param to_folder: The destination folder of the copy operation
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: Status for each send operation, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_copy(self, ids, to_folder, chunk_size=None):
    &#34;&#34;&#34;Copy items to another folder.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param to_folder: The destination folder of the copy operation
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: Status for each send operation, in the same order as the input
    &#34;&#34;&#34;
    return list(
        self._consume_item_service(
            service_cls=CopyItem,
            items=ids,
            chunk_size=chunk_size,
            kwargs=dict(
                to_folder=to_folder,
            ),
        )
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_create"><code class="name flex">
<span>def <span class="ident">bulk_create</span></span>(<span>self, folder, items, message_disposition='SaveOnly', send_meeting_invitations='SendToNone', chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create new items in 'folder'.</p>
<p>:param folder: the folder to create the items in
:param items: an iterable of Item objects
:param message_disposition: only applicable to Message items. Possible values are specified in
MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
:param send_meeting_invitations: only applicable to CalendarItem items. Possible values are specified in
SEND_MEETING_INVITATIONS_CHOICES (Default value = SEND_TO_NONE)
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: a list of either BulkCreateResult or exception instances in the same order as the input. The returned
BulkCreateResult objects are normal Item objects except they only contain the 'id' and 'changekey'
of the created item, and the 'id' of any attachments that were also created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_create(
    self, folder, items, message_disposition=SAVE_ONLY, send_meeting_invitations=SEND_TO_NONE, chunk_size=None
):
    &#34;&#34;&#34;Create new items in &#39;folder&#39;.

    :param folder: the folder to create the items in
    :param items: an iterable of Item objects
    :param message_disposition: only applicable to Message items. Possible values are specified in
        MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
    :param send_meeting_invitations: only applicable to CalendarItem items. Possible values are specified in
        SEND_MEETING_INVITATIONS_CHOICES (Default value = SEND_TO_NONE)
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: a list of either BulkCreateResult or exception instances in the same order as the input. The returned
      BulkCreateResult objects are normal Item objects except they only contain the &#39;id&#39; and &#39;changekey&#39;
      of the created item, and the &#39;id&#39; of any attachments that were also created.
    &#34;&#34;&#34;
    if isinstance(items, QuerySet):
        # bulk_create() on a queryset does not make sense because it returns items that have already been created
        raise ValueError(&#34;Cannot bulk create items from a QuerySet&#34;)
    log.debug(
        &#34;Adding items for %s (folder %s, message_disposition: %s, send_meeting_invitations: %s)&#34;,
        self,
        folder,
        message_disposition,
        send_meeting_invitations,
    )
    return list(
        self._consume_item_service(
            service_cls=CreateItem,
            items=items,
            chunk_size=chunk_size,
            kwargs=dict(
                folder=folder,
                message_disposition=message_disposition,
                send_meeting_invitations=send_meeting_invitations,
            ),
        )
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_delete"><code class="name flex">
<span>def <span class="ident">bulk_delete</span></span>(<span>self, ids, delete_type='HardDelete', send_meeting_cancellations='SendToNone', affected_task_occurrences='AllOccurrences', suppress_read_receipts=True, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Bulk delete items.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param delete_type: the type of delete to perform. Possible values are specified in DELETE_TYPE_CHOICES
(Default value = HARD_DELETE)
:param send_meeting_cancellations: only applicable to CalendarItem. Possible values are specified in
SEND_MEETING_CANCELLATIONS_CHOICES. (Default value = SEND_TO_NONE)
:param affected_task_occurrences: only applicable for recurring Task items. Possible values are specified in
AFFECTED_TASK_OCCURRENCES_CHOICES. (Default value = ALL_OCCURRENCES)
:param suppress_read_receipts: only supported from Exchange 2013. True or False. (Default value = True)
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: a list of either True or exception instances, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_delete(
    self,
    ids,
    delete_type=HARD_DELETE,
    send_meeting_cancellations=SEND_TO_NONE,
    affected_task_occurrences=ALL_OCCURRENCES,
    suppress_read_receipts=True,
    chunk_size=None,
):
    &#34;&#34;&#34;Bulk delete items.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param delete_type: the type of delete to perform. Possible values are specified in DELETE_TYPE_CHOICES
        (Default value = HARD_DELETE)
    :param send_meeting_cancellations: only applicable to CalendarItem. Possible values are specified in
        SEND_MEETING_CANCELLATIONS_CHOICES. (Default value = SEND_TO_NONE)
    :param affected_task_occurrences: only applicable for recurring Task items. Possible values are specified in
        AFFECTED_TASK_OCCURRENCES_CHOICES. (Default value = ALL_OCCURRENCES)
    :param suppress_read_receipts: only supported from Exchange 2013. True or False. (Default value = True)
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: a list of either True or exception instances, in the same order as the input
    &#34;&#34;&#34;
    log.debug(
        &#34;Deleting items for %s (delete_type: %s, send_meeting_invitations: %s, affected_task_occurrences: %s)&#34;,
        self,
        delete_type,
        send_meeting_cancellations,
        affected_task_occurrences,
    )
    return list(
        self._consume_item_service(
            service_cls=DeleteItem,
            items=ids,
            chunk_size=chunk_size,
            kwargs=dict(
                delete_type=delete_type,
                send_meeting_cancellations=send_meeting_cancellations,
                affected_task_occurrences=affected_task_occurrences,
                suppress_read_receipts=suppress_read_receipts,
            ),
        )
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_mark_as_junk"><code class="name flex">
<span>def <span class="ident">bulk_mark_as_junk</span></span>(<span>self, ids, is_junk, move_item, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Mark or un-mark message items as junk email and add or remove the sender from the blocked sender list.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param is_junk: Whether the messages are junk or not
:param move_item: Whether to move the messages to the junk folder or not
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: A list containing the new IDs of the moved items, if items were moved, or True, or an exception
instance, in stable order of the requested items.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_mark_as_junk(self, ids, is_junk, move_item, chunk_size=None):
    &#34;&#34;&#34;Mark or un-mark message items as junk email and add or remove the sender from the blocked sender list.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param is_junk: Whether the messages are junk or not
    :param move_item: Whether to move the messages to the junk folder or not
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: A list containing the new IDs of the moved items, if items were moved, or True, or an exception
      instance, in stable order of the requested items.
    &#34;&#34;&#34;
    return list(
        self._consume_item_service(
            service_cls=MarkAsJunk,
            items=ids,
            chunk_size=chunk_size,
            kwargs=dict(
                is_junk=is_junk,
                move_item=move_item,
            ),
        )
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_move"><code class="name flex">
<span>def <span class="ident">bulk_move</span></span>(<span>self, ids, to_folder, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move items to another folder.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param to_folder: The destination folder of the copy operation
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: The new IDs of the moved items, in the same order as the input. If 'to_folder' is a public folder or a
folder in a different mailbox, an empty list is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_move(self, ids, to_folder, chunk_size=None):
    &#34;&#34;&#34;Move items to another folder.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param to_folder: The destination folder of the copy operation
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: The new IDs of the moved items, in the same order as the input. If &#39;to_folder&#39; is a public folder or a
      folder in a different mailbox, an empty list is returned.
    &#34;&#34;&#34;
    return list(
        self._consume_item_service(
            service_cls=MoveItem,
            items=ids,
            chunk_size=chunk_size,
            kwargs=dict(
                to_folder=to_folder,
            ),
        )
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_send"><code class="name flex">
<span>def <span class="ident">bulk_send</span></span>(<span>self, ids, save_copy=True, copy_to_folder=None, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send existing draft messages. If requested, save a copy in 'copy_to_folder'.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param save_copy: If true, saves a copy of the message (Default value = True)
:param copy_to_folder: If requested, save a copy of the message in this folder. Default is the Sent folder
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: Status for each send operation, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_send(self, ids, save_copy=True, copy_to_folder=None, chunk_size=None):
    &#34;&#34;&#34;Send existing draft messages. If requested, save a copy in &#39;copy_to_folder&#39;.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param save_copy: If true, saves a copy of the message (Default value = True)
    :param copy_to_folder: If requested, save a copy of the message in this folder. Default is the Sent folder
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: Status for each send operation, in the same order as the input
    &#34;&#34;&#34;
    if copy_to_folder and not save_copy:
        raise AttributeError(&#34;&#39;save_copy&#39; must be True when &#39;copy_to_folder&#39; is set&#34;)
    if save_copy and not copy_to_folder:
        copy_to_folder = self.sent  # &#39;Sent&#39; is default EWS behaviour
    return list(
        self._consume_item_service(
            service_cls=SendItem,
            items=ids,
            chunk_size=chunk_size,
            kwargs=dict(
                saved_item_folder=copy_to_folder,
            ),
        )
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_update"><code class="name flex">
<span>def <span class="ident">bulk_update</span></span>(<span>self, items, conflict_resolution='AutoResolve', message_disposition='SaveOnly', send_meeting_invitations_or_cancellations='SendToNone', suppress_read_receipts=True, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Bulk update existing items.</p>
<p>:param items: a list of (Item, fieldnames) tuples, where 'Item' is an Item object, and 'fieldnames' is a list
containing the attributes on this Item object that we want to be updated.
:param conflict_resolution: Possible values are specified in CONFLICT_RESOLUTION_CHOICES
(Default value = AUTO_RESOLVE)
:param message_disposition: only applicable to Message items. Possible values are specified in
MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
:param send_meeting_invitations_or_cancellations: only applicable to CalendarItem items. Possible values are
specified in SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES (Default value = SEND_TO_NONE)
:param suppress_read_receipts: nly supported from Exchange 2013. True or False (Default value = True)
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: a list of either (id, changekey) tuples or exception instances, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_update(
    self,
    items,
    conflict_resolution=AUTO_RESOLVE,
    message_disposition=SAVE_ONLY,
    send_meeting_invitations_or_cancellations=SEND_TO_NONE,
    suppress_read_receipts=True,
    chunk_size=None,
):
    &#34;&#34;&#34;Bulk update existing items.

    :param items: a list of (Item, fieldnames) tuples, where &#39;Item&#39; is an Item object, and &#39;fieldnames&#39; is a list
        containing the attributes on this Item object that we want to be updated.
    :param conflict_resolution: Possible values are specified in CONFLICT_RESOLUTION_CHOICES
        (Default value = AUTO_RESOLVE)
    :param message_disposition: only applicable to Message items. Possible values are specified in
        MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
    :param send_meeting_invitations_or_cancellations: only applicable to CalendarItem items. Possible values are
        specified in SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES (Default value = SEND_TO_NONE)
    :param suppress_read_receipts: nly supported from Exchange 2013. True or False (Default value = True)
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: a list of either (id, changekey) tuples or exception instances, in the same order as the input
    &#34;&#34;&#34;
    # bulk_update() on a queryset does not make sense because there would be no opportunity to alter the items. In
    # fact, it could be dangerous if the queryset contains an &#39;.only()&#39;. This would wipe out certain fields
    # entirely.
    if isinstance(items, QuerySet):
        raise ValueError(&#34;Cannot bulk update on a queryset&#34;)
    log.debug(
        &#34;Updating items for %s (conflict_resolution %s, message_disposition: %s, send_meeting_invitations: %s)&#34;,
        self,
        conflict_resolution,
        message_disposition,
        send_meeting_invitations_or_cancellations,
    )
    return list(
        self._consume_item_service(
            service_cls=UpdateItem,
            items=items,
            chunk_size=chunk_size,
            kwargs=dict(
                conflict_resolution=conflict_resolution,
                message_disposition=message_disposition,
                send_meeting_invitations_or_cancellations=send_meeting_invitations_or_cancellations,
                suppress_read_receipts=suppress_read_receipts,
            ),
        )
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.create_rule"><code class="name flex">
<span>def <span class="ident">create_rule</span></span>(<span>self, rule: <a title="exchangelib.properties.Rule" href="properties.html#exchangelib.properties.Rule">Rule</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an Inbox rule.</p>
<p>:param rule: The rule to create. Must have at least 'display_name' set.
:return: None if success, else raises an error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rule(self, rule: Rule):
    &#34;&#34;&#34;Create an Inbox rule.

    :param rule: The rule to create. Must have at least &#39;display_name&#39; set.
    :return: None if success, else raises an error.
    &#34;&#34;&#34;
    CreateInboxRule(account=self).get(rule=rule, remove_outlook_rule_blob=True)
    # After creating the rule, query all rules,
    # find the rule that was just created, and return its ID.
    try:
        rule.id = {i.display_name: i for i in GetInboxRules(account=self).call()}[rule.display_name].id
    except KeyError:
        raise ResponseMessageError(f&#34;Failed to create rule ({rule.display_name})!&#34;)</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.delete_rule"><code class="name flex">
<span>def <span class="ident">delete_rule</span></span>(<span>self, rule: <a title="exchangelib.properties.Rule" href="properties.html#exchangelib.properties.Rule">Rule</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete an Inbox rule.</p>
<p>:param rule: The rule to delete. Must have an ID.
:return: None if success, else raises an error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_rule(self, rule: Rule):
    &#34;&#34;&#34;Delete an Inbox rule.

    :param rule: The rule to delete. Must have an ID.
    :return: None if success, else raises an error.
    &#34;&#34;&#34;
    if not rule.id:
        raise ValueError(&#34;Rule must have an ID&#34;)
    DeleteInboxRule(account=self).get(rule=rule)
    rule.id = None</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, items, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return export strings of the given items.</p>
<p>:param items: An iterable containing the Items we want to export
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: A list of strings, the exported representation of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, items, chunk_size=None):
    &#34;&#34;&#34;Return export strings of the given items.

    :param items: An iterable containing the Items we want to export
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: A list of strings, the exported representation of the object
    &#34;&#34;&#34;
    return list(self._consume_item_service(service_cls=ExportItems, items=items, chunk_size=chunk_size, kwargs={}))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>self, ids, folder=None, only_fields=None, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch items by ID.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param folder: used for validating 'only_fields' (Default value = None)
:param only_fields: A list of string or FieldPath items specifying the fields to fetch. Default to all fields
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: A generator of Item objects, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch(self, ids, folder=None, only_fields=None, chunk_size=None):
    &#34;&#34;&#34;Fetch items by ID.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param folder: used for validating &#39;only_fields&#39; (Default value = None)
    :param only_fields: A list of string or FieldPath items specifying the fields to fetch. Default to all fields
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: A generator of Item objects, in the same order as the input
    &#34;&#34;&#34;
    validation_folder = folder or Folder(root=self.root)  # Default to a folder type that supports all item types
    # &#39;ids&#39; could be an unevaluated QuerySet, e.g. if we ended up here via `fetch(ids=some_folder.filter(...))`. In
    # that case, we want to use its iterator. Otherwise, peek() will start a count() which is wasteful because we
    # need the item IDs immediately afterwards. iterator() will only do the bare minimum.
    if only_fields is None:
        # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
        additional_fields = {
            FieldPath(field=f) for f in validation_folder.allowed_item_fields(version=self.version)
        }
    else:
        for field in only_fields:
            validation_folder.validate_item_field(field=field, version=self.version)
        # Remove ItemId and ChangeKey. We get them unconditionally
        additional_fields = {
            f for f in validation_folder.normalize_fields(fields=only_fields) if not f.field.is_attribute
        }
    # Always use IdOnly here, because AllProperties doesn&#39;t actually get *all* properties
    yield from self._consume_item_service(
        service_cls=GetItem,
        items=ids,
        chunk_size=chunk_size,
        kwargs=dict(
            additional_fields=additional_fields,
            shape=ID_ONLY,
        ),
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.fetch_personas"><code class="name flex">
<span>def <span class="ident">fetch_personas</span></span>(<span>self, ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch personas by ID.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Persona objects.
:return: A generator of Persona objects, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_personas(self, ids):
    &#34;&#34;&#34;Fetch personas by ID.

    :param ids: an iterable of either (id, changekey) tuples or Persona objects.
    :return: A generator of Persona objects, in the same order as the input
    &#34;&#34;&#34;
    if isinstance(ids, QuerySet):
        # We just want an iterator over the results
        ids = iter(ids)
    is_empty, ids = peek(ids)
    if is_empty:
        # We accept generators, so it&#39;s not always convenient for caller to know up-front if &#39;ids&#39; is empty. Allow
        # empty &#39;ids&#39; and return early.
        return
    yield from GetPersona(account=self).call(personas=ids)</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.pull_subscription"><code class="name flex">
<span>def <span class="ident">pull_subscription</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pull_subscription(self, **kwargs):
    return PullSubscription(target=self, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.push_subscription"><code class="name flex">
<span>def <span class="ident">push_subscription</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_subscription(self, **kwargs):
    return PushSubscription(target=self, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.set_rule"><code class="name flex">
<span>def <span class="ident">set_rule</span></span>(<span>self, rule: <a title="exchangelib.properties.Rule" href="properties.html#exchangelib.properties.Rule">Rule</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Modify an Inbox rule.</p>
<p>:param rule: The rule to set. Must have an ID.
:return: None if success, else raises an error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_rule(self, rule: Rule):
    &#34;&#34;&#34;Modify an Inbox rule.

    :param rule: The rule to set. Must have an ID.
    :return: None if success, else raises an error.
    &#34;&#34;&#34;
    SetInboxRule(account=self).get(rule=rule)</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.streaming_subscription"><code class="name flex">
<span>def <span class="ident">streaming_subscription</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def streaming_subscription(self, **kwargs):
    return StreamingSubscription(target=self, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.subscribe_to_pull"><code class="name flex">
<span>def <span class="ident">subscribe_to_pull</span></span>(<span>self, event_types=None, watermark=None, timeout=60)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a pull subscription.</p>
<p>:param event_types: List of event types to subscribe to. Possible values defined in SubscribeToPull.EVENT_TYPES
:param watermark: An event bookmark as returned by some sync services
:param timeout: Timeout of the subscription, in minutes. Timeout is reset when the server receives a
GetEvents request for this subscription.
:return: The subscription ID and a watermark</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_pull(self, event_types=None, watermark=None, timeout=60):
    &#34;&#34;&#34;Create a pull subscription.

    :param event_types: List of event types to subscribe to. Possible values defined in SubscribeToPull.EVENT_TYPES
    :param watermark: An event bookmark as returned by some sync services
    :param timeout: Timeout of the subscription, in minutes. Timeout is reset when the server receives a
    GetEvents request for this subscription.
    :return: The subscription ID and a watermark
    &#34;&#34;&#34;
    if event_types is None:
        event_types = SubscribeToPull.EVENT_TYPES
    return SubscribeToPull(account=self).get(
        folders=None,
        event_types=event_types,
        watermark=watermark,
        timeout=timeout,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.subscribe_to_push"><code class="name flex">
<span>def <span class="ident">subscribe_to_push</span></span>(<span>self, callback_url, event_types=None, watermark=None, status_frequency=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a push subscription.</p>
<p>:param callback_url: A client-defined URL that the server will call
:param event_types: List of event types to subscribe to. Possible values defined in SubscribeToPush.EVENT_TYPES
:param watermark: An event bookmark as returned by some sync services
:param status_frequency: The frequency, in minutes, that the callback URL will be called with.
:return: The subscription ID and a watermark</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_push(self, callback_url, event_types=None, watermark=None, status_frequency=1):
    &#34;&#34;&#34;Create a push subscription.

    :param callback_url: A client-defined URL that the server will call
    :param event_types: List of event types to subscribe to. Possible values defined in SubscribeToPush.EVENT_TYPES
    :param watermark: An event bookmark as returned by some sync services
    :param status_frequency: The frequency, in minutes, that the callback URL will be called with.
    :return: The subscription ID and a watermark
    &#34;&#34;&#34;
    if event_types is None:
        event_types = SubscribeToPush.EVENT_TYPES
    return SubscribeToPush(account=self).get(
        folders=None,
        event_types=event_types,
        watermark=watermark,
        status_frequency=status_frequency,
        url=callback_url,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.subscribe_to_streaming"><code class="name flex">
<span>def <span class="ident">subscribe_to_streaming</span></span>(<span>self, event_types=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a streaming subscription.</p>
<p>:param event_types: List of event types to subscribe to. Possible values defined in SubscribeToPush.EVENT_TYPES
:return: The subscription ID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_streaming(self, event_types=None):
    &#34;&#34;&#34;Create a streaming subscription.

    :param event_types: List of event types to subscribe to. Possible values defined in SubscribeToPush.EVENT_TYPES
    :return: The subscription ID
    &#34;&#34;&#34;
    if event_types is None:
        event_types = SubscribeToStreaming.EVENT_TYPES
    return SubscribeToStreaming(account=self).get(folders=None, event_types=event_types)</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.unsubscribe"><code class="name flex">
<span>def <span class="ident">unsubscribe</span></span>(<span>self, subscription_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Unsubscribe. Only applies to pull and streaming notifications.</p>
<p>:param subscription_id: A subscription ID as acquired by .subscribe_to_<a href="">pull|streaming</a>
:return: True</p>
<p>This method doesn't need the current collection instance, but it makes sense to keep the method along the other
sync methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unsubscribe(self, subscription_id):
    &#34;&#34;&#34;Unsubscribe. Only applies to pull and streaming notifications.

    :param subscription_id: A subscription ID as acquired by .subscribe_to_[pull|streaming]()
    :return: True

    This method doesn&#39;t need the current collection instance, but it makes sense to keep the method along the other
    sync methods.
    &#34;&#34;&#34;
    return Unsubscribe(account=self).get(subscription_id=subscription_id)</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>self, data, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Upload objects retrieved from an export to the given folders.</p>
<p>:param data: An iterable of tuples containing the folder we want to upload the data to and the string outputs of
exports. If you want to update items instead of create, the data must be a tuple of
(ItemId, is_associated, data) values.
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: A list of tuples with the new ids and changekeys</p>
<p>Example:
account.upload([
(account.inbox, "AABBCC&hellip;"),
(account.inbox, (ItemId('AA', 'BB'), False, "XXYYZZ&hellip;")),
(account.inbox, (('CC', 'DD'), None, "XXYYZZ&hellip;")),
(account.calendar, "ABCXYZ&hellip;"),
])
-&gt; [("idA", "changekey"), ("idB", "changekey"), ("idC", "changekey")]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(self, data, chunk_size=None):
    &#34;&#34;&#34;Upload objects retrieved from an export to the given folders.

    :param data: An iterable of tuples containing the folder we want to upload the data to and the string outputs of
        exports. If you want to update items instead of create, the data must be a tuple of
        (ItemId, is_associated, data) values.
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: A list of tuples with the new ids and changekeys

      Example:
      account.upload([
          (account.inbox, &#34;AABBCC...&#34;),
          (account.inbox, (ItemId(&#39;AA&#39;, &#39;BB&#39;), False, &#34;XXYYZZ...&#34;)),
          (account.inbox, ((&#39;CC&#39;, &#39;DD&#39;), None, &#34;XXYYZZ...&#34;)),
          (account.calendar, &#34;ABCXYZ...&#34;),
      ])
      -&gt; [(&#34;idA&#34;, &#34;changekey&#34;), (&#34;idB&#34;, &#34;changekey&#34;), (&#34;idC&#34;, &#34;changekey&#34;)]
    &#34;&#34;&#34;
    items = ((f, (None, False, d) if isinstance(d, str) else d) for f, d in data)
    return list(self._consume_item_service(service_cls=UploadItems, items=items, chunk_size=chunk_size, kwargs={}))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Attendee"><code class="flex name class">
<span>class <span class="ident">Attendee</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/attendee">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/attendee</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Attendee(EWSElement):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/attendee&#34;&#34;&#34;

    ELEMENT_NAME = &#34;Attendee&#34;
    RESPONSE_TYPES = {&#34;Unknown&#34;, &#34;Organizer&#34;, &#34;Tentative&#34;, &#34;Accept&#34;, &#34;Decline&#34;, &#34;NoResponseReceived&#34;}

    mailbox = MailboxField(is_required=True)
    response_type = ChoiceField(
        field_uri=&#34;ResponseType&#34;, choices={Choice(c) for c in RESPONSE_TYPES}, default=&#34;Unknown&#34;
    )
    last_response_time = DateTimeField(field_uri=&#34;LastResponseTime&#34;)
    proposed_start = DateTimeField(field_uri=&#34;ProposedStart&#34;)
    proposed_end = DateTimeField(field_uri=&#34;ProposedEnd&#34;)

    def __hash__(self):
        return hash(self.mailbox)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Attendee.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Attendee.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Attendee.RESPONSE_TYPES"><code class="name">var <span class="ident">RESPONSE_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Attendee.last_response_time"><code class="name">var <span class="ident">last_response_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Attendee.mailbox"><code class="name">var <span class="ident">mailbox</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Attendee.proposed_end"><code class="name">var <span class="ident">proposed_end</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Attendee.proposed_start"><code class="name">var <span class="ident">proposed_start</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Attendee.response_type"><code class="name">var <span class="ident">response_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.EWSElement.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.BaseProtocol"><code class="flex name class">
<span>class <span class="ident">BaseProtocol</span></span>
<span>(</span><span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for Protocol which implements the bare essentials.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseProtocol:
    &#34;&#34;&#34;Base class for Protocol which implements the bare essentials.&#34;&#34;&#34;

    # The maximum number of sessions (== TCP connections, see below) we will open to this service endpoint. Keep this
    # low unless you have an agreement with the Exchange admin on the receiving end to hammer the server and
    # rate-limiting policies have been disabled for the connecting user. Changing this setting only makes sense if
    # you are using threads to run multiple concurrent workers in this process.
    SESSION_POOLSIZE = 1
    # We want only 1 TCP connection per Session object. We may have lots of different credentials hitting the server and
    # each credential needs its own session (NTLM auth will only send credentials once and then secure the connection,
    # so a connection can only handle requests for one credential). Having multiple connections per Session could
    # quickly exhaust the maximum number of concurrent connections the Exchange server allows from one client.
    CONNECTIONS_PER_SESSION = 1
    # The number of times a session may be reused before creating a new session object. &#39;None&#39; means &#34;infinite&#34;.
    # Discarding sessions after a certain number of usages may limit memory leaks in the Session object.
    MAX_SESSION_USAGE_COUNT = None
    # Timeout for HTTP requests
    TIMEOUT = 120
    RETRY_WAIT = 10  # Seconds to wait before retry on connection errors

    # The adapter class to use for HTTP requests. Override this if you need e.g. proxy support or specific TLS versions
    HTTP_ADAPTER_CLS = requests.adapters.HTTPAdapter

    # The User-Agent header to use for HTTP requests. Override this to set an app-specific one
    USERAGENT = None

    def __init__(self, config):
        self.config = config

        self._session_pool_size = 0
        self._session_pool_maxsize = config.max_connections or self.SESSION_POOLSIZE

        # Try to behave nicely with the remote server. We want to keep the connection open between requests.
        # We also want to re-use sessions, to avoid the NTLM auth handshake on every request. We must know the
        # authentication method to create sessions.
        self._session_pool = LifoQueue()
        self._session_pool_lock = Lock()

    @property
    def service_endpoint(self):
        return self.config.service_endpoint

    @abc.abstractmethod
    def get_auth_type(self):
        &#34;&#34;&#34;Autodetect authentication type&#34;&#34;&#34;

    @property
    def auth_type(self):
        # Autodetect authentication type if necessary
        if self.config.auth_type is None:
            self.config.auth_type = self.get_auth_type()
        return self.config.auth_type

    @property
    def credentials(self):
        return self.config.credentials

    @credentials.setter
    def credentials(self, value):
        # We are updating credentials, but that doesn&#39;t automatically propagate to the session objects. The simplest
        # solution is to just kill the sessions in the pool.
        with self._session_pool_lock:
            self.config._credentials = value
            self.close()

    @property
    def max_connections(self):
        return self._session_pool_maxsize

    @max_connections.setter
    def max_connections(self, value):
        with self._session_pool_lock:
            self._session_pool_maxsize = value or self.SESSION_POOLSIZE

    @property
    def retry_policy(self):
        return self.config.retry_policy

    @property
    def server(self):
        return self.config.server

    def __getstate__(self):
        # The session pool and lock cannot be pickled
        state = self.__dict__.copy()
        del state[&#34;_session_pool&#34;]
        del state[&#34;_session_pool_lock&#34;]
        return state

    def __setstate__(self, state):
        # Restore the session pool and lock
        self.__dict__.update(state)
        self._session_pool = LifoQueue()
        self._session_pool_lock = Lock()

    def __del__(self):
        # pylint: disable=bare-except
        try:
            self.close()
        except Exception:  # nosec
            # __del__ should never fail
            pass

    def close(self):
        log.debug(&#34;Server %s: Closing sessions&#34;, self.server)
        while True:
            try:
                session = self._session_pool.get(block=False)
                self.close_session(session)
                self._session_pool_size -= 1
            except Empty:
                break

    @classmethod
    def get_adapter(cls):
        # We want just one connection per session. No retries, since we wrap all requests in our own retry handler
        return cls.HTTP_ADAPTER_CLS(
            pool_block=True,
            pool_connections=cls.CONNECTIONS_PER_SESSION,
            pool_maxsize=cls.CONNECTIONS_PER_SESSION,
            max_retries=0,
        )

    @property
    def session_pool_size(self):
        return self._session_pool_size

    def increase_poolsize(self):
        &#34;&#34;&#34;Increases the session pool size. We increase by one session per call.&#34;&#34;&#34;
        # Create a single session and insert it into the pool. We need to protect this with a lock while we are changing
        # the pool size variable, to avoid race conditions. We must not exceed the pool size limit.
        if self._session_pool_size &gt;= self._session_pool_maxsize:
            raise SessionPoolMaxSizeReached(&#34;Session pool size cannot be increased further&#34;)
        with self._session_pool_lock:
            if self._session_pool_size &gt;= self._session_pool_maxsize:
                log.debug(&#34;Session pool size was increased in another thread&#34;)
                return
            log.debug(
                &#34;Server %s: Increasing session pool size from %s to %s&#34;,
                self.server,
                self._session_pool_size,
                self._session_pool_size + 1,
            )
            self._session_pool.put(self.create_session(), block=False)
            self._session_pool_size += 1

    def decrease_poolsize(self):
        &#34;&#34;&#34;Decreases the session pool size in response to error messages from the server requesting to rate-limit
        requests. We decrease by one session per call.
        &#34;&#34;&#34;
        # Take a single session from the pool and discard it. We need to protect this with a lock while we are changing
        # the pool size variable, to avoid race conditions. We must keep at least one session in the pool.
        if self._session_pool_size &lt;= 1:
            raise SessionPoolMinSizeReached(&#34;Session pool size cannot be decreased further&#34;)
        with self._session_pool_lock:
            if self._session_pool_size &lt;= 1:
                log.debug(&#34;Session pool size was decreased in another thread&#34;)
                return
            log.warning(
                &#34;Server %s: Decreasing session pool size from %s to %s&#34;,
                self.server,
                self._session_pool_size,
                self._session_pool_size - 1,
            )
            session = self.get_session()
            self.close_session(session)
            self._session_pool_size -= 1

    def get_session(self):
        # Try to get a session from the queue. If the queue is empty, try to add one more session to the queue. If the
        # queue is already at its max, wait until a session becomes available.
        _timeout = 60  # Rate-limit messages about session starvation
        try:
            session = self._session_pool.get(block=False)
            log.debug(&#34;Server %s: Got session immediately&#34;, self.server)
        except Empty:
            with suppress(SessionPoolMaxSizeReached):
                self.increase_poolsize()
            while True:
                try:
                    log.debug(&#34;Server %s: Waiting for session&#34;, self.server)
                    session = self._session_pool.get(timeout=_timeout)
                    break
                except Empty:
                    # This is normal when we have many worker threads starving for available sessions
                    log.debug(&#34;Server %s: No sessions available for %s seconds&#34;, self.server, _timeout)
        log.debug(&#34;Server %s: Got session %s&#34;, self.server, session.session_id)
        session.usage_count += 1
        return session

    def release_session(self, session):
        # This should never fail, as we don&#39;t have more sessions than the queue contains
        log.debug(&#34;Server %s: Releasing session %s&#34;, self.server, session.session_id)
        if self.MAX_SESSION_USAGE_COUNT and session.usage_count &gt;= self.MAX_SESSION_USAGE_COUNT:
            log.debug(&#34;Server %s: session %s usage exceeded limit. Discarding&#34;, self.server, session.session_id)
            session = self.renew_session(session)
        self._session_pool.put(session, block=False)

    def close_session(self, session):
        if isinstance(self.credentials, BaseOAuth2Credentials) and isinstance(
            self.credentials.client, BackendApplicationClient
        ):
            # Reset access token
            with self.credentials.lock:
                self.credentials.access_token = None
        session.close()
        del session

    def retire_session(self, session):
        # The session is useless. Close it completely and place a fresh session in the pool
        log.debug(&#34;Server %s: Retiring session %s&#34;, self.server, session.session_id)
        self.close_session(session)
        self.release_session(self.create_session())

    def renew_session(self, session):
        # The session is useless. Close it completely and place a fresh session in the pool
        log.debug(&#34;Server %s: Renewing session %s&#34;, self.server, session.session_id)
        self.close_session(session)
        return self.create_session()

    def refresh_credentials(self, session):
        # Credentials need to be refreshed, probably due to an OAuth
        # access token expiring. If we&#39;ve gotten here, it&#39;s because the
        # application didn&#39;t provide an OAuth client secret, so we can&#39;t
        # handle token refreshing for it.
        with self.credentials.lock:
            if self.credentials.sig() == session.credentials_sig:
                # Credentials have not been refreshed by another thread:
                # they&#39;re the same as the session was created with. If
                # this isn&#39;t the case, we can just go ahead with a new
                # session using the already-updated credentials.
                self.credentials.refresh(session=session)
        return self.renew_session(session)

    def create_session(self):
        if self.credentials is None:
            if self.auth_type in CREDENTIALS_REQUIRED:
                raise ValueError(f&#34;Auth type {self.auth_type!r} requires credentials&#34;)
            session = self.raw_session(self.service_endpoint)
            session.auth = get_auth_instance(auth_type=self.auth_type)
        else:
            if isinstance(self.credentials, BaseOAuth2Credentials):
                with self.credentials.lock:
                    session = self.create_oauth2_session()
                    # Keep track of the credentials used to create this session. If and when we need to renew
                    # credentials (for example, refreshing an OAuth access token), this lets us easily determine whether
                    # the credentials have already been refreshed in another thread by the time this session tries.
                    session.credentials_sig = self.credentials.sig()
            else:
                if self.auth_type == NTLM and self.credentials.type == self.credentials.EMAIL:
                    username = &#34;\\&#34; + self.credentials.username
                else:
                    username = self.credentials.username
                session = self.raw_session(self.service_endpoint)
                session.auth = get_auth_instance(
                    auth_type=self.auth_type, username=username, password=self.credentials.password
                )

        # Add some extra info
        session.session_id = random.randint(10000, 99999)  # Used for debugging messages in services
        session.usage_count = 0
        log.debug(&#34;Server %s: Created session %s&#34;, self.server, session.session_id)
        return session

    def create_oauth2_session(self):
        session = self.raw_session(
            self.service_endpoint,
            oauth2_client=self.credentials.client,
            oauth2_session_params=self.credentials.session_params(),
            oauth2_token_endpoint=self.credentials.token_url,
        )
        if not session.token:
            # Fetch the token explicitly -- it doesn&#39;t occur implicitly
            token = session.fetch_token(
                token_url=self.credentials.token_url,
                client_id=self.credentials.client_id,
                client_secret=self.credentials.client_secret,
                scope=self.credentials.scope,
                timeout=self.TIMEOUT,
                **self.credentials.token_params(),
            )
            # Allow the credentials object to update its copy of the new token, and give the application an opportunity
            # to cache it.
            self.credentials.on_token_auto_refreshed(token)
        session.auth = get_auth_instance(auth_type=OAUTH2, client=self.credentials.client)

        return session

    @classmethod
    def raw_session(cls, prefix, oauth2_client=None, oauth2_session_params=None, oauth2_token_endpoint=None):
        if oauth2_client:
            session = OAuth2Session(client=oauth2_client, **(oauth2_session_params or {}))
        else:
            session = requests.sessions.Session()
        session.headers.update(DEFAULT_HEADERS)
        session.headers[&#34;User-Agent&#34;] = cls.USERAGENT
        session.mount(prefix, adapter=cls.get_adapter())
        if oauth2_token_endpoint:
            session.mount(oauth2_token_endpoint, adapter=cls.get_adapter())
        return session

    def __repr__(self):
        return self.__class__.__name__ + repr((self.service_endpoint, self.credentials, self.auth_type))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.autodiscover.protocol.AutodiscoverProtocol" href="autodiscover/protocol.html#exchangelib.autodiscover.protocol.AutodiscoverProtocol">AutodiscoverProtocol</a></li>
<li><a title="exchangelib.protocol.Protocol" href="protocol.html#exchangelib.protocol.Protocol">Protocol</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.BaseProtocol.CONNECTIONS_PER_SESSION"><code class="name">var <span class="ident">CONNECTIONS_PER_SESSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.BaseProtocol.HTTP_ADAPTER_CLS"><code class="name">var <span class="ident">HTTP_ADAPTER_CLS</span></code></dt>
<dd>
<div class="desc"><p>The built-in HTTP Adapter for urllib3.</p>
<p>Provides a general-case interface for Requests sessions to contact HTTP and
HTTPS urls by implementing the Transport Adapter interface. This class will
usually be created by the :class:<code>Session &lt;Session&gt;</code> class under the
covers.</p>
<p>:param pool_connections: The number of urllib3 connection pools to cache.
:param pool_maxsize: The maximum number of connections to save in the pool.
:param max_retries: The maximum number of retries each connection
should attempt. Note, this applies only to failed DNS lookups, socket
connections and connection timeouts, never to requests where data has
made it to the server. By default, Requests does not retry failed
connections. If you need granular control over the conditions under
which we retry a request, import urllib3's <code>Retry</code> class and pass
that instead.
:param pool_block: Whether the connection pool should block for connections.</p>
<p>Usage::</p>
<blockquote>
<blockquote>
<blockquote>
<p>import requests
s = requests.Session()
a = requests.adapters.HTTPAdapter(max_retries=3)
s.mount('http://', a)</p>
</blockquote>
</blockquote>
</blockquote></div>
</dd>
<dt id="exchangelib.BaseProtocol.MAX_SESSION_USAGE_COUNT"><code class="name">var <span class="ident">MAX_SESSION_USAGE_COUNT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.BaseProtocol.RETRY_WAIT"><code class="name">var <span class="ident">RETRY_WAIT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.BaseProtocol.SESSION_POOLSIZE"><code class="name">var <span class="ident">SESSION_POOLSIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.BaseProtocol.TIMEOUT"><code class="name">var <span class="ident">TIMEOUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.BaseProtocol.USERAGENT"><code class="name">var <span class="ident">USERAGENT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.BaseProtocol.get_adapter"><code class="name flex">
<span>def <span class="ident">get_adapter</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_adapter(cls):
    # We want just one connection per session. No retries, since we wrap all requests in our own retry handler
    return cls.HTTP_ADAPTER_CLS(
        pool_block=True,
        pool_connections=cls.CONNECTIONS_PER_SESSION,
        pool_maxsize=cls.CONNECTIONS_PER_SESSION,
        max_retries=0,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.raw_session"><code class="name flex">
<span>def <span class="ident">raw_session</span></span>(<span>prefix, oauth2_client=None, oauth2_session_params=None, oauth2_token_endpoint=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def raw_session(cls, prefix, oauth2_client=None, oauth2_session_params=None, oauth2_token_endpoint=None):
    if oauth2_client:
        session = OAuth2Session(client=oauth2_client, **(oauth2_session_params or {}))
    else:
        session = requests.sessions.Session()
    session.headers.update(DEFAULT_HEADERS)
    session.headers[&#34;User-Agent&#34;] = cls.USERAGENT
    session.mount(prefix, adapter=cls.get_adapter())
    if oauth2_token_endpoint:
        session.mount(oauth2_token_endpoint, adapter=cls.get_adapter())
    return session</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.BaseProtocol.auth_type"><code class="name">var <span class="ident">auth_type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def auth_type(self):
    # Autodetect authentication type if necessary
    if self.config.auth_type is None:
        self.config.auth_type = self.get_auth_type()
    return self.config.auth_type</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.credentials"><code class="name">var <span class="ident">credentials</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def credentials(self):
    return self.config.credentials</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.max_connections"><code class="name">var <span class="ident">max_connections</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_connections(self):
    return self._session_pool_maxsize</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.retry_policy"><code class="name">var <span class="ident">retry_policy</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def retry_policy(self):
    return self.config.retry_policy</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.server"><code class="name">var <span class="ident">server</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def server(self):
    return self.config.server</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.service_endpoint"><code class="name">var <span class="ident">service_endpoint</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def service_endpoint(self):
    return self.config.service_endpoint</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.session_pool_size"><code class="name">var <span class="ident">session_pool_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def session_pool_size(self):
    return self._session_pool_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.BaseProtocol.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    log.debug(&#34;Server %s: Closing sessions&#34;, self.server)
    while True:
        try:
            session = self._session_pool.get(block=False)
            self.close_session(session)
            self._session_pool_size -= 1
        except Empty:
            break</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.close_session"><code class="name flex">
<span>def <span class="ident">close_session</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_session(self, session):
    if isinstance(self.credentials, BaseOAuth2Credentials) and isinstance(
        self.credentials.client, BackendApplicationClient
    ):
        # Reset access token
        with self.credentials.lock:
            self.credentials.access_token = None
    session.close()
    del session</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.create_oauth2_session"><code class="name flex">
<span>def <span class="ident">create_oauth2_session</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_oauth2_session(self):
    session = self.raw_session(
        self.service_endpoint,
        oauth2_client=self.credentials.client,
        oauth2_session_params=self.credentials.session_params(),
        oauth2_token_endpoint=self.credentials.token_url,
    )
    if not session.token:
        # Fetch the token explicitly -- it doesn&#39;t occur implicitly
        token = session.fetch_token(
            token_url=self.credentials.token_url,
            client_id=self.credentials.client_id,
            client_secret=self.credentials.client_secret,
            scope=self.credentials.scope,
            timeout=self.TIMEOUT,
            **self.credentials.token_params(),
        )
        # Allow the credentials object to update its copy of the new token, and give the application an opportunity
        # to cache it.
        self.credentials.on_token_auto_refreshed(token)
    session.auth = get_auth_instance(auth_type=OAUTH2, client=self.credentials.client)

    return session</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.create_session"><code class="name flex">
<span>def <span class="ident">create_session</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_session(self):
    if self.credentials is None:
        if self.auth_type in CREDENTIALS_REQUIRED:
            raise ValueError(f&#34;Auth type {self.auth_type!r} requires credentials&#34;)
        session = self.raw_session(self.service_endpoint)
        session.auth = get_auth_instance(auth_type=self.auth_type)
    else:
        if isinstance(self.credentials, BaseOAuth2Credentials):
            with self.credentials.lock:
                session = self.create_oauth2_session()
                # Keep track of the credentials used to create this session. If and when we need to renew
                # credentials (for example, refreshing an OAuth access token), this lets us easily determine whether
                # the credentials have already been refreshed in another thread by the time this session tries.
                session.credentials_sig = self.credentials.sig()
        else:
            if self.auth_type == NTLM and self.credentials.type == self.credentials.EMAIL:
                username = &#34;\\&#34; + self.credentials.username
            else:
                username = self.credentials.username
            session = self.raw_session(self.service_endpoint)
            session.auth = get_auth_instance(
                auth_type=self.auth_type, username=username, password=self.credentials.password
            )

    # Add some extra info
    session.session_id = random.randint(10000, 99999)  # Used for debugging messages in services
    session.usage_count = 0
    log.debug(&#34;Server %s: Created session %s&#34;, self.server, session.session_id)
    return session</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.decrease_poolsize"><code class="name flex">
<span>def <span class="ident">decrease_poolsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decreases the session pool size in response to error messages from the server requesting to rate-limit
requests. We decrease by one session per call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrease_poolsize(self):
    &#34;&#34;&#34;Decreases the session pool size in response to error messages from the server requesting to rate-limit
    requests. We decrease by one session per call.
    &#34;&#34;&#34;
    # Take a single session from the pool and discard it. We need to protect this with a lock while we are changing
    # the pool size variable, to avoid race conditions. We must keep at least one session in the pool.
    if self._session_pool_size &lt;= 1:
        raise SessionPoolMinSizeReached(&#34;Session pool size cannot be decreased further&#34;)
    with self._session_pool_lock:
        if self._session_pool_size &lt;= 1:
            log.debug(&#34;Session pool size was decreased in another thread&#34;)
            return
        log.warning(
            &#34;Server %s: Decreasing session pool size from %s to %s&#34;,
            self.server,
            self._session_pool_size,
            self._session_pool_size - 1,
        )
        session = self.get_session()
        self.close_session(session)
        self._session_pool_size -= 1</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.get_auth_type"><code class="name flex">
<span>def <span class="ident">get_auth_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Autodetect authentication type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractmethod
def get_auth_type(self):
    &#34;&#34;&#34;Autodetect authentication type&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.get_session"><code class="name flex">
<span>def <span class="ident">get_session</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_session(self):
    # Try to get a session from the queue. If the queue is empty, try to add one more session to the queue. If the
    # queue is already at its max, wait until a session becomes available.
    _timeout = 60  # Rate-limit messages about session starvation
    try:
        session = self._session_pool.get(block=False)
        log.debug(&#34;Server %s: Got session immediately&#34;, self.server)
    except Empty:
        with suppress(SessionPoolMaxSizeReached):
            self.increase_poolsize()
        while True:
            try:
                log.debug(&#34;Server %s: Waiting for session&#34;, self.server)
                session = self._session_pool.get(timeout=_timeout)
                break
            except Empty:
                # This is normal when we have many worker threads starving for available sessions
                log.debug(&#34;Server %s: No sessions available for %s seconds&#34;, self.server, _timeout)
    log.debug(&#34;Server %s: Got session %s&#34;, self.server, session.session_id)
    session.usage_count += 1
    return session</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.increase_poolsize"><code class="name flex">
<span>def <span class="ident">increase_poolsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Increases the session pool size. We increase by one session per call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increase_poolsize(self):
    &#34;&#34;&#34;Increases the session pool size. We increase by one session per call.&#34;&#34;&#34;
    # Create a single session and insert it into the pool. We need to protect this with a lock while we are changing
    # the pool size variable, to avoid race conditions. We must not exceed the pool size limit.
    if self._session_pool_size &gt;= self._session_pool_maxsize:
        raise SessionPoolMaxSizeReached(&#34;Session pool size cannot be increased further&#34;)
    with self._session_pool_lock:
        if self._session_pool_size &gt;= self._session_pool_maxsize:
            log.debug(&#34;Session pool size was increased in another thread&#34;)
            return
        log.debug(
            &#34;Server %s: Increasing session pool size from %s to %s&#34;,
            self.server,
            self._session_pool_size,
            self._session_pool_size + 1,
        )
        self._session_pool.put(self.create_session(), block=False)
        self._session_pool_size += 1</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.refresh_credentials"><code class="name flex">
<span>def <span class="ident">refresh_credentials</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_credentials(self, session):
    # Credentials need to be refreshed, probably due to an OAuth
    # access token expiring. If we&#39;ve gotten here, it&#39;s because the
    # application didn&#39;t provide an OAuth client secret, so we can&#39;t
    # handle token refreshing for it.
    with self.credentials.lock:
        if self.credentials.sig() == session.credentials_sig:
            # Credentials have not been refreshed by another thread:
            # they&#39;re the same as the session was created with. If
            # this isn&#39;t the case, we can just go ahead with a new
            # session using the already-updated credentials.
            self.credentials.refresh(session=session)
    return self.renew_session(session)</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.release_session"><code class="name flex">
<span>def <span class="ident">release_session</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def release_session(self, session):
    # This should never fail, as we don&#39;t have more sessions than the queue contains
    log.debug(&#34;Server %s: Releasing session %s&#34;, self.server, session.session_id)
    if self.MAX_SESSION_USAGE_COUNT and session.usage_count &gt;= self.MAX_SESSION_USAGE_COUNT:
        log.debug(&#34;Server %s: session %s usage exceeded limit. Discarding&#34;, self.server, session.session_id)
        session = self.renew_session(session)
    self._session_pool.put(session, block=False)</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.renew_session"><code class="name flex">
<span>def <span class="ident">renew_session</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renew_session(self, session):
    # The session is useless. Close it completely and place a fresh session in the pool
    log.debug(&#34;Server %s: Renewing session %s&#34;, self.server, session.session_id)
    self.close_session(session)
    return self.create_session()</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.retire_session"><code class="name flex">
<span>def <span class="ident">retire_session</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retire_session(self, session):
    # The session is useless. Close it completely and place a fresh session in the pool
    log.debug(&#34;Server %s: Retiring session %s&#34;, self.server, session.session_id)
    self.close_session(session)
    self.release_session(self.create_session())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Body"><code class="flex name class">
<span>class <span class="ident">Body</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to mark the 'body' field as a complex attribute.</p>
<p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Body(str):
    &#34;&#34;&#34;Helper to mark the &#39;body&#39; field as a complex attribute.

    MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body
    &#34;&#34;&#34;

    body_type = &#34;Text&#34;

    def __add__(self, other):
        # Make sure Body(&#39;&#39;) + &#39;foo&#39; returns a Body type
        return self.__class__(super().__add__(other))

    def __mod__(self, other):
        # Make sure Body(&#39;%s&#39;) % &#39;foo&#39; returns a Body type
        return self.__class__(super().__mod__(other))

    def format(self, *args, **kwargs):
        # Make sure Body(&#39;{}&#39;).format(&#39;foo&#39;) returns a Body type
        return self.__class__(super().format(*args, **kwargs))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.HTMLBody" href="properties.html#exchangelib.properties.HTMLBody">HTMLBody</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Body.body_type"><code class="name">var <span class="ident">body_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Body.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>S.format(<em>args, </em>*kwargs) -&gt; str</p>
<p>Return a formatted version of S, using substitutions from args and kwargs.
The substitutions are identified by braces ('{' and '}').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, *args, **kwargs):
    # Make sure Body(&#39;{}&#39;).format(&#39;foo&#39;) returns a Body type
    return self.__class__(super().format(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Build"><code class="flex name class">
<span>class <span class="ident">Build</span></span>
<span>(</span><span>major_version, minor_version, major_build=0, minor_build=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds methods for working with build numbers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Build:
    &#34;&#34;&#34;Holds methods for working with build numbers.&#34;&#34;&#34;

    __slots__ = &#34;major_version&#34;, &#34;minor_version&#34;, &#34;major_build&#34;, &#34;minor_build&#34;

    def __init__(self, major_version, minor_version, major_build=0, minor_build=0):
        if not isinstance(major_version, int):
            raise InvalidTypeError(&#34;major_version&#34;, major_version, int)
        if not isinstance(minor_version, int):
            raise InvalidTypeError(&#34;minor_version&#34;, minor_version, int)
        if not isinstance(major_build, int):
            raise InvalidTypeError(&#34;major_build&#34;, major_build, int)
        if not isinstance(minor_build, int):
            raise InvalidTypeError(&#34;minor_build&#34;, minor_build, int)
        self.major_version = major_version
        self.minor_version = minor_version
        self.major_build = major_build
        self.minor_build = minor_build
        if major_version &lt; 8:
            raise ValueError(f&#34;Exchange major versions below 8 don&#39;t support EWS ({self})&#34;)

    @classmethod
    def from_xml(cls, elem):
        xml_elems_map = {
            &#34;major_version&#34;: &#34;MajorVersion&#34;,
            &#34;minor_version&#34;: &#34;MinorVersion&#34;,
            &#34;major_build&#34;: &#34;MajorBuildNumber&#34;,
            &#34;minor_build&#34;: &#34;MinorBuildNumber&#34;,
        }
        kwargs = {}
        for k, xml_elem in xml_elems_map.items():
            v = elem.get(xml_elem)
            if v is None:
                v = get_xml_attr(elem, f&#34;{{{ANS}}}{xml_elem}&#34;)
                if v is None:
                    raise ValueError()
            kwargs[k] = int(v)  # Also raises ValueError
        return cls(**kwargs)

    def api_version(self):
        for build, api_version, _ in VERSIONS:
            if self.major_version != build.major_version or self.minor_version != build.minor_version:
                continue
            if self &gt;= build:
                return api_version
        raise ValueError(f&#34;API version for build {self} is unknown&#34;)

    def __cmp__(self, other):
        # __cmp__ is not a magic method in Python3. We&#39;ll just use it here to implement comparison operators
        c = (self.major_version &gt; other.major_version) - (self.major_version &lt; other.major_version)
        if c != 0:
            return c
        c = (self.minor_version &gt; other.minor_version) - (self.minor_version &lt; other.minor_version)
        if c != 0:
            return c
        c = (self.major_build &gt; other.major_build) - (self.major_build &lt; other.major_build)
        if c != 0:
            return c
        return (self.minor_build &gt; other.minor_build) - (self.minor_build &lt; other.minor_build)

    def __eq__(self, other):
        return self.__cmp__(other) == 0

    def __hash__(self):
        return hash(repr(self))

    def __ne__(self, other):
        return self.__cmp__(other) != 0

    def __lt__(self, other):
        return self.__cmp__(other) &lt; 0

    def __le__(self, other):
        return self.__cmp__(other) &lt;= 0

    def __gt__(self, other):
        return self.__cmp__(other) &gt; 0

    def __ge__(self, other):
        return self.__cmp__(other) &gt;= 0

    def __str__(self):
        return f&#34;{self.major_version}.{self.minor_version}.{self.major_build}.{self.minor_build}&#34;

    def __repr__(self):
        return self.__class__.__name__ + repr(
            (self.major_version, self.minor_version, self.major_build, self.minor_build)
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.Build.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem):
    xml_elems_map = {
        &#34;major_version&#34;: &#34;MajorVersion&#34;,
        &#34;minor_version&#34;: &#34;MinorVersion&#34;,
        &#34;major_build&#34;: &#34;MajorBuildNumber&#34;,
        &#34;minor_build&#34;: &#34;MinorBuildNumber&#34;,
    }
    kwargs = {}
    for k, xml_elem in xml_elems_map.items():
        v = elem.get(xml_elem)
        if v is None:
            v = get_xml_attr(elem, f&#34;{{{ANS}}}{xml_elem}&#34;)
            if v is None:
                raise ValueError()
        kwargs[k] = int(v)  # Also raises ValueError
    return cls(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Build.major_build"><code class="name">var <span class="ident">major_build</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Build.major_version"><code class="name">var <span class="ident">major_version</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Build.minor_build"><code class="name">var <span class="ident">minor_build</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Build.minor_version"><code class="name">var <span class="ident">minor_version</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Build.api_version"><code class="name flex">
<span>def <span class="ident">api_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def api_version(self):
    for build, api_version, _ in VERSIONS:
        if self.major_version != build.major_version or self.minor_version != build.minor_version:
            continue
        if self &gt;= build:
            return api_version
    raise ValueError(f&#34;API version for build {self} is unknown&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.CalendarItem"><code class="flex name class">
<span>class <span class="ident">CalendarItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/calendaritem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/calendaritem</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalendarItem(Item, AcceptDeclineMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/calendaritem&#34;&#34;&#34;

    ELEMENT_NAME = &#34;CalendarItem&#34;

    uid = TextField(field_uri=&#34;calendar:UID&#34;, is_required_after_save=True, is_searchable=False)
    recurrence_id = DateTimeField(field_uri=&#34;calendar:RecurrenceId&#34;, is_read_only=True)
    start = DateOrDateTimeField(field_uri=&#34;calendar:Start&#34;, is_required=True)
    end = DateOrDateTimeField(field_uri=&#34;calendar:End&#34;, is_required=True)
    original_start = DateTimeField(field_uri=&#34;calendar:OriginalStart&#34;, is_read_only=True)
    is_all_day = BooleanField(field_uri=&#34;calendar:IsAllDayEvent&#34;, is_required=True, default=False)
    legacy_free_busy_status = FreeBusyStatusField(
        field_uri=&#34;calendar:LegacyFreeBusyStatus&#34;, is_required=True, default=&#34;Busy&#34;
    )
    location = TextField(field_uri=&#34;calendar:Location&#34;)
    when = TextField(field_uri=&#34;calendar:When&#34;)
    is_meeting = BooleanField(field_uri=&#34;calendar:IsMeeting&#34;, is_read_only=True)
    is_cancelled = BooleanField(field_uri=&#34;calendar:IsCancelled&#34;, is_read_only=True)
    is_recurring = BooleanField(field_uri=&#34;calendar:IsRecurring&#34;, is_read_only=True)
    meeting_request_was_sent = BooleanField(field_uri=&#34;calendar:MeetingRequestWasSent&#34;, is_read_only=True)
    is_response_requested = BooleanField(
        field_uri=&#34;calendar:IsResponseRequested&#34;, default=None, is_required_after_save=True, is_searchable=False
    )
    type = ChoiceField(
        field_uri=&#34;calendar:CalendarItemType&#34;, choices={Choice(c) for c in CALENDAR_ITEM_CHOICES}, is_read_only=True
    )
    my_response_type = ChoiceField(
        field_uri=&#34;calendar:MyResponseType&#34;, choices={Choice(c) for c in Attendee.RESPONSE_TYPES}, is_read_only=True
    )
    organizer = MailboxField(field_uri=&#34;calendar:Organizer&#34;, is_read_only=True)
    required_attendees = AttendeesField(field_uri=&#34;calendar:RequiredAttendees&#34;, is_searchable=False)
    optional_attendees = AttendeesField(field_uri=&#34;calendar:OptionalAttendees&#34;, is_searchable=False)
    resources = AttendeesField(field_uri=&#34;calendar:Resources&#34;, is_searchable=False)
    conflicting_meeting_count = IntegerField(field_uri=&#34;calendar:ConflictingMeetingCount&#34;, is_read_only=True)
    adjacent_meeting_count = IntegerField(field_uri=&#34;calendar:AdjacentMeetingCount&#34;, is_read_only=True)
    conflicting_meetings = EWSElementListField(
        field_uri=&#34;calendar:ConflictingMeetings&#34;, value_cls=&#34;CalendarItem&#34;, namespace=Item.NAMESPACE, is_read_only=True
    )
    adjacent_meetings = EWSElementListField(
        field_uri=&#34;calendar:AdjacentMeetings&#34;, value_cls=&#34;CalendarItem&#34;, namespace=Item.NAMESPACE, is_read_only=True
    )
    duration = CharField(field_uri=&#34;calendar:Duration&#34;, is_read_only=True)
    appointment_reply_time = DateTimeField(field_uri=&#34;calendar:AppointmentReplyTime&#34;, is_read_only=True)
    appointment_sequence_number = IntegerField(field_uri=&#34;calendar:AppointmentSequenceNumber&#34;, is_read_only=True)
    appointment_state = AppointmentStateField(field_uri=&#34;calendar:AppointmentState&#34;, is_read_only=True)
    recurrence = RecurrenceField(field_uri=&#34;calendar:Recurrence&#34;, is_searchable=False)
    first_occurrence = OccurrenceField(
        field_uri=&#34;calendar:FirstOccurrence&#34;, value_cls=FirstOccurrence, is_read_only=True
    )
    last_occurrence = OccurrenceField(field_uri=&#34;calendar:LastOccurrence&#34;, value_cls=LastOccurrence, is_read_only=True)
    modified_occurrences = OccurrenceListField(
        field_uri=&#34;calendar:ModifiedOccurrences&#34;, value_cls=Occurrence, is_read_only=True
    )
    deleted_occurrences = OccurrenceListField(
        field_uri=&#34;calendar:DeletedOccurrences&#34;, value_cls=DeletedOccurrence, is_read_only=True
    )
    _meeting_timezone = TimeZoneField(
        field_uri=&#34;calendar:MeetingTimeZone&#34;, deprecated_from=EXCHANGE_2010, is_searchable=False
    )
    _start_timezone = TimeZoneField(
        field_uri=&#34;calendar:StartTimeZone&#34;, supported_from=EXCHANGE_2010, is_searchable=False
    )
    _end_timezone = TimeZoneField(field_uri=&#34;calendar:EndTimeZone&#34;, supported_from=EXCHANGE_2010, is_searchable=False)
    conference_type = EnumAsIntField(
        field_uri=&#34;calendar:ConferenceType&#34;, enum=CONFERENCE_TYPES, min=0, default=None, is_required_after_save=True
    )
    allow_new_time_proposal = BooleanField(
        field_uri=&#34;calendar:AllowNewTimeProposal&#34;, default=None, is_required_after_save=True, is_searchable=False
    )
    is_online_meeting = BooleanField(field_uri=&#34;calendar:IsOnlineMeeting&#34;, default=None, is_read_only=True)
    meeting_workspace_url = URIField(field_uri=&#34;calendar:MeetingWorkspaceUrl&#34;)
    net_show_url = URIField(field_uri=&#34;calendar:NetShowUrl&#34;)

    def occurrence(self, index):
        &#34;&#34;&#34;Get an occurrence of a recurring master by index. No query is sent to the server to actually fetch the item.
        Call refresh() on the item to do so.

        Only call this method on a recurring master.

        :param index: The index, which is 1-based

        :return The occurrence
        &#34;&#34;&#34;
        return self.__class__(
            account=self.account,
            folder=self.folder,
            _id=OccurrenceItemId(id=self.id, changekey=self.changekey, instance_index=index),
        )

    def recurring_master(self):
        &#34;&#34;&#34;Get the recurring master of an occurrence. No query is sent to the server to actually fetch the item.
        Call refresh() on the item to do so.

        Only call this method on an occurrence of a recurring master.

        :return: The master occurrence
        &#34;&#34;&#34;
        return self.__class__(
            account=self.account,
            folder=self.folder,
            _id=RecurringMasterItemId(id=self.id, changekey=self.changekey),
        )

    @classmethod
    def timezone_fields(cls):
        return tuple(f for f in cls.FIELDS if isinstance(f, TimeZoneField))

    def clean_timezone_fields(self, version):
        # Sets proper values on the timezone fields if they are not already set
        if self.start is None:
            start_tz = None
        elif type(self.start) in (EWSDate, datetime.date):
            start_tz = self.account.default_timezone
        else:
            start_tz = self.start.tzinfo
        if self.end is None:
            end_tz = None
        elif type(self.end) in (EWSDate, datetime.date):
            end_tz = self.account.default_timezone
        else:
            end_tz = self.end.tzinfo
        if version.build &lt; EXCHANGE_2010:
            if self._meeting_timezone is None:
                self._meeting_timezone = start_tz
            self._start_timezone = None
            self._end_timezone = None
        else:
            self._meeting_timezone = None
            if self._start_timezone is None:
                self._start_timezone = start_tz
            if self._end_timezone is None:
                self._end_timezone = end_tz

    def clean(self, version=None):
        super().clean(version=version)
        if self.start and self.end and self.end &lt; self.start:
            raise ValueError(f&#34;&#39;end&#39; must be greater than &#39;start&#39; ({self.start} -&gt; {self.end})&#34;)
        if version:
            self.clean_timezone_fields(version=version)

    def cancel(self, **kwargs):
        return CancelCalendarItem(
            account=self.account, reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey), **kwargs
        ).send()

    def _update_fieldnames(self):
        update_fields = super()._update_fieldnames()
        if self.type == OCCURRENCE:
            # Some CalendarItem fields cannot be updated when the item is an occurrence. The values are empty when we
            # receive them so would have been updated because they are set to None.
            update_fields.remove(&#34;recurrence&#34;)
            update_fields.remove(&#34;uid&#34;)
        return update_fields

    @classmethod
    def from_xml(cls, elem, account):
        item = super().from_xml(elem=elem, account=account)
        # EWS returns the start and end values as a datetime regardless of the is_all_day status. Convert to date if
        # applicable.
        if not item.is_all_day:
            return item
        for field_name in (&#34;start&#34;, &#34;end&#34;):
            val = getattr(item, field_name)
            if val is None:
                continue
            # Return just the date part of the value. Subtract 1 day from the date if this is the end field. This is
            # the inverse of what we do in .to_xml(). Convert to the local timezone before getting the date.
            if field_name == &#34;end&#34;:
                val -= datetime.timedelta(days=1)
            tz = getattr(item, f&#34;_{field_name}_timezone&#34;)
            setattr(item, field_name, val.astimezone(tz).date())
        return item

    def tz_field_for_field_name(self, field_name):
        meeting_tz_field, start_tz_field, end_tz_field = CalendarItem.timezone_fields()
        if self.account.version.build &lt; EXCHANGE_2010:
            return meeting_tz_field
        if field_name == &#34;start&#34;:
            return start_tz_field
        if field_name == &#34;end&#34;:
            return end_tz_field
        raise ValueError(&#34;Unsupported field_name&#34;)

    def date_to_datetime(self, field_name):
        # EWS always expects a datetime. If we have a date value, then convert it to datetime in the local
        # timezone. Additionally, if this the end field, add 1 day to the date. We could add 12 hours to both
        # start and end values and let EWS apply its logic, but that seems hacky.
        value = getattr(self, field_name)
        tz = getattr(self, self.tz_field_for_field_name(field_name).name)
        value = EWSDateTime.combine(value, datetime.time(0, 0)).replace(tzinfo=tz)
        if field_name == &#34;end&#34;:
            value += datetime.timedelta(days=1)
        return value

    def to_xml(self, version):
        # EWS has some special logic related to all-day start and end values. Non-midnight start values are pushed to
        # the previous midnight. Non-midnight end values are pushed to the following midnight. Midnight in this context
        # refers to midnight in the local timezone. See
        #
        # https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/how-to-create-all-day-events-by-using-ews-in-exchange
        #
        elem = super().to_xml(version=version)
        if not self.is_all_day:
            return elem
        for field_name in (&#34;start&#34;, &#34;end&#34;):
            value = getattr(self, field_name)
            if value is None:
                continue
            if type(value) in (EWSDate, datetime.date):
                # EWS always expects a datetime
                value = self.date_to_datetime(field_name=field_name)
                # We already generated an XML element for this field, but it contains a plain date at this point, which
                # is invalid. Replace the value.
                field = self.get_field_by_fieldname(field_name)
                set_xml_value(elem.find(field.response_tag()), value)
        return elem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
<li><a title="exchangelib.items.calendar_item.AcceptDeclineMixIn" href="items/calendar_item.html#exchangelib.items.calendar_item.AcceptDeclineMixIn">AcceptDeclineMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.CalendarItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.CalendarItem.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    item = super().from_xml(elem=elem, account=account)
    # EWS returns the start and end values as a datetime regardless of the is_all_day status. Convert to date if
    # applicable.
    if not item.is_all_day:
        return item
    for field_name in (&#34;start&#34;, &#34;end&#34;):
        val = getattr(item, field_name)
        if val is None:
            continue
        # Return just the date part of the value. Subtract 1 day from the date if this is the end field. This is
        # the inverse of what we do in .to_xml(). Convert to the local timezone before getting the date.
        if field_name == &#34;end&#34;:
            val -= datetime.timedelta(days=1)
        tz = getattr(item, f&#34;_{field_name}_timezone&#34;)
        setattr(item, field_name, val.astimezone(tz).date())
    return item</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.timezone_fields"><code class="name flex">
<span>def <span class="ident">timezone_fields</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def timezone_fields(cls):
    return tuple(f for f in cls.FIELDS if isinstance(f, TimeZoneField))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.CalendarItem.adjacent_meeting_count"><code class="name">var <span class="ident">adjacent_meeting_count</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.adjacent_meetings"><code class="name">var <span class="ident">adjacent_meetings</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.allow_new_time_proposal"><code class="name">var <span class="ident">allow_new_time_proposal</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.appointment_reply_time"><code class="name">var <span class="ident">appointment_reply_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.appointment_sequence_number"><code class="name">var <span class="ident">appointment_sequence_number</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.appointment_state"><code class="name">var <span class="ident">appointment_state</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.conference_type"><code class="name">var <span class="ident">conference_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.conflicting_meeting_count"><code class="name">var <span class="ident">conflicting_meeting_count</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.conflicting_meetings"><code class="name">var <span class="ident">conflicting_meetings</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.deleted_occurrences"><code class="name">var <span class="ident">deleted_occurrences</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.duration"><code class="name">var <span class="ident">duration</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.first_occurrence"><code class="name">var <span class="ident">first_occurrence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_all_day"><code class="name">var <span class="ident">is_all_day</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_cancelled"><code class="name">var <span class="ident">is_cancelled</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_meeting"><code class="name">var <span class="ident">is_meeting</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_online_meeting"><code class="name">var <span class="ident">is_online_meeting</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_recurring"><code class="name">var <span class="ident">is_recurring</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_response_requested"><code class="name">var <span class="ident">is_response_requested</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.last_occurrence"><code class="name">var <span class="ident">last_occurrence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.legacy_free_busy_status"><code class="name">var <span class="ident">legacy_free_busy_status</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.location"><code class="name">var <span class="ident">location</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.meeting_request_was_sent"><code class="name">var <span class="ident">meeting_request_was_sent</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.meeting_workspace_url"><code class="name">var <span class="ident">meeting_workspace_url</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.modified_occurrences"><code class="name">var <span class="ident">modified_occurrences</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.my_response_type"><code class="name">var <span class="ident">my_response_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.net_show_url"><code class="name">var <span class="ident">net_show_url</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.optional_attendees"><code class="name">var <span class="ident">optional_attendees</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.organizer"><code class="name">var <span class="ident">organizer</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.original_start"><code class="name">var <span class="ident">original_start</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.recurrence"><code class="name">var <span class="ident">recurrence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.recurrence_id"><code class="name">var <span class="ident">recurrence_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.required_attendees"><code class="name">var <span class="ident">required_attendees</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.start"><code class="name">var <span class="ident">start</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.uid"><code class="name">var <span class="ident">uid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.when"><code class="name">var <span class="ident">when</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.CalendarItem.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, **kwargs):
    return CancelCalendarItem(
        account=self.account, reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey), **kwargs
    ).send()</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    super().clean(version=version)
    if self.start and self.end and self.end &lt; self.start:
        raise ValueError(f&#34;&#39;end&#39; must be greater than &#39;start&#39; ({self.start} -&gt; {self.end})&#34;)
    if version:
        self.clean_timezone_fields(version=version)</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.clean_timezone_fields"><code class="name flex">
<span>def <span class="ident">clean_timezone_fields</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_timezone_fields(self, version):
    # Sets proper values on the timezone fields if they are not already set
    if self.start is None:
        start_tz = None
    elif type(self.start) in (EWSDate, datetime.date):
        start_tz = self.account.default_timezone
    else:
        start_tz = self.start.tzinfo
    if self.end is None:
        end_tz = None
    elif type(self.end) in (EWSDate, datetime.date):
        end_tz = self.account.default_timezone
    else:
        end_tz = self.end.tzinfo
    if version.build &lt; EXCHANGE_2010:
        if self._meeting_timezone is None:
            self._meeting_timezone = start_tz
        self._start_timezone = None
        self._end_timezone = None
    else:
        self._meeting_timezone = None
        if self._start_timezone is None:
            self._start_timezone = start_tz
        if self._end_timezone is None:
            self._end_timezone = end_tz</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.date_to_datetime"><code class="name flex">
<span>def <span class="ident">date_to_datetime</span></span>(<span>self, field_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date_to_datetime(self, field_name):
    # EWS always expects a datetime. If we have a date value, then convert it to datetime in the local
    # timezone. Additionally, if this the end field, add 1 day to the date. We could add 12 hours to both
    # start and end values and let EWS apply its logic, but that seems hacky.
    value = getattr(self, field_name)
    tz = getattr(self, self.tz_field_for_field_name(field_name).name)
    value = EWSDateTime.combine(value, datetime.time(0, 0)).replace(tzinfo=tz)
    if field_name == &#34;end&#34;:
        value += datetime.timedelta(days=1)
    return value</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.occurrence"><code class="name flex">
<span>def <span class="ident">occurrence</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an occurrence of a recurring master by index. No query is sent to the server to actually fetch the item.
Call refresh() on the item to do so.</p>
<p>Only call this method on a recurring master.</p>
<p>:param index: The index, which is 1-based</p>
<p>:return The occurrence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def occurrence(self, index):
    &#34;&#34;&#34;Get an occurrence of a recurring master by index. No query is sent to the server to actually fetch the item.
    Call refresh() on the item to do so.

    Only call this method on a recurring master.

    :param index: The index, which is 1-based

    :return The occurrence
    &#34;&#34;&#34;
    return self.__class__(
        account=self.account,
        folder=self.folder,
        _id=OccurrenceItemId(id=self.id, changekey=self.changekey, instance_index=index),
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.recurring_master"><code class="name flex">
<span>def <span class="ident">recurring_master</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the recurring master of an occurrence. No query is sent to the server to actually fetch the item.
Call refresh() on the item to do so.</p>
<p>Only call this method on an occurrence of a recurring master.</p>
<p>:return: The master occurrence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recurring_master(self):
    &#34;&#34;&#34;Get the recurring master of an occurrence. No query is sent to the server to actually fetch the item.
    Call refresh() on the item to do so.

    Only call this method on an occurrence of a recurring master.

    :return: The master occurrence
    &#34;&#34;&#34;
    return self.__class__(
        account=self.account,
        folder=self.folder,
        _id=RecurringMasterItemId(id=self.id, changekey=self.changekey),
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self, version):
    # EWS has some special logic related to all-day start and end values. Non-midnight start values are pushed to
    # the previous midnight. Non-midnight end values are pushed to the following midnight. Midnight in this context
    # refers to midnight in the local timezone. See
    #
    # https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/how-to-create-all-day-events-by-using-ews-in-exchange
    #
    elem = super().to_xml(version=version)
    if not self.is_all_day:
        return elem
    for field_name in (&#34;start&#34;, &#34;end&#34;):
        value = getattr(self, field_name)
        if value is None:
            continue
        if type(value) in (EWSDate, datetime.date):
            # EWS always expects a datetime
            value = self.date_to_datetime(field_name=field_name)
            # We already generated an XML element for this field, but it contains a plain date at this point, which
            # is invalid. Replace the value.
            field = self.get_field_by_fieldname(field_name)
            set_xml_value(elem.find(field.response_tag()), value)
    return elem</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.tz_field_for_field_name"><code class="name flex">
<span>def <span class="ident">tz_field_for_field_name</span></span>(<span>self, field_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tz_field_for_field_name(self, field_name):
    meeting_tz_field, start_tz_field, end_tz_field = CalendarItem.timezone_fields()
    if self.account.version.build &lt; EXCHANGE_2010:
        return meeting_tz_field
    if field_name == &#34;start&#34;:
        return start_tz_field
    if field_name == &#34;end&#34;:
        return end_tz_field
    raise ValueError(&#34;Unsupported field_name&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.CancelCalendarItem"><code class="flex name class">
<span>class <span class="ident">CancelCalendarItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/cancelcalendaritem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/cancelcalendaritem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CancelCalendarItem(BaseReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/cancelcalendaritem&#34;&#34;&#34;

    ELEMENT_NAME = &#34;CancelCalendarItem&#34;
    author_idx = BaseReplyItem.FIELDS.index_by_name(&#34;author&#34;)
    FIELDS = BaseReplyItem.FIELDS[:author_idx] + BaseReplyItem.FIELDS[author_idx + 1 :]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.CancelCalendarItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CancelCalendarItem.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CancelCalendarItem.author_idx"><code class="name">var <span class="ident">author_idx</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.base.BaseReplyItem.account" href="items/base.html#exchangelib.items.base.BaseReplyItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.save" href="items/base.html#exchangelib.items.base.BaseReplyItem.save">save</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Configuration"><code class="flex name class">
<span>class <span class="ident">Configuration</span></span>
<span>(</span><span>credentials=None, server=None, service_endpoint=None, auth_type=None, version=None, retry_policy=None, max_connections=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains information needed to create an authenticated connection to an EWS endpoint.</p>
<p>The 'credentials' argument contains the credentials needed to authenticate with the server. Multiple credentials
implementations are available in 'exchangelib.credentials'.</p>
<p>config = Configuration(credentials=Credentials('john@example.com', 'MY_SECRET'), &hellip;)</p>
<p>The 'server' and 'service_endpoint' arguments are mutually exclusive. The former must contain only a domain name,
the latter a full URL:</p>
<pre><code>config = Configuration(server='example.com', ...)
config = Configuration(service_endpoint='https://mail.example.com/EWS/Exchange.asmx', ...)
</code></pre>
<p>If you know which authentication type the server uses, you add that as a hint in 'auth_type'. Likewise, you can
add the server version as a hint. This allows to skip the auth type and version guessing routines:</p>
<pre><code>config = Configuration(auth_type=NTLM, ...)
config = Configuration(version=Version(build=Build(15, 1, 2, 3)), ...)
</code></pre>
<p>You can use 'retry_policy' to define a custom retry policy for handling server connection failures:</p>
<pre><code>config = Configuration(retry_policy=FaultTolerance(max_wait=3600), ...)
</code></pre>
<p>'max_connections' defines the max number of connections allowed for this server. This may be restricted by
policies on the Exchange server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Configuration:
    &#34;&#34;&#34;Contains information needed to create an authenticated connection to an EWS endpoint.

    The &#39;credentials&#39; argument contains the credentials needed to authenticate with the server. Multiple credentials
    implementations are available in &#39;exchangelib.credentials&#39;.

    config = Configuration(credentials=Credentials(&#39;john@example.com&#39;, &#39;MY_SECRET&#39;), ...)

    The &#39;server&#39; and &#39;service_endpoint&#39; arguments are mutually exclusive. The former must contain only a domain name,
    the latter a full URL:

        config = Configuration(server=&#39;example.com&#39;, ...)
        config = Configuration(service_endpoint=&#39;https://mail.example.com/EWS/Exchange.asmx&#39;, ...)

    If you know which authentication type the server uses, you add that as a hint in &#39;auth_type&#39;. Likewise, you can
    add the server version as a hint. This allows to skip the auth type and version guessing routines:

        config = Configuration(auth_type=NTLM, ...)
        config = Configuration(version=Version(build=Build(15, 1, 2, 3)), ...)

    You can use &#39;retry_policy&#39; to define a custom retry policy for handling server connection failures:

        config = Configuration(retry_policy=FaultTolerance(max_wait=3600), ...)

    &#39;max_connections&#39; defines the max number of connections allowed for this server. This may be restricted by
    policies on the Exchange server.
    &#34;&#34;&#34;

    def __init__(
        self,
        credentials=None,
        server=None,
        service_endpoint=None,
        auth_type=None,
        version=None,
        retry_policy=None,
        max_connections=None,
    ):
        if not isinstance(credentials, (BaseCredentials, type(None))):
            raise InvalidTypeError(&#34;credentials&#34;, credentials, BaseCredentials)
        if auth_type is None and isinstance(credentials, BaseOAuth2Credentials):
            # Set a default auth type for the credentials where this makes sense
            auth_type = OAUTH2
        if auth_type is not None and auth_type not in AUTH_TYPE_MAP:
            raise InvalidEnumValue(&#34;auth_type&#34;, auth_type, AUTH_TYPE_MAP)
        if credentials is None and auth_type in CREDENTIALS_REQUIRED:
            raise ValueError(f&#34;Auth type {auth_type!r} was detected but no credentials were provided&#34;)
        if server and service_endpoint:
            raise AttributeError(&#34;Only one of &#39;server&#39; or &#39;service_endpoint&#39; must be provided&#34;)
        if not retry_policy:
            retry_policy = FailFast()
        if not isinstance(version, (Version, type(None))):
            raise InvalidTypeError(&#34;version&#34;, version, Version)
        if not isinstance(retry_policy, RetryPolicy):
            raise InvalidTypeError(&#34;retry_policy&#34;, retry_policy, RetryPolicy)
        if not isinstance(max_connections, (int, type(None))):
            raise InvalidTypeError(&#34;max_connections&#34;, max_connections, int)
        self._credentials = credentials
        if server:
            self.service_endpoint = f&#34;https://{server}/EWS/Exchange.asmx&#34;
        else:
            self.service_endpoint = service_endpoint
        self.auth_type = auth_type
        self.version = version
        self.retry_policy = retry_policy
        self.max_connections = max_connections

    @property
    def credentials(self):
        # Do not update credentials from this class. Instead, do it from Protocol
        return self._credentials

    @threaded_cached_property
    def server(self):
        if not self.service_endpoint:
            return None
        return split_url(self.service_endpoint)[1]

    def __repr__(self):
        args_str = &#34;, &#34;.join(
            f&#34;{k}={getattr(self, k)!r}&#34;
            for k in (&#34;credentials&#34;, &#34;service_endpoint&#34;, &#34;auth_type&#34;, &#34;version&#34;, &#34;retry_policy&#34;)
        )
        return f&#34;{self.__class__.__name__}({args_str})&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.configuration.O365InteractiveConfiguration" href="configuration.html#exchangelib.configuration.O365InteractiveConfiguration">O365InteractiveConfiguration</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Configuration.credentials"><code class="name">var <span class="ident">credentials</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def credentials(self):
    # Do not update credentials from this class. Instead, do it from Protocol
    return self._credentials</code></pre>
</details>
</dd>
<dt id="exchangelib.Configuration.server"><code class="name">var <span class="ident">server</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Contact"><code class="flex name class">
<span>class <span class="ident">Contact</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/contact">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/contact</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Contact(Item):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/contact&#34;&#34;&#34;

    ELEMENT_NAME = &#34;Contact&#34;

    file_as = TextField(field_uri=&#34;contacts:FileAs&#34;)
    file_as_mapping = ChoiceField(
        field_uri=&#34;contacts:FileAsMapping&#34;,
        choices={
            Choice(&#34;None&#34;),
            Choice(&#34;LastCommaFirst&#34;),
            Choice(&#34;FirstSpaceLast&#34;),
            Choice(&#34;Company&#34;),
            Choice(&#34;LastCommaFirstCompany&#34;),
            Choice(&#34;CompanyLastFirst&#34;),
            Choice(&#34;LastFirst&#34;),
            Choice(&#34;LastFirstCompany&#34;),
            Choice(&#34;CompanyLastCommaFirst&#34;),
            Choice(&#34;LastFirstSuffix&#34;),
            Choice(&#34;LastSpaceFirstCompany&#34;),
            Choice(&#34;CompanyLastSpaceFirst&#34;),
            Choice(&#34;LastSpaceFirst&#34;),
            Choice(&#34;DisplayName&#34;),
            Choice(&#34;FirstName&#34;),
            Choice(&#34;LastFirstMiddleSuffix&#34;),
            Choice(&#34;LastName&#34;),
            Choice(&#34;Empty&#34;),
        },
    )
    display_name = TextField(field_uri=&#34;contacts:DisplayName&#34;, is_required=True)
    given_name = CharField(field_uri=&#34;contacts:GivenName&#34;)
    initials = TextField(field_uri=&#34;contacts:Initials&#34;)
    middle_name = CharField(field_uri=&#34;contacts:MiddleName&#34;)
    nickname = TextField(field_uri=&#34;contacts:Nickname&#34;)
    complete_name = EWSElementField(field_uri=&#34;contacts:CompleteName&#34;, value_cls=CompleteName, is_read_only=True)
    company_name = TextField(field_uri=&#34;contacts:CompanyName&#34;)
    email_addresses = EmailAddressesField(field_uri=&#34;contacts:EmailAddress&#34;)
    physical_addresses = PhysicalAddressField(field_uri=&#34;contacts:PhysicalAddress&#34;)
    phone_numbers = PhoneNumberField(field_uri=&#34;contacts:PhoneNumber&#34;)
    assistant_name = TextField(field_uri=&#34;contacts:AssistantName&#34;)
    birthday = DateTimeBackedDateField(field_uri=&#34;contacts:Birthday&#34;, default_time=datetime.time(11, 59))
    business_homepage = URIField(field_uri=&#34;contacts:BusinessHomePage&#34;)
    children = TextListField(field_uri=&#34;contacts:Children&#34;)
    companies = TextListField(field_uri=&#34;contacts:Companies&#34;, is_searchable=False)
    contact_source = ChoiceField(
        field_uri=&#34;contacts:ContactSource&#34;, choices={Choice(&#34;Store&#34;), Choice(&#34;ActiveDirectory&#34;)}, is_read_only=True
    )
    department = TextField(field_uri=&#34;contacts:Department&#34;)
    generation = TextField(field_uri=&#34;contacts:Generation&#34;)
    im_addresses = ImAddressField(field_uri=&#34;contacts:ImAddress&#34;)
    job_title = TextField(field_uri=&#34;contacts:JobTitle&#34;)
    manager = TextField(field_uri=&#34;contacts:Manager&#34;)
    mileage = TextField(field_uri=&#34;contacts:Mileage&#34;)
    office = TextField(field_uri=&#34;contacts:OfficeLocation&#34;)
    postal_address_index = ChoiceField(
        field_uri=&#34;contacts:PostalAddressIndex&#34;,
        choices={Choice(&#34;Business&#34;), Choice(&#34;Home&#34;), Choice(&#34;Other&#34;), Choice(&#34;None&#34;)},
        default=&#34;None&#34;,
        is_required_after_save=True,
    )
    profession = TextField(field_uri=&#34;contacts:Profession&#34;)
    spouse_name = TextField(field_uri=&#34;contacts:SpouseName&#34;)
    surname = CharField(field_uri=&#34;contacts:Surname&#34;)
    wedding_anniversary = DateTimeBackedDateField(
        field_uri=&#34;contacts:WeddingAnniversary&#34;, default_time=datetime.time(11, 59)
    )
    has_picture = BooleanField(field_uri=&#34;contacts:HasPicture&#34;, supported_from=EXCHANGE_2010, is_read_only=True)
    phonetic_full_name = TextField(
        field_uri=&#34;contacts:PhoneticFullName&#34;, supported_from=EXCHANGE_2010_SP2, is_read_only=True
    )
    phonetic_first_name = TextField(
        field_uri=&#34;contacts:PhoneticFirstName&#34;, supported_from=EXCHANGE_2010_SP2, is_read_only=True
    )
    phonetic_last_name = TextField(
        field_uri=&#34;contacts:PhoneticLastName&#34;, supported_from=EXCHANGE_2010_SP2, is_read_only=True
    )
    email_alias = EmailAddressField(field_uri=&#34;contacts:Alias&#34;, is_read_only=True, supported_from=EXCHANGE_2010_SP2)
    # &#39;notes&#39; is documented in MSDN but apparently unused. Writing to it raises ErrorInvalidPropertyRequest. OWA
    # put entries into the &#39;notes&#39; form field into the &#39;body&#39; field.
    notes = CharField(field_uri=&#34;contacts:Notes&#34;, supported_from=EXCHANGE_2010_SP2, is_read_only=True)
    # &#39;photo&#39; is documented in MSDN but apparently unused. Writing to it raises ErrorInvalidPropertyRequest. OWA
    # adds photos as FileAttachments on the contact item (with &#39;is_contact_photo=True&#39;), which automatically flips
    # the &#39;has_picture&#39; field.
    photo = Base64Field(field_uri=&#34;contacts:Photo&#34;, supported_from=EXCHANGE_2010_SP2, is_read_only=True)
    user_smime_certificate = Base64Field(
        field_uri=&#34;contacts:UserSMIMECertificate&#34;, supported_from=EXCHANGE_2010_SP2, is_read_only=True
    )
    ms_exchange_certificate = Base64Field(
        field_uri=&#34;contacts:MSExchangeCertificate&#34;, supported_from=EXCHANGE_2010_SP2, is_read_only=True
    )
    directory_id = TextField(field_uri=&#34;contacts:DirectoryId&#34;, supported_from=EXCHANGE_2010_SP2, is_read_only=True)
    manager_mailbox = MailboxField(
        field_uri=&#34;contacts:ManagerMailbox&#34;, supported_from=EXCHANGE_2010_SP2, is_read_only=True
    )
    direct_reports = MailboxListField(
        field_uri=&#34;contacts:DirectReports&#34;, supported_from=EXCHANGE_2010_SP2, is_read_only=True
    )
    # O365 throws ErrorInternalServerError &#34;[0x004f0102] MapiReplyToBlob&#34; if UniqueBody is requested
    unique_body_idx = Item.FIELDS.index_by_name(&#34;unique_body&#34;)
    FIELDS = Item.FIELDS[:unique_body_idx] + Item.FIELDS[unique_body_idx + 1 :]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Contact.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.unique_body_idx"><code class="name">var <span class="ident">unique_body_idx</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Contact.assistant_name"><code class="name">var <span class="ident">assistant_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.birthday"><code class="name">var <span class="ident">birthday</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.business_homepage"><code class="name">var <span class="ident">business_homepage</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.companies"><code class="name">var <span class="ident">companies</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.company_name"><code class="name">var <span class="ident">company_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.complete_name"><code class="name">var <span class="ident">complete_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.contact_source"><code class="name">var <span class="ident">contact_source</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.department"><code class="name">var <span class="ident">department</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.direct_reports"><code class="name">var <span class="ident">direct_reports</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.directory_id"><code class="name">var <span class="ident">directory_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.display_name"><code class="name">var <span class="ident">display_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.email_addresses"><code class="name">var <span class="ident">email_addresses</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.email_alias"><code class="name">var <span class="ident">email_alias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.file_as"><code class="name">var <span class="ident">file_as</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.file_as_mapping"><code class="name">var <span class="ident">file_as_mapping</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.generation"><code class="name">var <span class="ident">generation</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.given_name"><code class="name">var <span class="ident">given_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.has_picture"><code class="name">var <span class="ident">has_picture</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.im_addresses"><code class="name">var <span class="ident">im_addresses</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.initials"><code class="name">var <span class="ident">initials</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.job_title"><code class="name">var <span class="ident">job_title</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.manager"><code class="name">var <span class="ident">manager</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.manager_mailbox"><code class="name">var <span class="ident">manager_mailbox</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.middle_name"><code class="name">var <span class="ident">middle_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.mileage"><code class="name">var <span class="ident">mileage</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.ms_exchange_certificate"><code class="name">var <span class="ident">ms_exchange_certificate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.nickname"><code class="name">var <span class="ident">nickname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.notes"><code class="name">var <span class="ident">notes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.office"><code class="name">var <span class="ident">office</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.phone_numbers"><code class="name">var <span class="ident">phone_numbers</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.phonetic_first_name"><code class="name">var <span class="ident">phonetic_first_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.phonetic_full_name"><code class="name">var <span class="ident">phonetic_full_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.phonetic_last_name"><code class="name">var <span class="ident">phonetic_last_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.photo"><code class="name">var <span class="ident">photo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.physical_addresses"><code class="name">var <span class="ident">physical_addresses</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.postal_address_index"><code class="name">var <span class="ident">postal_address_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.profession"><code class="name">var <span class="ident">profession</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.spouse_name"><code class="name">var <span class="ident">spouse_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.surname"><code class="name">var <span class="ident">surname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.user_smime_certificate"><code class="name">var <span class="ident">user_smime_certificate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.wedding_anniversary"><code class="name">var <span class="ident">wedding_anniversary</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Credentials"><code class="flex name class">
<span>class <span class="ident">Credentials</span></span>
<span>(</span><span>username, password)</span>
</code></dt>
<dd>
<div class="desc"><p>Keeps login info the way Exchange likes it.</p>
<p>Usernames for authentication are of one of these forms:
* PrimarySMTPAddress
* WINDOMAIN\username
* User Principal Name (UPN)
password: Clear-text password</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Credentials(BaseCredentials):
    r&#34;&#34;&#34;Keeps login info the way Exchange likes it.

    Usernames for authentication are of one of these forms:
    * PrimarySMTPAddress
    * WINDOMAIN\username
    * User Principal Name (UPN)
      password: Clear-text password
    &#34;&#34;&#34;

    EMAIL = &#34;email&#34;
    DOMAIN = &#34;domain&#34;
    UPN = &#34;upn&#34;

    def __init__(self, username, password):
        super().__init__()
        if username.count(&#34;@&#34;) == 1:
            self.type = self.EMAIL
        elif username.count(&#34;\\&#34;) == 1:
            self.type = self.DOMAIN
        else:
            self.type = self.UPN
        self.username = username
        self.password = password

    def __repr__(self):
        return self.__class__.__name__ + repr((self.username, &#34;********&#34;))

    def __str__(self):
        return self.username</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseCredentials" href="credentials.html#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Credentials.DOMAIN"><code class="name">var <span class="ident">DOMAIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Credentials.EMAIL"><code class="name">var <span class="ident">EMAIL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Credentials.UPN"><code class="name">var <span class="ident">UPN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="exchangelib.DLMailbox"><code class="flex name class">
<span>class <span class="ident">DLMailbox</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like Mailbox, but creates elements in the 'messages' namespace when sending requests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DLMailbox(Mailbox):
    &#34;&#34;&#34;Like Mailbox, but creates elements in the &#39;messages&#39; namespace when sending requests.&#34;&#34;&#34;

    NAMESPACE = MNS</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.DLMailbox.NAMESPACE"><code class="name">var <span class="ident">NAMESPACE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.Mailbox.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.DeclineItem"><code class="flex name class">
<span>class <span class="ident">DeclineItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/declineitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/declineitem</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeclineItem(BaseMeetingReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/declineitem&#34;&#34;&#34;

    ELEMENT_NAME = &#34;DeclineItem&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.DeclineItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.DistributionList"><code class="flex name class">
<span>class <span class="ident">DistributionList</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/distributionlist">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/distributionlist</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DistributionList(Item):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/distributionlist&#34;&#34;&#34;

    ELEMENT_NAME = &#34;DistributionList&#34;

    display_name = CharField(field_uri=&#34;contacts:DisplayName&#34;, is_required=True)
    file_as = CharField(field_uri=&#34;contacts:FileAs&#34;, is_read_only=True)
    contact_source = ChoiceField(
        field_uri=&#34;contacts:ContactSource&#34;, choices={Choice(&#34;Store&#34;), Choice(&#34;ActiveDirectory&#34;)}, is_read_only=True
    )
    members = MemberListField(field_uri=&#34;distributionlist:Members&#34;)

    # O365 throws ErrorInternalServerError &#34;[0x004f0102] MapiReplyToBlob&#34; if UniqueBody is requested
    unique_body_idx = Item.FIELDS.index_by_name(&#34;unique_body&#34;)
    FIELDS = Item.FIELDS[:unique_body_idx] + Item.FIELDS[unique_body_idx + 1 :]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.DistributionList.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.DistributionList.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.DistributionList.unique_body_idx"><code class="name">var <span class="ident">unique_body_idx</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.DistributionList.contact_source"><code class="name">var <span class="ident">contact_source</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.DistributionList.display_name"><code class="name">var <span class="ident">display_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.DistributionList.file_as"><code class="name">var <span class="ident">file_as</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.DistributionList.members"><code class="name">var <span class="ident">members</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.EWSDate"><code class="flex name class">
<span>class <span class="ident">EWSDate</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends the normal date implementation to satisfy EWS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EWSDate(datetime.date):
    &#34;&#34;&#34;Extends the normal date implementation to satisfy EWS.&#34;&#34;&#34;

    __slots__ = &#34;_year&#34;, &#34;_month&#34;, &#34;_day&#34;, &#34;_hashcode&#34;

    def ewsformat(self):
        &#34;&#34;&#34;ISO 8601 format to satisfy xs:date as interpreted by EWS. Example: 2009-01-15.&#34;&#34;&#34;
        return self.isoformat()

    def __add__(self, other):
        dt = super().__add__(other)
        if isinstance(dt, self.__class__):
            return dt
        return self.from_date(dt)  # We want to return EWSDate objects

    def __iadd__(self, other):
        return self + other

    def __sub__(self, other):
        dt = super().__sub__(other)
        if isinstance(dt, datetime.timedelta):
            return dt
        if isinstance(dt, self.__class__):
            return dt
        return self.from_date(dt)  # We want to return EWSDate objects

    def __isub__(self, other):
        return self - other

    @classmethod
    def fromordinal(cls, n):
        dt = super().fromordinal(n)
        if isinstance(dt, cls):
            return dt
        return cls.from_date(dt)  # We want to return EWSDate objects

    @classmethod
    def from_date(cls, d):
        if type(d) is not datetime.date:
            raise InvalidTypeError(&#34;d&#34;, d, datetime.date)
        return cls(d.year, d.month, d.day)

    @classmethod
    def from_string(cls, date_string):
        # Sometimes, we&#39;ll receive a date string with time zone information. Not very useful.
        if date_string.endswith(&#34;Z&#34;):
            date_fmt = &#34;%Y-%m-%dZ&#34;
        elif &#34;:&#34; in date_string:
            if &#34;+&#34; in date_string:
                date_fmt = &#34;%Y-%m-%d+%H:%M&#34;
            else:
                date_fmt = &#34;%Y-%m-%d-%H:%M&#34;
        else:
            date_fmt = &#34;%Y-%m-%d&#34;
        d = datetime.datetime.strptime(date_string, date_fmt).date()
        if isinstance(d, cls):
            return d
        return cls.from_date(d)  # We want to return EWSDate objects</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>datetime.date</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.EWSDate.from_date"><code class="name flex">
<span>def <span class="ident">from_date</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_date(cls, d):
    if type(d) is not datetime.date:
        raise InvalidTypeError(&#34;d&#34;, d, datetime.date)
    return cls(d.year, d.month, d.day)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDate.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>date_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, date_string):
    # Sometimes, we&#39;ll receive a date string with time zone information. Not very useful.
    if date_string.endswith(&#34;Z&#34;):
        date_fmt = &#34;%Y-%m-%dZ&#34;
    elif &#34;:&#34; in date_string:
        if &#34;+&#34; in date_string:
            date_fmt = &#34;%Y-%m-%d+%H:%M&#34;
        else:
            date_fmt = &#34;%Y-%m-%d-%H:%M&#34;
    else:
        date_fmt = &#34;%Y-%m-%d&#34;
    d = datetime.datetime.strptime(date_string, date_fmt).date()
    if isinstance(d, cls):
        return d
    return cls.from_date(d)  # We want to return EWSDate objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDate.fromordinal"><code class="name flex">
<span>def <span class="ident">fromordinal</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>int -&gt; date corresponding to a proleptic Gregorian ordinal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromordinal(cls, n):
    dt = super().fromordinal(n)
    if isinstance(dt, cls):
        return dt
    return cls.from_date(dt)  # We want to return EWSDate objects</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.EWSDate.ewsformat"><code class="name flex">
<span>def <span class="ident">ewsformat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ISO 8601 format to satisfy xs:date as interpreted by EWS. Example: 2009-01-15.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ewsformat(self):
    &#34;&#34;&#34;ISO 8601 format to satisfy xs:date as interpreted by EWS. Example: 2009-01-15.&#34;&#34;&#34;
    return self.isoformat()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.EWSDateTime"><code class="flex name class">
<span>class <span class="ident">EWSDateTime</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends the normal datetime implementation to satisfy EWS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EWSDateTime(datetime.datetime):
    &#34;&#34;&#34;Extends the normal datetime implementation to satisfy EWS.&#34;&#34;&#34;

    __slots__ = &#34;_year&#34;, &#34;_month&#34;, &#34;_day&#34;, &#34;_hour&#34;, &#34;_minute&#34;, &#34;_second&#34;, &#34;_microsecond&#34;, &#34;_tzinfo&#34;, &#34;_hashcode&#34;

    def __new__(cls, *args, **kwargs):
        # pylint: disable=arguments-differ

        if len(args) == 8:
            tzinfo = args[7]
        else:
            tzinfo = kwargs.get(&#34;tzinfo&#34;)
        if isinstance(tzinfo, zoneinfo.ZoneInfo):
            # Don&#39;t allow pytz or dateutil timezones here. They are not safe to use as direct input for datetime()
            tzinfo = EWSTimeZone.from_timezone(tzinfo)
        if not isinstance(tzinfo, (EWSTimeZone, type(None))):
            raise InvalidTypeError(&#34;tzinfo&#34;, tzinfo, EWSTimeZone)
        if len(args) == 8:
            args = args[:7] + (tzinfo,)
        else:
            kwargs[&#34;tzinfo&#34;] = tzinfo
        return super().__new__(cls, *args, **kwargs)

    def ewsformat(self):
        &#34;&#34;&#34;ISO 8601 format to satisfy xs:datetime as interpreted by EWS. Examples:
        * 2009-01-15T13:45:56Z
        * 2009-01-15T13:45:56+01:00
        &#34;&#34;&#34;
        if not self.tzinfo:
            raise ValueError(f&#34;{self!r} must be timezone-aware&#34;)
        if self.tzinfo.key == &#34;UTC&#34;:
            if self.microsecond:
                return self.strftime(&#34;%Y-%m-%dT%H:%M:%S.%fZ&#34;)
            return self.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
        return self.isoformat()

    @classmethod
    def from_datetime(cls, d):
        if type(d) is not datetime.datetime:
            raise InvalidTypeError(&#34;d&#34;, d, datetime.datetime)
        if d.tzinfo is None:
            tz = None
        elif isinstance(d.tzinfo, EWSTimeZone):
            tz = d.tzinfo
        else:
            tz = EWSTimeZone.from_timezone(d.tzinfo)
        return cls(d.year, d.month, d.day, d.hour, d.minute, d.second, d.microsecond, tzinfo=tz)

    def astimezone(self, tz=None):
        if tz is None:
            tz = EWSTimeZone.localzone()
        t = super().astimezone(tz=tz).replace(tzinfo=tz)
        if isinstance(t, self.__class__):
            return t
        return self.from_datetime(t)  # We want to return EWSDateTime objects

    @classmethod
    def fromisoformat(cls, date_string):
        return cls.from_string(date_string)

    def __add__(self, other):
        t = super().__add__(other)
        if isinstance(t, self.__class__):
            return t
        return self.from_datetime(t)  # We want to return EWSDateTime objects

    def __iadd__(self, other):
        return self + other

    def __sub__(self, other):
        t = super().__sub__(other)
        if isinstance(t, datetime.timedelta):
            return t
        if isinstance(t, self.__class__):
            return t
        return self.from_datetime(t)  # We want to return EWSDateTime objects

    def __isub__(self, other):
        return self - other

    @classmethod
    def from_string(cls, date_string):
        # Parses several common datetime formats and returns time zone aware EWSDateTime objects
        if date_string.endswith(&#34;Z&#34;):
            # UTC datetime
            return super().strptime(date_string, &#34;%Y-%m-%dT%H:%M:%SZ&#34;).replace(tzinfo=UTC)
        if len(date_string) == 19:
            # This is probably a naive datetime. Don&#39;t allow this, but signal caller with an appropriate error
            local_dt = super().strptime(date_string, &#34;%Y-%m-%dT%H:%M:%S&#34;)
            raise NaiveDateTimeNotAllowed(local_dt)
        # This is probably a datetime value with time zone information. This comes in the form &#39;+/-HH:MM&#39;.
        aware_dt = datetime.datetime.fromisoformat(date_string).astimezone(UTC).replace(tzinfo=UTC)
        if isinstance(aware_dt, cls):
            return aware_dt
        return cls.from_datetime(aware_dt)

    @classmethod
    def fromtimestamp(cls, t, tz=None):
        dt = super().fromtimestamp(t, tz=tz)
        if isinstance(dt, cls):
            return dt
        return cls.from_datetime(dt)  # We want to return EWSDateTime objects

    @classmethod
    def utcfromtimestamp(cls, t):
        dt = super().utcfromtimestamp(t)
        if isinstance(dt, cls):
            return dt
        return cls.from_datetime(dt)  # We want to return EWSDateTime objects

    @classmethod
    def now(cls, tz=None):
        t = super().now(tz=tz)
        if isinstance(t, cls):
            return t
        return cls.from_datetime(t)  # We want to return EWSDateTime objects

    @classmethod
    def utcnow(cls):
        t = super().utcnow()
        if isinstance(t, cls):
            return t
        return cls.from_datetime(t)  # We want to return EWSDateTime objects

    def date(self):
        d = super().date()
        if isinstance(d, EWSDate):
            return d
        return EWSDate.from_date(d)  # We want to return EWSDate objects</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>datetime.datetime</li>
<li>datetime.date</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.EWSDateTime.from_datetime"><code class="name flex">
<span>def <span class="ident">from_datetime</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_datetime(cls, d):
    if type(d) is not datetime.datetime:
        raise InvalidTypeError(&#34;d&#34;, d, datetime.datetime)
    if d.tzinfo is None:
        tz = None
    elif isinstance(d.tzinfo, EWSTimeZone):
        tz = d.tzinfo
    else:
        tz = EWSTimeZone.from_timezone(d.tzinfo)
    return cls(d.year, d.month, d.day, d.hour, d.minute, d.second, d.microsecond, tzinfo=tz)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>date_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, date_string):
    # Parses several common datetime formats and returns time zone aware EWSDateTime objects
    if date_string.endswith(&#34;Z&#34;):
        # UTC datetime
        return super().strptime(date_string, &#34;%Y-%m-%dT%H:%M:%SZ&#34;).replace(tzinfo=UTC)
    if len(date_string) == 19:
        # This is probably a naive datetime. Don&#39;t allow this, but signal caller with an appropriate error
        local_dt = super().strptime(date_string, &#34;%Y-%m-%dT%H:%M:%S&#34;)
        raise NaiveDateTimeNotAllowed(local_dt)
    # This is probably a datetime value with time zone information. This comes in the form &#39;+/-HH:MM&#39;.
    aware_dt = datetime.datetime.fromisoformat(date_string).astimezone(UTC).replace(tzinfo=UTC)
    if isinstance(aware_dt, cls):
        return aware_dt
    return cls.from_datetime(aware_dt)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.fromisoformat"><code class="name flex">
<span>def <span class="ident">fromisoformat</span></span>(<span>date_string)</span>
</code></dt>
<dd>
<div class="desc"><p>string -&gt; datetime from a string in most ISO 8601 formats</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromisoformat(cls, date_string):
    return cls.from_string(date_string)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.fromtimestamp"><code class="name flex">
<span>def <span class="ident">fromtimestamp</span></span>(<span>t, tz=None)</span>
</code></dt>
<dd>
<div class="desc"><p>timestamp[, tz] -&gt; tz's local time from POSIX timestamp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromtimestamp(cls, t, tz=None):
    dt = super().fromtimestamp(t, tz=tz)
    if isinstance(dt, cls):
        return dt
    return cls.from_datetime(dt)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.now"><code class="name flex">
<span>def <span class="ident">now</span></span>(<span>tz=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns new datetime object representing current time local to tz.</p>
<p>tz
Timezone object.</p>
<p>If no tz is specified, uses local timezone.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def now(cls, tz=None):
    t = super().now(tz=tz)
    if isinstance(t, cls):
        return t
    return cls.from_datetime(t)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.utcfromtimestamp"><code class="name flex">
<span>def <span class="ident">utcfromtimestamp</span></span>(<span>t)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a naive UTC datetime from a POSIX timestamp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def utcfromtimestamp(cls, t):
    dt = super().utcfromtimestamp(t)
    if isinstance(dt, cls):
        return dt
    return cls.from_datetime(dt)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.utcnow"><code class="name flex">
<span>def <span class="ident">utcnow</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new datetime representing UTC day and time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def utcnow(cls):
    t = super().utcnow()
    if isinstance(t, cls):
        return t
    return cls.from_datetime(t)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.EWSDateTime.astimezone"><code class="name flex">
<span>def <span class="ident">astimezone</span></span>(<span>self, tz=None)</span>
</code></dt>
<dd>
<div class="desc"><p>tz -&gt; convert to local time in new timezone tz</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def astimezone(self, tz=None):
    if tz is None:
        tz = EWSTimeZone.localzone()
    t = super().astimezone(tz=tz).replace(tzinfo=tz)
    if isinstance(t, self.__class__):
        return t
    return self.from_datetime(t)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.date"><code class="name flex">
<span>def <span class="ident">date</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return date object with same year, month and day.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date(self):
    d = super().date()
    if isinstance(d, EWSDate):
        return d
    return EWSDate.from_date(d)  # We want to return EWSDate objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.ewsformat"><code class="name flex">
<span>def <span class="ident">ewsformat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ISO 8601 format to satisfy xs:datetime as interpreted by EWS. Examples:
* 2009-01-15T13:45:56Z
* 2009-01-15T13:45:56+01:00</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ewsformat(self):
    &#34;&#34;&#34;ISO 8601 format to satisfy xs:datetime as interpreted by EWS. Examples:
    * 2009-01-15T13:45:56Z
    * 2009-01-15T13:45:56+01:00
    &#34;&#34;&#34;
    if not self.tzinfo:
        raise ValueError(f&#34;{self!r} must be timezone-aware&#34;)
    if self.tzinfo.key == &#34;UTC&#34;:
        if self.microsecond:
            return self.strftime(&#34;%Y-%m-%dT%H:%M:%S.%fZ&#34;)
        return self.strftime(&#34;%Y-%m-%dT%H:%M:%SZ&#34;)
    return self.isoformat()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.EWSTimeZone"><code class="flex name class">
<span>class <span class="ident">EWSTimeZone</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a time zone as expected by the EWS TimezoneContext / TimezoneDefinition XML element, and returned by
services.GetServerTimeZones.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EWSTimeZone(zoneinfo.ZoneInfo):
    &#34;&#34;&#34;Represents a time zone as expected by the EWS TimezoneContext / TimezoneDefinition XML element, and returned by
    services.GetServerTimeZones.
    &#34;&#34;&#34;

    IANA_TO_MS_MAP = IANA_TO_MS_TIMEZONE_MAP
    MS_TO_IANA_MAP = MS_TIMEZONE_TO_IANA_MAP

    def __new__(cls, *args, **kwargs):
        try:
            instance = super().__new__(cls, *args, **kwargs)
        except zoneinfo.ZoneInfoNotFoundError as e:
            raise UnknownTimeZone(e.args[0])
        try:
            instance.ms_id = cls.IANA_TO_MS_MAP[instance.key][0]
        except KeyError:
            raise UnknownTimeZone(f&#34;No Windows timezone name found for timezone {instance.key!r}&#34;)

        # We don&#39;t need the Windows long-format time zone name in long format. It&#39;s used in time zone XML elements, but
        # EWS happily accepts empty strings. For a full list of time zones supported by the target server, including
        # long-format names, see output of services.GetServerTimeZones(account.protocol).call()
        instance.ms_name = &#34;&#34;
        return instance

    def __hash__(self):
        return hash(self.key)

    def __eq__(self, other):
        # Microsoft time zones are less granular than IANA, so an EWSTimeZone created from &#39;Europe/Copenhagen&#39; may
        # return from the server as &#39;Europe/Copenhagen&#39;. We&#39;re catering for Microsoft here, so base equality on the
        # Microsoft time zone ID.
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self.ms_id == other.ms_id

    @classmethod
    def from_ms_id(cls, ms_id):
        # Create a time zone instance from a Microsoft time zone ID. This is lossy because there is not a 1:1
        # translation from MS time zone ID to IANA time zone.
        try:
            return cls(cls.MS_TO_IANA_MAP[ms_id])
        except KeyError:
            if &#34;/&#34; in ms_id:
                # EWS sometimes returns an ID that has a region/location format, e.g. &#39;Europe/Copenhagen&#39;. Try the
                # string unaltered.
                return cls(ms_id)
            raise UnknownTimeZone(f&#34;Windows timezone ID {ms_id!r} is unknown by CLDR&#34;)

    @classmethod
    def from_pytz(cls, tz):
        return cls(tz.zone)

    @classmethod
    def from_datetime(cls, tz):
        &#34;&#34;&#34;Convert from a standard library `datetime.timezone` instance.&#34;&#34;&#34;
        return cls(tz.tzname(None))

    @classmethod
    def from_dateutil(cls, tz):
        # Objects returned by dateutil.tz.tzlocal() and dateutil.tz.gettz() are not supported. They
        # don&#39;t contain enough information to reliably match them with a CLDR time zone.
        if hasattr(tz, &#34;_filename&#34;):
            key = &#34;/&#34;.join(tz._filename.split(&#34;/&#34;)[-2:])
            return cls(key)
        return cls(tz.tzname(datetime.datetime.now()))

    @classmethod
    def from_zoneinfo(cls, tz):
        return cls(tz.key)

    @classmethod
    def from_timezone(cls, tz):
        # Support multiple tzinfo implementations. We could use isinstance(), but then we&#39;d have to have pytz
        # and dateutil as dependencies for this package.
        tz_module = tz.__class__.__module__.split(&#34;.&#34;)[0]
        try:
            return {
                cls.__module__.split(&#34;.&#34;)[0]: lambda z: z,
                &#34;backports&#34;: cls.from_zoneinfo,
                &#34;datetime&#34;: cls.from_datetime,
                &#34;dateutil&#34;: cls.from_dateutil,
                &#34;pytz&#34;: cls.from_pytz,
                &#34;zoneinfo&#34;: cls.from_zoneinfo,
                &#34;pytz_deprecation_shim&#34;: lambda z: cls.from_timezone(z.unwrap_shim()),
            }[tz_module](tz)
        except KeyError:
            raise TypeError(f&#34;Unsupported tzinfo type: {tz!r}&#34;)

    @classmethod
    def localzone(cls):
        try:
            tz = tzlocal.get_localzone()
        except zoneinfo.ZoneInfoNotFoundError:
            # Older versions of tzlocal will raise a pytz exception. Let&#39;s not depend on pytz just for that.
            raise UnknownTimeZone(&#34;Failed to guess local timezone&#34;)
        # Handle both old and new versions of tzlocal that may return pytz or zoneinfo objects, respectively
        return cls.from_timezone(tz)

    def fromutc(self, dt):
        t = super().fromutc(dt)
        if isinstance(t, EWSDateTime):
            return t
        return EWSDateTime.from_datetime(t)  # We want to return EWSDateTime objects</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>zoneinfo.ZoneInfo</li>
<li>datetime.tzinfo</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.EWSTimeZone.IANA_TO_MS_MAP"><code class="name">var <span class="ident">IANA_TO_MS_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.EWSTimeZone.MS_TO_IANA_MAP"><code class="name">var <span class="ident">MS_TO_IANA_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.EWSTimeZone.from_datetime"><code class="name flex">
<span>def <span class="ident">from_datetime</span></span>(<span>tz)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert from a standard library <code>datetime.timezone</code> instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_datetime(cls, tz):
    &#34;&#34;&#34;Convert from a standard library `datetime.timezone` instance.&#34;&#34;&#34;
    return cls(tz.tzname(None))</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.from_dateutil"><code class="name flex">
<span>def <span class="ident">from_dateutil</span></span>(<span>tz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dateutil(cls, tz):
    # Objects returned by dateutil.tz.tzlocal() and dateutil.tz.gettz() are not supported. They
    # don&#39;t contain enough information to reliably match them with a CLDR time zone.
    if hasattr(tz, &#34;_filename&#34;):
        key = &#34;/&#34;.join(tz._filename.split(&#34;/&#34;)[-2:])
        return cls(key)
    return cls(tz.tzname(datetime.datetime.now()))</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.from_ms_id"><code class="name flex">
<span>def <span class="ident">from_ms_id</span></span>(<span>ms_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_ms_id(cls, ms_id):
    # Create a time zone instance from a Microsoft time zone ID. This is lossy because there is not a 1:1
    # translation from MS time zone ID to IANA time zone.
    try:
        return cls(cls.MS_TO_IANA_MAP[ms_id])
    except KeyError:
        if &#34;/&#34; in ms_id:
            # EWS sometimes returns an ID that has a region/location format, e.g. &#39;Europe/Copenhagen&#39;. Try the
            # string unaltered.
            return cls(ms_id)
        raise UnknownTimeZone(f&#34;Windows timezone ID {ms_id!r} is unknown by CLDR&#34;)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.from_pytz"><code class="name flex">
<span>def <span class="ident">from_pytz</span></span>(<span>tz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_pytz(cls, tz):
    return cls(tz.zone)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.from_timezone"><code class="name flex">
<span>def <span class="ident">from_timezone</span></span>(<span>tz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_timezone(cls, tz):
    # Support multiple tzinfo implementations. We could use isinstance(), but then we&#39;d have to have pytz
    # and dateutil as dependencies for this package.
    tz_module = tz.__class__.__module__.split(&#34;.&#34;)[0]
    try:
        return {
            cls.__module__.split(&#34;.&#34;)[0]: lambda z: z,
            &#34;backports&#34;: cls.from_zoneinfo,
            &#34;datetime&#34;: cls.from_datetime,
            &#34;dateutil&#34;: cls.from_dateutil,
            &#34;pytz&#34;: cls.from_pytz,
            &#34;zoneinfo&#34;: cls.from_zoneinfo,
            &#34;pytz_deprecation_shim&#34;: lambda z: cls.from_timezone(z.unwrap_shim()),
        }[tz_module](tz)
    except KeyError:
        raise TypeError(f&#34;Unsupported tzinfo type: {tz!r}&#34;)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.from_zoneinfo"><code class="name flex">
<span>def <span class="ident">from_zoneinfo</span></span>(<span>tz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_zoneinfo(cls, tz):
    return cls(tz.key)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.localzone"><code class="name flex">
<span>def <span class="ident">localzone</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def localzone(cls):
    try:
        tz = tzlocal.get_localzone()
    except zoneinfo.ZoneInfoNotFoundError:
        # Older versions of tzlocal will raise a pytz exception. Let&#39;s not depend on pytz just for that.
        raise UnknownTimeZone(&#34;Failed to guess local timezone&#34;)
    # Handle both old and new versions of tzlocal that may return pytz or zoneinfo objects, respectively
    return cls.from_timezone(tz)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.EWSTimeZone.fromutc"><code class="name flex">
<span>def <span class="ident">fromutc</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a datetime with local time in UTC, retrieve an adjusted datetime in local time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromutc(self, dt):
    t = super().fromutc(dt)
    if isinstance(t, EWSDateTime):
        return t
    return EWSDateTime.from_datetime(t)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.ExtendedProperty"><code class="flex name class">
<span>class <span class="ident">ExtendedProperty</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/extendedproperty">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/extendedproperty</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtendedProperty(EWSElement):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/extendedproperty&#34;&#34;&#34;

    ELEMENT_NAME = &#34;ExtendedProperty&#34;

    # Enum values: https://docs.microsoft.com/en-us/dotnet/api/exchangewebservices.distinguishedpropertysettype
    DISTINGUISHED_SETS = {
        &#34;Address&#34;,
        &#34;Appointment&#34;,
        &#34;CalendarAssistant&#34;,
        &#34;Common&#34;,
        &#34;InternetHeaders&#34;,
        &#34;Meeting&#34;,
        &#34;PublicStrings&#34;,
        &#34;Sharing&#34;,
        &#34;Task&#34;,
        &#34;UnifiedMessaging&#34;,
    }
    # Enum values: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/extendedfielduri
    # The following types cannot be used for setting or getting (see docs) and are thus not very useful here:
    # &#39;Error&#39;
    # &#39;Null&#39;
    # &#39;Object&#39;
    # &#39;ObjectArray&#39;
    PROPERTY_TYPES = {
        &#34;ApplicationTime&#34;,
        &#34;Binary&#34;,
        &#34;BinaryArray&#34;,
        &#34;Boolean&#34;,
        &#34;CLSID&#34;,
        &#34;CLSIDArray&#34;,
        &#34;Currency&#34;,
        &#34;CurrencyArray&#34;,
        &#34;Double&#34;,
        &#34;DoubleArray&#34;,
        &#34;Float&#34;,
        &#34;FloatArray&#34;,
        &#34;Integer&#34;,
        &#34;IntegerArray&#34;,
        &#34;Long&#34;,
        &#34;LongArray&#34;,
        &#34;Short&#34;,
        &#34;ShortArray&#34;,
        &#34;SystemTime&#34;,
        &#34;SystemTimeArray&#34;,
        &#34;String&#34;,
        &#34;StringArray&#34;,
    }

    # Translation table between common distinguished_property_set_id and property_set_id values. See
    # https://docs.microsoft.com/en-us/office/client-developer/outlook/mapi/commonly-used-property-sets
    # ID values must be lowercase.
    DISTINGUISHED_SET_NAME_TO_ID_MAP = {
        &#34;Address&#34;: &#34;00062004-0000-0000-c000-000000000046&#34;,
        &#34;AirSync&#34;: &#34;71035549-0739-4dcb-9163-00f0580dbbdf&#34;,
        &#34;Appointment&#34;: &#34;00062002-0000-0000-c000-000000000046&#34;,
        &#34;Common&#34;: &#34;00062008-0000-0000-c000-000000000046&#34;,
        &#34;InternetHeaders&#34;: &#34;00020386-0000-0000-c000-000000000046&#34;,
        &#34;Log&#34;: &#34;0006200a-0000-0000-c000-000000000046&#34;,
        &#34;Mapi&#34;: &#34;00020328-0000-0000-c000-000000000046&#34;,
        &#34;Meeting&#34;: &#34;6ed8da90-450b-101b-98da-00aa003f1305&#34;,
        &#34;Messaging&#34;: &#34;41f28f13-83f4-4114-a584-eedb5a6b0bff&#34;,
        &#34;Note&#34;: &#34;0006200e-0000-0000-c000-000000000046&#34;,
        &#34;PostRss&#34;: &#34;00062041-0000-0000-c000-000000000046&#34;,
        &#34;PublicStrings&#34;: &#34;00020329-0000-0000-c000-000000000046&#34;,
        &#34;Remote&#34;: &#34;00062014-0000-0000-c000-000000000046&#34;,
        &#34;Report&#34;: &#34;00062013-0000-0000-c000-000000000046&#34;,
        &#34;Sharing&#34;: &#34;00062040-0000-0000-c000-000000000046&#34;,
        &#34;Task&#34;: &#34;00062003-0000-0000-c000-000000000046&#34;,
        &#34;UnifiedMessaging&#34;: &#34;4442858e-a9e3-4e80-b900-317a210cc15b&#34;,
    }
    DISTINGUISHED_SET_ID_TO_NAME_MAP = {v: k for k, v in DISTINGUISHED_SET_NAME_TO_ID_MAP.items()}

    distinguished_property_set_id = None
    property_set_id = None
    property_tag = None  # hex integer (e.g. 0x8000) or string (&#39;0x8000&#39;)
    property_name = None
    property_id = None  # integer as hex-formatted int (e.g. 0x8000) or normal int (32768)
    property_type = &#34;&#34;

    __slots__ = (&#34;value&#34;,)

    def __init__(self, *args, **kwargs):
        if not kwargs:
            # Allow to set attributes without keyword
            kwargs = dict(zip(self._slots_keys, args))
        self.value = kwargs.pop(&#34;value&#34;)
        super().__init__(**kwargs)

    @classmethod
    def validate_cls(cls):
        # Validate values of class attributes and their interdependencies
        cls._validate_distinguished_property_set_id()
        cls._validate_property_set_id()
        cls._validate_property_tag()
        cls._validate_property_name()
        cls._validate_property_id()
        cls._validate_property_type()

    @classmethod
    def _validate_distinguished_property_set_id(cls):
        if cls.distinguished_property_set_id:
            if any([cls.property_set_id, cls.property_tag]):
                raise ValueError(
                    &#34;When &#39;distinguished_property_set_id&#39; is set, &#39;property_set_id&#39; and &#39;property_tag&#39; must be None&#34;
                )
            if not any([cls.property_id, cls.property_name]):
                raise ValueError(
                    &#34;When &#39;distinguished_property_set_id&#39; is set, &#39;property_id&#39; or &#39;property_name&#39; must also be set&#34;
                )
            if cls.distinguished_property_set_id not in cls.DISTINGUISHED_SETS:
                raise InvalidEnumValue(
                    &#34;distinguished_property_set_id&#34;, cls.distinguished_property_set_id, cls.DISTINGUISHED_SETS
                )

    @classmethod
    def _validate_property_set_id(cls):
        if cls.property_set_id:
            if any([cls.distinguished_property_set_id, cls.property_tag]):
                raise ValueError(
                    &#34;When &#39;property_set_id&#39; is set, &#39;distinguished_property_set_id&#39; and &#39;property_tag&#39; must be None&#34;
                )
            if not any([cls.property_id, cls.property_name]):
                raise ValueError(&#34;When &#39;property_set_id&#39; is set, &#39;property_id&#39; or &#39;property_name&#39; must also be set&#34;)

    @classmethod
    def _validate_property_tag(cls):
        if cls.property_tag:
            if any([cls.distinguished_property_set_id, cls.property_set_id, cls.property_name, cls.property_id]):
                raise ValueError(&#34;When &#39;property_tag&#39; is set, only &#39;property_type&#39; must be set&#34;)
            if 0x8000 &lt;= cls.property_tag_as_int() &lt;= 0xFFFE:
                raise ValueError(
                    f&#34;&#39;property_tag&#39; value {cls.property_tag_as_hex()!r} is reserved for custom properties&#34;
                )

    @classmethod
    def _validate_property_name(cls):
        if cls.property_name:
            if any([cls.property_id, cls.property_tag]):
                raise ValueError(&#34;When &#39;property_name&#39; is set, &#39;property_id&#39; and &#39;property_tag&#39; must be None&#34;)
            if not any([cls.distinguished_property_set_id, cls.property_set_id]):
                raise ValueError(
                    &#34;When &#39;property_name&#39; is set, &#39;distinguished_property_set_id&#39; or &#39;property_set_id&#39; must also be set&#34;
                )

    @classmethod
    def _validate_property_id(cls):
        if cls.property_id:
            if any([cls.property_name, cls.property_tag]):
                raise ValueError(&#34;When &#39;property_id&#39; is set, &#39;property_name&#39; and &#39;property_tag&#39; must be None&#34;)
            if not any([cls.distinguished_property_set_id, cls.property_set_id]):
                raise ValueError(
                    &#34;When &#39;property_id&#39; is set, &#39;distinguished_property_set_id&#39; or &#39;property_set_id&#39; must also be set&#34;
                )

    @classmethod
    def _validate_property_type(cls):
        if cls.property_type not in cls.PROPERTY_TYPES:
            raise InvalidEnumValue(&#34;property_type&#34;, cls.property_type, cls.PROPERTY_TYPES)

    def clean(self, version=None):
        self.validate_cls()
        python_type = self.python_type()
        if self.is_array_type():
            if not is_iterable(self.value):
                raise TypeError(f&#34;Field {self.__class__.__name__!r} value {self.value!r} must be of type {list}&#34;)
            for v in self.value:
                if not isinstance(v, python_type):
                    raise TypeError(f&#34;Field {self.__class__.__name__!r} list value {v!r} must be of type {python_type}&#34;)
        else:
            if not isinstance(self.value, python_type):
                raise TypeError(f&#34;Field {self.__class__.__name__!r} value {self.value!r} must be of type {python_type}&#34;)

    @classmethod
    def _normalize_obj(cls, obj):
        # Sometimes, EWS will helpfully translate a &#39;distinguished_property_set_id&#39; value to a &#39;property_set_id&#39; value
        # and vice versa. Align these values on an ExtendedFieldURI instance.
        try:
            obj.property_set_id = cls.DISTINGUISHED_SET_NAME_TO_ID_MAP[obj.distinguished_property_set_id]
        except KeyError:
            with suppress(KeyError):
                obj.distinguished_property_set_id = cls.DISTINGUISHED_SET_ID_TO_NAME_MAP[obj.property_set_id]
        return obj

    @classmethod
    def is_property_instance(cls, elem):
        &#34;&#34;&#34;Return whether an &#39;ExtendedProperty&#39; element matches the definition for this class. Extended property fields
        do not have a name, so we must match on the cls.property_* attributes to match a field in the request with a
        field in the response.
        &#34;&#34;&#34;
        # We can&#39;t use ExtendedFieldURI.from_xml(). It clears the XML element, but we may not want to consume it here.
        kwargs = {
            f.name: f.from_xml(elem=elem.find(ExtendedFieldURI.response_tag()), account=None)
            for f in ExtendedFieldURI.FIELDS
        }
        xml_obj = ExtendedFieldURI(**kwargs)
        cls_obj = cls.as_object()
        return cls._normalize_obj(cls_obj) == cls._normalize_obj(xml_obj)

    @classmethod
    def from_xml(cls, elem, account):
        # Gets value of this specific ExtendedProperty from a list of &#39;ExtendedProperty&#39; XML elements
        python_type = cls.python_type()
        if cls.is_array_type():
            values = elem.find(f&#34;{{{TNS}}}Values&#34;)
            return [
                xml_text_to_value(value=val, value_type=python_type) for val in get_xml_attrs(values, f&#34;{{{TNS}}}Value&#34;)
            ]
        extended_field_value = xml_text_to_value(value=get_xml_attr(elem, f&#34;{{{TNS}}}Value&#34;), value_type=python_type)
        if python_type == str and not extended_field_value:
            # For string types, we want to return the empty string instead of None if the element was
            # actually found, but there was no XML value. For other types, it would be more problematic
            # to make that distinction, e.g. return False for bool, 0 for int, etc.
            return &#34;&#34;
        return extended_field_value

    def to_xml(self, version):
        if self.is_array_type():
            values = create_element(&#34;t:Values&#34;)
            for v in self.value:
                add_xml_child(values, &#34;t:Value&#34;, v)
            return values
        return set_xml_value(create_element(&#34;t:Value&#34;), self.value, version=version)

    @classmethod
    def is_array_type(cls):
        return cls.property_type.endswith(&#34;Array&#34;)

    @classmethod
    def property_tag_as_int(cls):
        if isinstance(cls.property_tag, str):
            return int(cls.property_tag, base=16)
        return cls.property_tag

    @classmethod
    def property_tag_as_hex(cls):
        return hex(cls.property_tag) if isinstance(cls.property_tag, int) else cls.property_tag

    @classmethod
    def python_type(cls):
        # Return the best equivalent for a Python type for the property type of this class
        base_type = cls.property_type[:-5] if cls.is_array_type() else cls.property_type
        return {
            &#34;ApplicationTime&#34;: Decimal,
            &#34;Binary&#34;: bytes,
            &#34;Boolean&#34;: bool,
            &#34;CLSID&#34;: str,
            &#34;Currency&#34;: int,
            &#34;Double&#34;: Decimal,
            &#34;Float&#34;: Decimal,
            &#34;Integer&#34;: int,
            &#34;Long&#34;: int,
            &#34;Short&#34;: int,
            &#34;SystemTime&#34;: EWSDateTime,
            &#34;String&#34;: str,
        }[base_type]

    @classmethod
    def as_object(cls):
        # Return an object we can use to match with the incoming object from XML
        return ExtendedFieldURI(
            distinguished_property_set_id=cls.distinguished_property_set_id,
            property_set_id=cls.property_set_id.lower() if cls.property_set_id else None,
            property_tag=cls.property_tag_as_hex(),
            property_name=cls.property_name,
            property_id=value_to_xml_text(cls.property_id) if cls.property_id else None,
            property_type=cls.property_type,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.extended_properties.ExternId" href="extended_properties.html#exchangelib.extended_properties.ExternId">ExternId</a></li>
<li><a title="exchangelib.extended_properties.Flag" href="extended_properties.html#exchangelib.extended_properties.Flag">Flag</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ExtendedProperty.DISTINGUISHED_SETS"><code class="name">var <span class="ident">DISTINGUISHED_SETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.DISTINGUISHED_SET_ID_TO_NAME_MAP"><code class="name">var <span class="ident">DISTINGUISHED_SET_ID_TO_NAME_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.DISTINGUISHED_SET_NAME_TO_ID_MAP"><code class="name">var <span class="ident">DISTINGUISHED_SET_NAME_TO_ID_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.PROPERTY_TYPES"><code class="name">var <span class="ident">PROPERTY_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.distinguished_property_set_id"><code class="name">var <span class="ident">distinguished_property_set_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.property_id"><code class="name">var <span class="ident">property_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.property_name"><code class="name">var <span class="ident">property_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.property_set_id"><code class="name">var <span class="ident">property_set_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.property_tag"><code class="name">var <span class="ident">property_tag</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.property_type"><code class="name">var <span class="ident">property_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.ExtendedProperty.as_object"><code class="name flex">
<span>def <span class="ident">as_object</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def as_object(cls):
    # Return an object we can use to match with the incoming object from XML
    return ExtendedFieldURI(
        distinguished_property_set_id=cls.distinguished_property_set_id,
        property_set_id=cls.property_set_id.lower() if cls.property_set_id else None,
        property_tag=cls.property_tag_as_hex(),
        property_name=cls.property_name,
        property_id=value_to_xml_text(cls.property_id) if cls.property_id else None,
        property_type=cls.property_type,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    # Gets value of this specific ExtendedProperty from a list of &#39;ExtendedProperty&#39; XML elements
    python_type = cls.python_type()
    if cls.is_array_type():
        values = elem.find(f&#34;{{{TNS}}}Values&#34;)
        return [
            xml_text_to_value(value=val, value_type=python_type) for val in get_xml_attrs(values, f&#34;{{{TNS}}}Value&#34;)
        ]
    extended_field_value = xml_text_to_value(value=get_xml_attr(elem, f&#34;{{{TNS}}}Value&#34;), value_type=python_type)
    if python_type == str and not extended_field_value:
        # For string types, we want to return the empty string instead of None if the element was
        # actually found, but there was no XML value. For other types, it would be more problematic
        # to make that distinction, e.g. return False for bool, 0 for int, etc.
        return &#34;&#34;
    return extended_field_value</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.is_array_type"><code class="name flex">
<span>def <span class="ident">is_array_type</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_array_type(cls):
    return cls.property_type.endswith(&#34;Array&#34;)</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.is_property_instance"><code class="name flex">
<span>def <span class="ident">is_property_instance</span></span>(<span>elem)</span>
</code></dt>
<dd>
<div class="desc"><p>Return whether an 'ExtendedProperty' element matches the definition for this class. Extended property fields
do not have a name, so we must match on the cls.property_* attributes to match a field in the request with a
field in the response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_property_instance(cls, elem):
    &#34;&#34;&#34;Return whether an &#39;ExtendedProperty&#39; element matches the definition for this class. Extended property fields
    do not have a name, so we must match on the cls.property_* attributes to match a field in the request with a
    field in the response.
    &#34;&#34;&#34;
    # We can&#39;t use ExtendedFieldURI.from_xml(). It clears the XML element, but we may not want to consume it here.
    kwargs = {
        f.name: f.from_xml(elem=elem.find(ExtendedFieldURI.response_tag()), account=None)
        for f in ExtendedFieldURI.FIELDS
    }
    xml_obj = ExtendedFieldURI(**kwargs)
    cls_obj = cls.as_object()
    return cls._normalize_obj(cls_obj) == cls._normalize_obj(xml_obj)</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.property_tag_as_hex"><code class="name flex">
<span>def <span class="ident">property_tag_as_hex</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def property_tag_as_hex(cls):
    return hex(cls.property_tag) if isinstance(cls.property_tag, int) else cls.property_tag</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.property_tag_as_int"><code class="name flex">
<span>def <span class="ident">property_tag_as_int</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def property_tag_as_int(cls):
    if isinstance(cls.property_tag, str):
        return int(cls.property_tag, base=16)
    return cls.property_tag</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.python_type"><code class="name flex">
<span>def <span class="ident">python_type</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def python_type(cls):
    # Return the best equivalent for a Python type for the property type of this class
    base_type = cls.property_type[:-5] if cls.is_array_type() else cls.property_type
    return {
        &#34;ApplicationTime&#34;: Decimal,
        &#34;Binary&#34;: bytes,
        &#34;Boolean&#34;: bool,
        &#34;CLSID&#34;: str,
        &#34;Currency&#34;: int,
        &#34;Double&#34;: Decimal,
        &#34;Float&#34;: Decimal,
        &#34;Integer&#34;: int,
        &#34;Long&#34;: int,
        &#34;Short&#34;: int,
        &#34;SystemTime&#34;: EWSDateTime,
        &#34;String&#34;: str,
    }[base_type]</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.validate_cls"><code class="name flex">
<span>def <span class="ident">validate_cls</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def validate_cls(cls):
    # Validate values of class attributes and their interdependencies
    cls._validate_distinguished_property_set_id()
    cls._validate_property_set_id()
    cls._validate_property_tag()
    cls._validate_property_name()
    cls._validate_property_id()
    cls._validate_property_type()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.ExtendedProperty.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.ExtendedProperty.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    self.validate_cls()
    python_type = self.python_type()
    if self.is_array_type():
        if not is_iterable(self.value):
            raise TypeError(f&#34;Field {self.__class__.__name__!r} value {self.value!r} must be of type {list}&#34;)
        for v in self.value:
            if not isinstance(v, python_type):
                raise TypeError(f&#34;Field {self.__class__.__name__!r} list value {v!r} must be of type {python_type}&#34;)
    else:
        if not isinstance(self.value, python_type):
            raise TypeError(f&#34;Field {self.__class__.__name__!r} value {self.value!r} must be of type {python_type}&#34;)</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self, version):
    if self.is_array_type():
        values = create_element(&#34;t:Values&#34;)
        for v in self.value:
            add_xml_child(values, &#34;t:Value&#34;, v)
        return values
    return set_xml_value(create_element(&#34;t:Value&#34;), self.value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.EWSElement.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.FailFast"><code class="flex name class">
<span>class <span class="ident">FailFast</span></span>
</code></dt>
<dd>
<div class="desc"><p>Fail immediately on server errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FailFast(RetryPolicy):
    &#34;&#34;&#34;Fail immediately on server errors.&#34;&#34;&#34;

    @property
    def fail_fast(self):
        return True

    @property
    def back_off_until(self):
        return None

    def back_off(self, seconds):
        raise ValueError(&#34;Cannot back off with fail-fast policy&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.protocol.RetryPolicy" href="protocol.html#exchangelib.protocol.RetryPolicy">RetryPolicy</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.protocol.RetryPolicy" href="protocol.html#exchangelib.protocol.RetryPolicy">RetryPolicy</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.protocol.RetryPolicy.back_off" href="protocol.html#exchangelib.protocol.RetryPolicy.back_off">back_off</a></code></li>
<li><code><a title="exchangelib.protocol.RetryPolicy.back_off_until" href="protocol.html#exchangelib.protocol.RetryPolicy.back_off_until">back_off_until</a></code></li>
<li><code><a title="exchangelib.protocol.RetryPolicy.fail_fast" href="protocol.html#exchangelib.protocol.RetryPolicy.fail_fast">fail_fast</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.FaultTolerance"><code class="flex name class">
<span>class <span class="ident">FaultTolerance</span></span>
<span>(</span><span>max_wait=3600)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables fault-tolerant error handling. Tells internal methods to do an exponential back off when requests start
failing, and wait up to max_wait seconds before failing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FaultTolerance(RetryPolicy):
    &#34;&#34;&#34;Enables fault-tolerant error handling. Tells internal methods to do an exponential back off when requests start
    failing, and wait up to max_wait seconds before failing.
    &#34;&#34;&#34;

    # Back off 60 seconds if we didn&#39;t get an explicit suggested value
    DEFAULT_BACKOFF = 60

    def __init__(self, max_wait=3600):
        self.max_wait = max_wait
        self._back_off_until = None
        self._back_off_lock = Lock()

    def __getstate__(self):
        # Locks cannot be pickled
        state = self.__dict__.copy()
        del state[&#34;_back_off_lock&#34;]
        return state

    def __setstate__(self, state):
        # Restore the lock
        self.__dict__.update(state)
        self._back_off_lock = Lock()

    @property
    def fail_fast(self):
        return False

    @property
    def back_off_until(self):
        &#34;&#34;&#34;Return the back off value as a datetime. Reset the current back off value if it has expired.&#34;&#34;&#34;
        if self._back_off_until is None:
            return None
        with self._back_off_lock:
            if self._back_off_until is None:
                return None
            if self._back_off_until &lt; datetime.datetime.now():
                self._back_off_until = None  # The back off value has expired. Reset
                return None
            return self._back_off_until

    @back_off_until.setter
    def back_off_until(self, value):
        with self._back_off_lock:
            self._back_off_until = value

    def back_off(self, seconds):
        if seconds is None:
            seconds = self.DEFAULT_BACKOFF
        if seconds &gt; self.max_wait:
            # We lost patience. Session is cleaned up in outer loop
            raise RateLimitError(&#34;Max timeout reached&#34;, wait=seconds)
        value = datetime.datetime.now() + datetime.timedelta(seconds=seconds)
        with self._back_off_lock:
            self._back_off_until = value

    def raise_response_errors(self, response):
        try:
            return super().raise_response_errors(response)
        except (ErrorInternalServerTransientError, ErrorServerBusy) as e:
            # Pass on the retry header value
            retry_after = _get_retry_after(response)
            if retry_after:
                raise ErrorServerBusy(e.args[0], back_off=retry_after)
            raise</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.protocol.RetryPolicy" href="protocol.html#exchangelib.protocol.RetryPolicy">RetryPolicy</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.FaultTolerance.DEFAULT_BACKOFF"><code class="name">var <span class="ident">DEFAULT_BACKOFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.FaultTolerance.back_off_until"><code class="name">var <span class="ident">back_off_until</span></code></dt>
<dd>
<div class="desc"><p>Return the back off value as a datetime. Reset the current back off value if it has expired.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def back_off_until(self):
    &#34;&#34;&#34;Return the back off value as a datetime. Reset the current back off value if it has expired.&#34;&#34;&#34;
    if self._back_off_until is None:
        return None
    with self._back_off_lock:
        if self._back_off_until is None:
            return None
        if self._back_off_until &lt; datetime.datetime.now():
            self._back_off_until = None  # The back off value has expired. Reset
            return None
        return self._back_off_until</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.FaultTolerance.raise_response_errors"><code class="name flex">
<span>def <span class="ident">raise_response_errors</span></span>(<span>self, response)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raise_response_errors(self, response):
    try:
        return super().raise_response_errors(response)
    except (ErrorInternalServerTransientError, ErrorServerBusy) as e:
        # Pass on the retry header value
        retry_after = _get_retry_after(response)
        if retry_after:
            raise ErrorServerBusy(e.args[0], back_off=retry_after)
        raise</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.protocol.RetryPolicy" href="protocol.html#exchangelib.protocol.RetryPolicy">RetryPolicy</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.protocol.RetryPolicy.back_off" href="protocol.html#exchangelib.protocol.RetryPolicy.back_off">back_off</a></code></li>
<li><code><a title="exchangelib.protocol.RetryPolicy.fail_fast" href="protocol.html#exchangelib.protocol.RetryPolicy.fail_fast">fail_fast</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.FileAttachment"><code class="flex name class">
<span>class <span class="ident">FileAttachment</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/fileattachment">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/fileattachment</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileAttachment(Attachment):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/fileattachment&#34;&#34;&#34;

    ELEMENT_NAME = &#34;FileAttachment&#34;

    is_contact_photo = BooleanField(field_uri=&#34;IsContactPhoto&#34;)
    _content = Base64Field(field_uri=&#34;Content&#34;)

    __slots__ = (&#34;_fp&#34;,)

    def __init__(self, **kwargs):
        kwargs[&#34;_content&#34;] = kwargs.pop(&#34;content&#34;, None)
        super().__init__(**kwargs)
        self._fp = None

    @property
    def fp(self):
        # Return a file-like object for the content. This avoids creating multiple in-memory copies of the content.
        if self._fp is None:
            self._init_fp()
        return self._fp

    def _init_fp(self):
        # Create a file-like object for the attachment content. We try hard to reduce memory consumption, so we never
        # store the full attachment content in-memory.
        if not self.parent_item or not self.parent_item.account:
            raise ValueError(f&#34;{self.__class__.__name__} must have an account&#34;)
        self._fp = FileAttachmentIO(attachment=self)

    @property
    def content(self):
        &#34;&#34;&#34;Return the attachment content. Stores a local copy of the content in case you want to upload the attachment
        again later.
        &#34;&#34;&#34;
        if self.attachment_id is None:
            return self._content
        if self._content is not None:
            return self._content
        # We have an ID to the data but still haven&#39;t called GetAttachment to get the actual data. Do that now.
        with self.fp as fp:
            self._content = fp.read()
        return self._content

    @content.setter
    def content(self, value):
        &#34;&#34;&#34;Replace the attachment content.&#34;&#34;&#34;
        if not isinstance(value, bytes):
            raise InvalidTypeError(&#34;value&#34;, value, bytes)
        self._content = value

    @classmethod
    def from_xml(cls, elem, account):
        kwargs = {f.name: f.from_xml(elem=elem, account=account) for f in cls.FIELDS}
        kwargs[&#34;content&#34;] = kwargs.pop(&#34;_content&#34;)
        cls._clear(elem)
        return cls(**kwargs)

    def to_xml(self, version):
        self._content = self.content  # Make sure content is available, to avoid ErrorRequiredPropertyMissing
        return super().to_xml(version=version)

    def __getstate__(self):
        # The fp does not need to be pickled
        state = {k: getattr(self, k) for k in self._slots_keys}
        del state[&#34;_fp&#34;]
        return state

    def __setstate__(self, state):
        # Restore the fp
        for k in self._slots_keys:
            setattr(self, k, state.get(k))
        self._fp = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.attachments.Attachment" href="attachments.html#exchangelib.attachments.Attachment">Attachment</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.FileAttachment.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.FileAttachment.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.FileAttachment.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    kwargs = {f.name: f.from_xml(elem=elem, account=account) for f in cls.FIELDS}
    kwargs[&#34;content&#34;] = kwargs.pop(&#34;_content&#34;)
    cls._clear(elem)
    return cls(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.FileAttachment.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>Return the attachment content. Stores a local copy of the content in case you want to upload the attachment
again later.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content(self):
    &#34;&#34;&#34;Return the attachment content. Stores a local copy of the content in case you want to upload the attachment
    again later.
    &#34;&#34;&#34;
    if self.attachment_id is None:
        return self._content
    if self._content is not None:
        return self._content
    # We have an ID to the data but still haven&#39;t called GetAttachment to get the actual data. Do that now.
    with self.fp as fp:
        self._content = fp.read()
    return self._content</code></pre>
</details>
</dd>
<dt id="exchangelib.FileAttachment.fp"><code class="name">var <span class="ident">fp</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fp(self):
    # Return a file-like object for the content. This avoids creating multiple in-memory copies of the content.
    if self._fp is None:
        self._init_fp()
    return self._fp</code></pre>
</details>
</dd>
<dt id="exchangelib.FileAttachment.is_contact_photo"><code class="name">var <span class="ident">is_contact_photo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.FileAttachment.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self, version):
    self._content = self.content  # Make sure content is available, to avoid ErrorRequiredPropertyMissing
    return super().to_xml(version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.attachments.Attachment" href="attachments.html#exchangelib.attachments.Attachment">Attachment</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.attachments.Attachment.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.parent_item" href="attachments.html#exchangelib.attachments.Attachment.parent_item">parent_item</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Folder"><code class="flex name class">
<span>class <span class="ident">Folder</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/folder">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/folder</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Folder(BaseFolder):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/folder&#34;&#34;&#34;

    permission_set = PermissionSetField(field_uri=&#34;folder:PermissionSet&#34;, supported_from=EXCHANGE_2007_SP1)
    effective_rights = EffectiveRightsField(
        field_uri=&#34;folder:EffectiveRights&#34;, is_read_only=True, supported_from=EXCHANGE_2007_SP1
    )

    __slots__ = (&#34;_root&#34;,)

    def __init__(self, **kwargs):
        self._root = kwargs.pop(&#34;root&#34;, None)  # This is a pointer to the root of the folder hierarchy
        parent = kwargs.pop(&#34;parent&#34;, None)
        if parent:
            if self.root:
                if parent.root != self.root:
                    raise ValueError(&#34;&#39;parent.root&#39; must match &#39;root&#39;&#34;)
            else:
                self._root = parent.root
            if &#34;parent_folder_id&#34; in kwargs and parent.id != kwargs[&#34;parent_folder_id&#34;]:
                raise ValueError(&#34;&#39;parent_folder_id&#39; must match &#39;parent&#39; ID&#34;)
            kwargs[&#34;parent_folder_id&#34;] = ParentFolderId(id=parent.id, changekey=parent.changekey)
        super().__init__(**kwargs)

    @property
    def account(self):
        if self.root is None:
            return None
        return self.root.account

    @property
    def root(self):
        return self._root

    @classmethod
    def register(cls, *args, **kwargs):
        if cls is not Folder:
            raise TypeError(&#34;For folders, custom fields must be registered on the Folder class&#34;)
        return super().register(*args, **kwargs)

    @classmethod
    def deregister(cls, *args, **kwargs):
        if cls is not Folder:
            raise TypeError(&#34;For folders, custom fields must be registered on the Folder class&#34;)
        return super().deregister(*args, **kwargs)

    @property
    def parent(self):
        if not self.parent_folder_id:
            return None
        if self.parent_folder_id.id == self.id:
            # Some folders have a parent that references itself. Avoid circular references here
            return None
        return self.root.get_folder(self.parent_folder_id)

    @parent.setter
    def parent(self, value):
        if value is None:
            self.parent_folder_id = None
        else:
            if not isinstance(value, BaseFolder):
                raise InvalidTypeError(&#34;value&#34;, value, BaseFolder)
            self._root = value.root
            self.parent_folder_id = ParentFolderId(id=value.id, changekey=value.changekey)

    def clean(self, version=None):
        from .roots import RootOfHierarchy

        super().clean(version=version)
        if self.root and not isinstance(self.root, RootOfHierarchy):
            raise InvalidTypeError(&#34;root&#34;, self.root, RootOfHierarchy)

    @classmethod
    def get_distinguished(cls, root):
        &#34;&#34;&#34;Get the distinguished folder for this folder class.

        :param root:
        :return:
        &#34;&#34;&#34;
        return cls._get_distinguished(
            folder=cls(
                _distinguished_id=DistinguishedFolderId(
                    id=cls.DISTINGUISHED_FOLDER_ID,
                    mailbox=Mailbox(email_address=root.account.primary_smtp_address),
                ),
                root=root,
            )
        )

    @classmethod
    def from_xml_with_root(cls, elem, root):
        folder = cls.from_xml(elem=elem, account=root.account)
        folder_cls = cls
        if cls == Folder:
            # We were called on the generic Folder class. Try to find a more specific class to return objects as.
            #
            # The &#34;FolderClass&#34; element value is the only indication we have in the FindFolder response of which
            # folder class we should create the folder with. And many folders share the same &#39;FolderClass&#39; value, e.g.
            # Inbox and DeletedItems. We want to distinguish between these because otherwise we can&#39;t locate the right
            # folders types for e.g. Account.inbox and Account.trash.
            #
            # We should be able to just use the name, but apparently default folder names can be renamed to a set of
            # localized names using a PowerShell command:
            # https://docs.microsoft.com/en-us/powershell/module/exchange/client-access/Set-MailboxRegionalConfiguration
            #
            # Instead, search for a folder class using the localized name. If none are found, fall back to getting the
            # folder class by the &#34;FolderClass&#34; value.
            #
            # The returned XML may contain neither folder class nor name. In that case, we default to the generic
            # Folder class.
            if folder.name:
                with suppress(KeyError):
                    # TODO: fld_class.LOCALIZED_NAMES is most definitely neither complete nor authoritative
                    folder_cls = root.folder_cls_from_folder_name(
                        folder_name=folder.name,
                        folder_class=folder.folder_class,
                        locale=root.account.locale,
                    )
                    log.debug(&#34;Folder class %s matches localized folder name %s&#34;, folder_cls, folder.name)
            if folder.folder_class and folder_cls == Folder:
                with suppress(KeyError):
                    folder_cls = cls.folder_cls_from_container_class(container_class=folder.folder_class)
                    log.debug(
                        &#34;Folder class %s matches container class %s (%s)&#34;, folder_cls, folder.folder_class, folder.name
                    )
            if folder_cls == Folder:
                log.debug(&#34;Fallback to class Folder (folder_class %s, name %s)&#34;, folder.folder_class, folder.name)
        # Some servers return folders in a FindFolder result that have a DistinguishedFolderId element that the same
        # server cannot handle in a GetFolder request. Only set the DistinguishedFolderId field if we recognize the ID.
        if folder._distinguished_id and not folder_cls.DISTINGUISHED_FOLDER_ID:
            folder._distinguished_id = None
        return folder_cls(root=root, **{f.name: getattr(folder, f.name) for f in folder.FIELDS})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.base.BaseFolder" href="folders/base.html#exchangelib.folders.base.BaseFolder">BaseFolder</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
<li><a title="exchangelib.queryset.SearchableMixIn" href="queryset.html#exchangelib.queryset.SearchableMixIn">SearchableMixIn</a></li>
<li><a title="exchangelib.version.SupportedVersionClassMixIn" href="version.html#exchangelib.version.SupportedVersionClassMixIn">SupportedVersionClassMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.known_folders.Birthdays" href="folders/known_folders.html#exchangelib.folders.known_folders.Birthdays">Birthdays</a></li>
<li><a title="exchangelib.folders.known_folders.CrawlerData" href="folders/known_folders.html#exchangelib.folders.known_folders.CrawlerData">CrawlerData</a></li>
<li><a title="exchangelib.folders.known_folders.EventCheckPoints" href="folders/known_folders.html#exchangelib.folders.known_folders.EventCheckPoints">EventCheckPoints</a></li>
<li><a title="exchangelib.folders.known_folders.FolderMemberships" href="folders/known_folders.html#exchangelib.folders.known_folders.FolderMemberships">FolderMemberships</a></li>
<li><a title="exchangelib.folders.known_folders.FreeBusyCache" href="folders/known_folders.html#exchangelib.folders.known_folders.FreeBusyCache">FreeBusyCache</a></li>
<li><a title="exchangelib.folders.known_folders.NonDeletableFolder" href="folders/known_folders.html#exchangelib.folders.known_folders.NonDeletableFolder">NonDeletableFolder</a></li>
<li><a title="exchangelib.folders.known_folders.RecoveryPoints" href="folders/known_folders.html#exchangelib.folders.known_folders.RecoveryPoints">RecoveryPoints</a></li>
<li><a title="exchangelib.folders.known_folders.SkypeTeamsMessages" href="folders/known_folders.html#exchangelib.folders.known_folders.SkypeTeamsMessages">SkypeTeamsMessages</a></li>
<li><a title="exchangelib.folders.known_folders.SwssItems" href="folders/known_folders.html#exchangelib.folders.known_folders.SwssItems">SwssItems</a></li>
<li><a title="exchangelib.folders.known_folders.WellknownFolder" href="folders/known_folders.html#exchangelib.folders.known_folders.WellknownFolder">WellknownFolder</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Folder.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.Folder.from_xml_with_root"><code class="name flex">
<span>def <span class="ident">from_xml_with_root</span></span>(<span>elem, root)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml_with_root(cls, elem, root):
    folder = cls.from_xml(elem=elem, account=root.account)
    folder_cls = cls
    if cls == Folder:
        # We were called on the generic Folder class. Try to find a more specific class to return objects as.
        #
        # The &#34;FolderClass&#34; element value is the only indication we have in the FindFolder response of which
        # folder class we should create the folder with. And many folders share the same &#39;FolderClass&#39; value, e.g.
        # Inbox and DeletedItems. We want to distinguish between these because otherwise we can&#39;t locate the right
        # folders types for e.g. Account.inbox and Account.trash.
        #
        # We should be able to just use the name, but apparently default folder names can be renamed to a set of
        # localized names using a PowerShell command:
        # https://docs.microsoft.com/en-us/powershell/module/exchange/client-access/Set-MailboxRegionalConfiguration
        #
        # Instead, search for a folder class using the localized name. If none are found, fall back to getting the
        # folder class by the &#34;FolderClass&#34; value.
        #
        # The returned XML may contain neither folder class nor name. In that case, we default to the generic
        # Folder class.
        if folder.name:
            with suppress(KeyError):
                # TODO: fld_class.LOCALIZED_NAMES is most definitely neither complete nor authoritative
                folder_cls = root.folder_cls_from_folder_name(
                    folder_name=folder.name,
                    folder_class=folder.folder_class,
                    locale=root.account.locale,
                )
                log.debug(&#34;Folder class %s matches localized folder name %s&#34;, folder_cls, folder.name)
        if folder.folder_class and folder_cls == Folder:
            with suppress(KeyError):
                folder_cls = cls.folder_cls_from_container_class(container_class=folder.folder_class)
                log.debug(
                    &#34;Folder class %s matches container class %s (%s)&#34;, folder_cls, folder.folder_class, folder.name
                )
        if folder_cls == Folder:
            log.debug(&#34;Fallback to class Folder (folder_class %s, name %s)&#34;, folder.folder_class, folder.name)
    # Some servers return folders in a FindFolder result that have a DistinguishedFolderId element that the same
    # server cannot handle in a GetFolder request. Only set the DistinguishedFolderId field if we recognize the ID.
    if folder._distinguished_id and not folder_cls.DISTINGUISHED_FOLDER_ID:
        folder._distinguished_id = None
    return folder_cls(root=root, **{f.name: getattr(folder, f.name) for f in folder.FIELDS})</code></pre>
</details>
</dd>
<dt id="exchangelib.Folder.get_distinguished"><code class="name flex">
<span>def <span class="ident">get_distinguished</span></span>(<span>root)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the distinguished folder for this folder class.</p>
<p>:param root:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_distinguished(cls, root):
    &#34;&#34;&#34;Get the distinguished folder for this folder class.

    :param root:
    :return:
    &#34;&#34;&#34;
    return cls._get_distinguished(
        folder=cls(
            _distinguished_id=DistinguishedFolderId(
                id=cls.DISTINGUISHED_FOLDER_ID,
                mailbox=Mailbox(email_address=root.account.primary_smtp_address),
            ),
            root=root,
        )
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Folder.effective_rights"><code class="name">var <span class="ident">effective_rights</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Folder.permission_set"><code class="name">var <span class="ident">permission_set</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Folder.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    from .roots import RootOfHierarchy

    super().clean(version=version)
    if self.root and not isinstance(self.root, RootOfHierarchy):
        raise InvalidTypeError(&#34;root&#34;, self.root, RootOfHierarchy)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.folders.base.BaseFolder" href="folders/base.html#exchangelib.folders.base.BaseFolder">BaseFolder</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.folders.base.BaseFolder.ID_ELEMENT_CLS" href="folders/base.html#exchangelib.folders.base.BaseFolder.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.account" href="folders/base.html#exchangelib.folders.base.BaseFolder.account">account</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.all" href="queryset.html#exchangelib.queryset.SearchableMixIn.all">all</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.exclude" href="queryset.html#exchangelib.queryset.SearchableMixIn.exclude">exclude</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.filter" href="queryset.html#exchangelib.queryset.SearchableMixIn.filter">filter</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.folder_cls_from_container_class" href="folders/base.html#exchangelib.folders.base.BaseFolder.folder_cls_from_container_class">folder_cls_from_container_class</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.folder_sync_state" href="folders/base.html#exchangelib.folders.base.BaseFolder.folder_sync_state">folder_sync_state</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.get" href="queryset.html#exchangelib.queryset.SearchableMixIn.get">get</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.get_events" href="folders/base.html#exchangelib.folders.base.BaseFolder.get_events">get_events</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.get_streaming_events" href="folders/base.html#exchangelib.folders.base.BaseFolder.get_streaming_events">get_streaming_events</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.item_sync_state" href="folders/base.html#exchangelib.folders.base.BaseFolder.item_sync_state">item_sync_state</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.none" href="queryset.html#exchangelib.queryset.SearchableMixIn.none">none</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.parent" href="folders/base.html#exchangelib.folders.base.BaseFolder.parent">parent</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.people" href="queryset.html#exchangelib.queryset.SearchableMixIn.people">people</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.root" href="folders/base.html#exchangelib.folders.base.BaseFolder.root">root</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_pull" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_pull">subscribe_to_pull</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_push" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_push">subscribe_to_push</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_streaming" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_streaming">subscribe_to_streaming</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.sync_hierarchy" href="folders/base.html#exchangelib.folders.base.BaseFolder.sync_hierarchy">sync_hierarchy</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.sync_items" href="folders/base.html#exchangelib.folders.base.BaseFolder.sync_items">sync_items</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.test_access" href="folders/base.html#exchangelib.folders.base.BaseFolder.test_access">test_access</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.tree" href="folders/base.html#exchangelib.folders.base.BaseFolder.tree">tree</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.unsubscribe" href="folders/base.html#exchangelib.folders.base.BaseFolder.unsubscribe">unsubscribe</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.FolderCollection"><code class="flex name class">
<span>class <span class="ident">FolderCollection</span></span>
<span>(</span><span>account, folders)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that implements an API for searching folders.</p>
<p>Implement a search API on a collection of folders.</p>
<p>:param account: An Account object
:param folders: An iterable of folders, e.g. Folder.walk(), Folder.glob(), or [a.calendar, a.inbox]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FolderCollection(SearchableMixIn):
    &#34;&#34;&#34;A class that implements an API for searching folders.&#34;&#34;&#34;

    # These fields are required in a FindFolder or GetFolder call to properly identify folder types
    REQUIRED_FOLDER_FIELDS = (&#34;name&#34;, &#34;folder_class&#34;)

    def __init__(self, account, folders):
        &#34;&#34;&#34;Implement a search API on a collection of folders.

        :param account: An Account object
        :param folders: An iterable of folders, e.g. Folder.walk(), Folder.glob(), or [a.calendar, a.inbox]
        &#34;&#34;&#34;
        self.account = account
        self._folders = folders

    @threaded_cached_property
    def folders(self):
        # Resolve the list of folders, in case it&#39;s a generator
        return tuple(self._folders)

    def __len__(self):
        return len(self.folders)

    def __iter__(self):
        yield from self.folders

    def get(self, *args, **kwargs):
        return QuerySet(self).get(*args, **kwargs)

    def all(self):
        return QuerySet(self).all()

    def none(self):
        return QuerySet(self).none()

    def filter(self, *args, **kwargs):
        &#34;&#34;&#34;Find items in the folder(s).

        Non-keyword args may be a list of Q instances.

        Optional extra keyword arguments follow a Django-like QuerySet filter syntax (see
           https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups).

        We don&#39;t support &#39;__year&#39; and other date-related lookups. We also don&#39;t support &#39;__endswith&#39; or &#39;__iendswith&#39;.

        We support the additional &#39;__not&#39; lookup in place of Django&#39;s exclude() for simple cases. For more complicated
        cases you need to create a Q object and use ~Q().

        Examples:

            my_account.inbox.filter(datetime_received__gt=EWSDateTime(2016, 1, 1))
            my_account.calendar.filter(start__range=(EWSDateTime(2016, 1, 1), EWSDateTime(2017, 1, 1)))
            my_account.tasks.filter(subject=&#39;Hi mom&#39;)
            my_account.tasks.filter(subject__not=&#39;Hi mom&#39;)
            my_account.tasks.filter(subject__contains=&#39;Foo&#39;)
            my_account.tasks.filter(subject__icontains=&#39;foo&#39;)

        &#39;endswith&#39; and &#39;iendswith&#39; could be emulated by searching with &#39;contains&#39; or &#39;icontains&#39; and then
        post-processing items. Fetch the field in question with additional_fields and remove items where the search
        string is not a postfix.
        &#34;&#34;&#34;
        return QuerySet(self).filter(*args, **kwargs)

    def exclude(self, *args, **kwargs):
        return QuerySet(self).exclude(*args, **kwargs)

    def people(self):
        return QuerySet(self).people()

    def view(self, start, end, max_items=None):
        &#34;&#34;&#34;Implement the CalendarView option to FindItem. The difference between &#39;filter&#39; and &#39;view&#39; is that &#39;filter&#39;
        only returns the master CalendarItem for recurring items, while &#39;view&#39; unfolds recurring items and returns all
        CalendarItem occurrences as one would normally expect when presenting a calendar.

        Supports the same semantics as filter, except for &#39;start&#39; and &#39;end&#39; keyword attributes which are both required
        and behave differently than filter. Here, they denote the start and end of the timespan of the view. All items
        the overlap the timespan are returned (items that end exactly on &#39;start&#39; are also returned, for some reason).

        EWS does not allow combining CalendarView with search restrictions (filter and exclude).

        &#39;max_items&#39; defines the maximum number of items returned in this view. Optional.

        :param start:
        :param end:
        :param max_items:  (Default value = None)
        :return:
        &#34;&#34;&#34;
        qs = QuerySet(self)
        qs.calendar_view = CalendarView(start=start, end=end, max_items=max_items)
        return qs

    def allowed_item_fields(self):
        # Return non-ID fields of all item classes allowed in this folder type
        fields = set()
        for item_model in self.supported_item_models:
            fields.update(set(item_model.supported_fields(version=self.account.version)))
        return fields

    @property
    def supported_item_models(self):
        return tuple(item_model for folder in self.folders for item_model in folder.supported_item_models)

    def validate_item_field(self, field, version):
        # Takes a fieldname, Field or FieldPath object pointing to an item field, and checks that it is valid
        # for the item types supported by this folder collection.
        for item_model in self.supported_item_models:
            try:
                item_model.validate_field(field=field, version=version)
                break
            except InvalidField:
                continue
        else:
            raise InvalidField(f&#34;{field!r} is not a valid field on {self.supported_item_models}&#34;)

    def _rinse_args(self, q, depth, additional_fields, field_validator):
        if depth is None:
            depth = self._get_default_item_traversal_depth()
        if additional_fields:
            for f in additional_fields:
                field_validator(field=f, version=self.account.version)
                if f.field.is_complex:
                    raise ValueError(f&#34;Field {f.field.name!r} not supported for this service&#34;)

        # Build up any restrictions
        if q.is_empty():
            restriction = None
            query_string = None
        elif q.query_string:
            restriction = None
            query_string = Restriction(q, folders=self.folders, applies_to=Restriction.ITEMS)
        else:
            restriction = Restriction(q, folders=self.folders, applies_to=Restriction.ITEMS)
            query_string = None
        return depth, restriction, query_string

    def find_items(
        self,
        q,
        shape=ID_ONLY,
        depth=None,
        additional_fields=None,
        order_fields=None,
        calendar_view=None,
        page_size=None,
        max_items=None,
        offset=0,
    ):
        &#34;&#34;&#34;Private method to call the FindItem service.

        :param q: a Q instance containing any restrictions
        :param shape: controls whether to return (id, changekey) tuples or Item objects. If additional_fields is
          non-null, we always return Item objects. (Default value = ID_ONLY)
        :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
        :param additional_fields: the extra properties we want on the return objects. Default is no properties. Be aware
          that complex fields can only be fetched with fetch() (i.e. the GetItem service).
        :param order_fields: the SortOrder fields, if any (Default value = None)
        :param calendar_view: a CalendarView instance, if any (Default value = None)
        :param page_size: the requested number of items per page (Default value = None)
        :param max_items: the max number of items to return (Default value = None)
        :param offset: the offset relative to the first item in the item collection (Default value = 0)

        :return: a generator for the returned item IDs or items
        &#34;&#34;&#34;
        from ..services import FindItem

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return
        if q.is_never():
            log.debug(&#34;Query will never return results&#34;)
            return
        depth, restriction, query_string = self._rinse_args(
            q=q, depth=depth, additional_fields=additional_fields, field_validator=self.validate_item_field
        )
        if calendar_view is not None and not isinstance(calendar_view, CalendarView):
            raise InvalidTypeError(&#34;calendar_view&#34;, calendar_view, CalendarView)

        log.debug(
            &#34;Finding %s items in folders %s (shape: %s, depth: %s, additional_fields: %s, restriction: %s)&#34;,
            self.account,
            self.folders,
            shape,
            depth,
            additional_fields,
            restriction.q if restriction else None,
        )
        yield from FindItem(account=self.account, page_size=page_size).call(
            folders=self.folders,
            additional_fields=additional_fields,
            restriction=restriction,
            order_fields=order_fields,
            shape=shape,
            query_string=query_string,
            depth=depth,
            calendar_view=calendar_view,
            max_items=calendar_view.max_items if calendar_view else max_items,
            offset=offset,
        )

    def _get_single_folder(self):
        if len(self.folders) &gt; 1:
            raise ValueError(&#34;Syncing folder hierarchy can only be done on a single folder&#34;)
        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        return self.folders[0]

    def find_people(
        self,
        q,
        shape=ID_ONLY,
        depth=None,
        additional_fields=None,
        order_fields=None,
        page_size=None,
        max_items=None,
        offset=0,
    ):
        &#34;&#34;&#34;Private method to call the FindPeople service.

        :param q: a Q instance containing any restrictions
        :param shape: controls whether to return (id, changekey) tuples or Persona objects. If additional_fields is
          non-null, we always return Persona objects. (Default value = ID_ONLY)
        :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
        :param additional_fields: the extra properties we want on the return objects. Default is no properties.
        :param order_fields: the SortOrder fields, if any (Default value = None)
        :param page_size: the requested number of items per page (Default value = None)
        :param max_items: the max number of items to return (Default value = None)
        :param offset: the offset relative to the first item in the item collection (Default value = 0)

        :return: a generator for the returned personas
        &#34;&#34;&#34;
        from ..services import FindPeople

        folder = self._get_single_folder()
        if q.is_never():
            log.debug(&#34;Query will never return results&#34;)
            return
        depth, restriction, query_string = self._rinse_args(
            q=q, depth=depth, additional_fields=additional_fields, field_validator=Persona.validate_field
        )

        yield from FindPeople(account=self.account, page_size=page_size).call(
            folder=folder,
            additional_fields=additional_fields,
            restriction=restriction,
            order_fields=order_fields,
            shape=shape,
            query_string=query_string,
            depth=depth,
            max_items=max_items,
            offset=offset,
        )

    def get_folder_fields(self, target_cls, is_complex=None):
        return {
            FieldPath(field=f)
            for f in target_cls.supported_fields(version=self.account.version)
            if is_complex is None or f.is_complex is is_complex
        }

    def _get_target_cls(self):
        # We may have root folders that don&#39;t support the same set of fields as normal folders. If there is a mix of
        # both folder types in self.folders, raise an error, so we don&#39;t risk losing some fields in the query.
        from .base import Folder
        from .roots import RootOfHierarchy

        has_roots = False
        has_non_roots = False
        for f in self.folders:
            if isinstance(f, RootOfHierarchy):
                if has_non_roots:
                    raise ValueError(f&#34;Cannot call GetFolder on a mix of folder types: {self.folders}&#34;)
                has_roots = True
            else:
                if has_roots:
                    raise ValueError(f&#34;Cannot call GetFolder on a mix of folder types: {self.folders}&#34;)
                has_non_roots = True
        return RootOfHierarchy if has_roots else Folder

    def _get_default_traversal_depth(self, traversal_attr):
        unique_depths = {getattr(f, traversal_attr) for f in self.folders}
        if len(unique_depths) == 1:
            return unique_depths.pop()
        raise ValueError(
            f&#34;Folders in this collection do not have a common {traversal_attr} value. You need to define an explicit &#34;
            f&#34;traversal depth with QuerySet.depth() (values: {unique_depths})&#34;
        )

    def _get_default_item_traversal_depth(self):
        # When searching folders, some folders require &#39;Shallow&#39; and others &#39;Associated&#39; traversal depth.
        return self._get_default_traversal_depth(&#34;DEFAULT_ITEM_TRAVERSAL_DEPTH&#34;)

    def _get_default_folder_traversal_depth(self):
        # When searching folders, some folders require &#39;Shallow&#39; and others &#39;Deep&#39; traversal depth.
        return self._get_default_traversal_depth(&#34;DEFAULT_FOLDER_TRAVERSAL_DEPTH&#34;)

    def resolve(self):
        # Looks up the folders or folder IDs in the collection and returns full Folder instances with all fields set.
        from .base import BaseFolder

        resolveable_folders = []
        for f in self.folders:
            if isinstance(f, BaseFolder) and not f.get_folder_allowed:
                log.debug(&#34;GetFolder not allowed on folder %s. Non-complex fields must be fetched with FindFolder&#34;, f)
                yield f
            else:
                resolveable_folders.append(f)
        # Fetch all properties for the remaining folders of folder IDs
        additional_fields = self.get_folder_fields(target_cls=self._get_target_cls())
        yield from self.__class__(account=self.account, folders=resolveable_folders).get_folders(
            additional_fields=additional_fields
        )

    @require_account
    def find_folders(
        self, q=None, shape=ID_ONLY, depth=None, additional_fields=None, page_size=None, max_items=None, offset=0
    ):
        from ..services import FindFolder

        # &#39;depth&#39; controls whether to return direct children or recurse into sub-folders
        from .base import BaseFolder, Folder

        if q is None:
            q = Q()
        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return
        if q.is_never():
            log.debug(&#34;Query will never return results&#34;)
            return
        if q.is_empty():
            restriction = None
        else:
            restriction = Restriction(q, folders=self.folders, applies_to=Restriction.FOLDERS)
        if depth is None:
            depth = self._get_default_folder_traversal_depth()
        if additional_fields is None:
            # Default to all non-complex properties. Sub-folders will always be of class Folder
            additional_fields = self.get_folder_fields(target_cls=Folder, is_complex=False)
        else:
            for f in additional_fields:
                if f.field.is_complex:
                    raise ValueError(f&#34;find_folders() does not support field {f.field.name!r}. Use get_folders().&#34;)

        # Add required fields
        additional_fields.update(
            (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        yield from FindFolder(account=self.account, page_size=page_size).call(
            folders=self.folders,
            additional_fields=additional_fields,
            restriction=restriction,
            shape=shape,
            depth=depth,
            max_items=max_items,
            offset=offset,
        )

    def get_folders(self, additional_fields=None):
        from ..services import GetFolder

        # Expand folders with their full set of properties
        from .base import BaseFolder

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return
        if additional_fields is None:
            # Default to all complex properties
            additional_fields = self.get_folder_fields(target_cls=self._get_target_cls(), is_complex=True)

        # Add required fields
        additional_fields.update(
            (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        yield from GetFolder(account=self.account).call(
            folders=self.folders,
            additional_fields=additional_fields,
            shape=ID_ONLY,
        )

    def subscribe_to_pull(self, event_types=None, watermark=None, timeout=60):
        from ..services import SubscribeToPull

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        if event_types is None:
            event_types = SubscribeToPull.EVENT_TYPES
        return SubscribeToPull(account=self.account).get(
            folders=self.folders,
            event_types=event_types,
            watermark=watermark,
            timeout=timeout,
        )

    def subscribe_to_push(self, callback_url, event_types=None, watermark=None, status_frequency=1):
        from ..services import SubscribeToPush

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        if event_types is None:
            event_types = SubscribeToPush.EVENT_TYPES
        return SubscribeToPush(account=self.account).get(
            folders=self.folders,
            event_types=event_types,
            watermark=watermark,
            status_frequency=status_frequency,
            url=callback_url,
        )

    def subscribe_to_streaming(self, event_types=None):
        from ..services import SubscribeToStreaming

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        if event_types is None:
            event_types = SubscribeToStreaming.EVENT_TYPES
        return SubscribeToStreaming(account=self.account).get(folders=self.folders, event_types=event_types)

    def pull_subscription(self, **kwargs):
        return PullSubscription(target=self, **kwargs)

    def push_subscription(self, **kwargs):
        return PushSubscription(target=self, **kwargs)

    def streaming_subscription(self, **kwargs):
        return StreamingSubscription(target=self, **kwargs)

    def unsubscribe(self, subscription_id):
        &#34;&#34;&#34;Unsubscribe. Only applies to pull and streaming notifications.

        :param subscription_id: A subscription ID as acquired by .subscribe_to_[pull|streaming]()
        :return: True

        This method doesn&#39;t need the current collection instance, but it makes sense to keep the method along the other
        sync methods.
        &#34;&#34;&#34;
        from ..services import Unsubscribe

        return Unsubscribe(account=self.account).get(subscription_id=subscription_id)

    def sync_items(self, sync_state=None, only_fields=None, ignore=None, max_changes_returned=None, sync_scope=None):
        from ..services import SyncFolderItems

        folder = self._get_single_folder()
        if only_fields is None:
            # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
            additional_fields = {FieldPath(field=f) for f in folder.allowed_item_fields(version=self.account.version)}
        else:
            for field in only_fields:
                folder.validate_item_field(field=field, version=self.account.version)
            # Remove ItemId and ChangeKey. We get them unconditionally
            additional_fields = {f for f in folder.normalize_fields(fields=only_fields) if not f.field.is_attribute}

        svc = SyncFolderItems(account=self.account)
        while True:
            yield from svc.call(
                folder=folder,
                shape=ID_ONLY,
                additional_fields=additional_fields,
                sync_state=sync_state,
                ignore=ignore,
                max_changes_returned=max_changes_returned,
                sync_scope=sync_scope,
            )
            if svc.sync_state == sync_state:
                # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
                break
            sync_state = svc.sync_state  # Set the new sync state in the next call
            if svc.includes_last_item_in_range:  # Try again if there are more items
                break
        raise SyncCompleted(sync_state=svc.sync_state)

    def sync_hierarchy(self, sync_state=None, only_fields=None):
        from ..services import SyncFolderHierarchy

        folder = self._get_single_folder()
        if only_fields is None:
            # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
            additional_fields = {FieldPath(field=f) for f in folder.supported_fields(version=self.account.version)}
        else:
            additional_fields = set()
            for field_name in only_fields:
                folder.validate_field(field=field_name, version=self.account.version)
                f = folder.get_field_by_fieldname(fieldname=field_name)
                if not f.is_attribute:
                    # Remove ItemId and ChangeKey. We get them unconditionally
                    additional_fields.add(FieldPath(field=f))

        # Add required fields
        additional_fields.update(
            (FieldPath(field=folder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        svc = SyncFolderHierarchy(account=self.account)
        while True:
            yield from svc.call(
                folder=folder,
                shape=ID_ONLY,
                additional_fields=additional_fields,
                sync_state=sync_state,
            )
            if svc.sync_state == sync_state:
                # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
                break
            sync_state = svc.sync_state  # Set the new sync state in the next call
            if svc.includes_last_item_in_range:  # Try again if there are more items
                break
        raise SyncCompleted(sync_state=svc.sync_state)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.queryset.SearchableMixIn" href="queryset.html#exchangelib.queryset.SearchableMixIn">SearchableMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.FolderCollection.REQUIRED_FOLDER_FIELDS"><code class="name">var <span class="ident">REQUIRED_FOLDER_FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.FolderCollection.folders"><code class="name">var <span class="ident">folders</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.supported_item_models"><code class="name">var <span class="ident">supported_item_models</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def supported_item_models(self):
    return tuple(item_model for folder in self.folders for item_model in folder.supported_item_models)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.FolderCollection.allowed_item_fields"><code class="name flex">
<span>def <span class="ident">allowed_item_fields</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allowed_item_fields(self):
    # Return non-ID fields of all item classes allowed in this folder type
    fields = set()
    for item_model in self.supported_item_models:
        fields.update(set(item_model.supported_fields(version=self.account.version)))
    return fields</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Find items in the folder(s).</p>
<p>Non-keyword args may be a list of Q instances.</p>
<p>Optional extra keyword arguments follow a Django-like QuerySet filter syntax (see
<a href="https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups">https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups</a>).</p>
<p>We don't support '__year' and other date-related lookups. We also don't support '__endswith' or '__iendswith'.</p>
<p>We support the additional '__not' lookup in place of Django's exclude() for simple cases. For more complicated
cases you need to create a Q object and use ~Q().</p>
<h2 id="examples">Examples</h2>
<p>my_account.inbox.filter(datetime_received__gt=EWSDateTime(2016, 1, 1))
my_account.calendar.filter(start__range=(EWSDateTime(2016, 1, 1), EWSDateTime(2017, 1, 1)))
my_account.tasks.filter(subject='Hi mom')
my_account.tasks.filter(subject__not='Hi mom')
my_account.tasks.filter(subject__contains='Foo')
my_account.tasks.filter(subject__icontains='foo')</p>
<p>'endswith' and 'iendswith' could be emulated by searching with 'contains' or 'icontains' and then
post-processing items. Fetch the field in question with additional_fields and remove items where the search
string is not a postfix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, *args, **kwargs):
    &#34;&#34;&#34;Find items in the folder(s).

    Non-keyword args may be a list of Q instances.

    Optional extra keyword arguments follow a Django-like QuerySet filter syntax (see
       https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups).

    We don&#39;t support &#39;__year&#39; and other date-related lookups. We also don&#39;t support &#39;__endswith&#39; or &#39;__iendswith&#39;.

    We support the additional &#39;__not&#39; lookup in place of Django&#39;s exclude() for simple cases. For more complicated
    cases you need to create a Q object and use ~Q().

    Examples:

        my_account.inbox.filter(datetime_received__gt=EWSDateTime(2016, 1, 1))
        my_account.calendar.filter(start__range=(EWSDateTime(2016, 1, 1), EWSDateTime(2017, 1, 1)))
        my_account.tasks.filter(subject=&#39;Hi mom&#39;)
        my_account.tasks.filter(subject__not=&#39;Hi mom&#39;)
        my_account.tasks.filter(subject__contains=&#39;Foo&#39;)
        my_account.tasks.filter(subject__icontains=&#39;foo&#39;)

    &#39;endswith&#39; and &#39;iendswith&#39; could be emulated by searching with &#39;contains&#39; or &#39;icontains&#39; and then
    post-processing items. Fetch the field in question with additional_fields and remove items where the search
    string is not a postfix.
    &#34;&#34;&#34;
    return QuerySet(self).filter(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.find_folders"><code class="name flex">
<span>def <span class="ident">find_folders</span></span>(<span>self, q=None, shape='IdOnly', depth=None, additional_fields=None, page_size=None, max_items=None, offset=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_account
def find_folders(
    self, q=None, shape=ID_ONLY, depth=None, additional_fields=None, page_size=None, max_items=None, offset=0
):
    from ..services import FindFolder

    # &#39;depth&#39; controls whether to return direct children or recurse into sub-folders
    from .base import BaseFolder, Folder

    if q is None:
        q = Q()
    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return
    if q.is_never():
        log.debug(&#34;Query will never return results&#34;)
        return
    if q.is_empty():
        restriction = None
    else:
        restriction = Restriction(q, folders=self.folders, applies_to=Restriction.FOLDERS)
    if depth is None:
        depth = self._get_default_folder_traversal_depth()
    if additional_fields is None:
        # Default to all non-complex properties. Sub-folders will always be of class Folder
        additional_fields = self.get_folder_fields(target_cls=Folder, is_complex=False)
    else:
        for f in additional_fields:
            if f.field.is_complex:
                raise ValueError(f&#34;find_folders() does not support field {f.field.name!r}. Use get_folders().&#34;)

    # Add required fields
    additional_fields.update(
        (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
    )

    yield from FindFolder(account=self.account, page_size=page_size).call(
        folders=self.folders,
        additional_fields=additional_fields,
        restriction=restriction,
        shape=shape,
        depth=depth,
        max_items=max_items,
        offset=offset,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.find_items"><code class="name flex">
<span>def <span class="ident">find_items</span></span>(<span>self, q, shape='IdOnly', depth=None, additional_fields=None, order_fields=None, calendar_view=None, page_size=None, max_items=None, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Private method to call the FindItem service.</p>
<p>:param q: a Q instance containing any restrictions
:param shape: controls whether to return (id, changekey) tuples or Item objects. If additional_fields is
non-null, we always return Item objects. (Default value = ID_ONLY)
:param depth: controls the whether to return soft-deleted items or not. (Default value = None)
:param additional_fields: the extra properties we want on the return objects. Default is no properties. Be aware
that complex fields can only be fetched with fetch() (i.e. the GetItem service).
:param order_fields: the SortOrder fields, if any (Default value = None)
:param calendar_view: a CalendarView instance, if any (Default value = None)
:param page_size: the requested number of items per page (Default value = None)
:param max_items: the max number of items to return (Default value = None)
:param offset: the offset relative to the first item in the item collection (Default value = 0)</p>
<p>:return: a generator for the returned item IDs or items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_items(
    self,
    q,
    shape=ID_ONLY,
    depth=None,
    additional_fields=None,
    order_fields=None,
    calendar_view=None,
    page_size=None,
    max_items=None,
    offset=0,
):
    &#34;&#34;&#34;Private method to call the FindItem service.

    :param q: a Q instance containing any restrictions
    :param shape: controls whether to return (id, changekey) tuples or Item objects. If additional_fields is
      non-null, we always return Item objects. (Default value = ID_ONLY)
    :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
    :param additional_fields: the extra properties we want on the return objects. Default is no properties. Be aware
      that complex fields can only be fetched with fetch() (i.e. the GetItem service).
    :param order_fields: the SortOrder fields, if any (Default value = None)
    :param calendar_view: a CalendarView instance, if any (Default value = None)
    :param page_size: the requested number of items per page (Default value = None)
    :param max_items: the max number of items to return (Default value = None)
    :param offset: the offset relative to the first item in the item collection (Default value = 0)

    :return: a generator for the returned item IDs or items
    &#34;&#34;&#34;
    from ..services import FindItem

    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return
    if q.is_never():
        log.debug(&#34;Query will never return results&#34;)
        return
    depth, restriction, query_string = self._rinse_args(
        q=q, depth=depth, additional_fields=additional_fields, field_validator=self.validate_item_field
    )
    if calendar_view is not None and not isinstance(calendar_view, CalendarView):
        raise InvalidTypeError(&#34;calendar_view&#34;, calendar_view, CalendarView)

    log.debug(
        &#34;Finding %s items in folders %s (shape: %s, depth: %s, additional_fields: %s, restriction: %s)&#34;,
        self.account,
        self.folders,
        shape,
        depth,
        additional_fields,
        restriction.q if restriction else None,
    )
    yield from FindItem(account=self.account, page_size=page_size).call(
        folders=self.folders,
        additional_fields=additional_fields,
        restriction=restriction,
        order_fields=order_fields,
        shape=shape,
        query_string=query_string,
        depth=depth,
        calendar_view=calendar_view,
        max_items=calendar_view.max_items if calendar_view else max_items,
        offset=offset,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.find_people"><code class="name flex">
<span>def <span class="ident">find_people</span></span>(<span>self, q, shape='IdOnly', depth=None, additional_fields=None, order_fields=None, page_size=None, max_items=None, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Private method to call the FindPeople service.</p>
<p>:param q: a Q instance containing any restrictions
:param shape: controls whether to return (id, changekey) tuples or Persona objects. If additional_fields is
non-null, we always return Persona objects. (Default value = ID_ONLY)
:param depth: controls the whether to return soft-deleted items or not. (Default value = None)
:param additional_fields: the extra properties we want on the return objects. Default is no properties.
:param order_fields: the SortOrder fields, if any (Default value = None)
:param page_size: the requested number of items per page (Default value = None)
:param max_items: the max number of items to return (Default value = None)
:param offset: the offset relative to the first item in the item collection (Default value = 0)</p>
<p>:return: a generator for the returned personas</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_people(
    self,
    q,
    shape=ID_ONLY,
    depth=None,
    additional_fields=None,
    order_fields=None,
    page_size=None,
    max_items=None,
    offset=0,
):
    &#34;&#34;&#34;Private method to call the FindPeople service.

    :param q: a Q instance containing any restrictions
    :param shape: controls whether to return (id, changekey) tuples or Persona objects. If additional_fields is
      non-null, we always return Persona objects. (Default value = ID_ONLY)
    :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
    :param additional_fields: the extra properties we want on the return objects. Default is no properties.
    :param order_fields: the SortOrder fields, if any (Default value = None)
    :param page_size: the requested number of items per page (Default value = None)
    :param max_items: the max number of items to return (Default value = None)
    :param offset: the offset relative to the first item in the item collection (Default value = 0)

    :return: a generator for the returned personas
    &#34;&#34;&#34;
    from ..services import FindPeople

    folder = self._get_single_folder()
    if q.is_never():
        log.debug(&#34;Query will never return results&#34;)
        return
    depth, restriction, query_string = self._rinse_args(
        q=q, depth=depth, additional_fields=additional_fields, field_validator=Persona.validate_field
    )

    yield from FindPeople(account=self.account, page_size=page_size).call(
        folder=folder,
        additional_fields=additional_fields,
        restriction=restriction,
        order_fields=order_fields,
        shape=shape,
        query_string=query_string,
        depth=depth,
        max_items=max_items,
        offset=offset,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.get_folder_fields"><code class="name flex">
<span>def <span class="ident">get_folder_fields</span></span>(<span>self, target_cls, is_complex=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folder_fields(self, target_cls, is_complex=None):
    return {
        FieldPath(field=f)
        for f in target_cls.supported_fields(version=self.account.version)
        if is_complex is None or f.is_complex is is_complex
    }</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.get_folders"><code class="name flex">
<span>def <span class="ident">get_folders</span></span>(<span>self, additional_fields=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folders(self, additional_fields=None):
    from ..services import GetFolder

    # Expand folders with their full set of properties
    from .base import BaseFolder

    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return
    if additional_fields is None:
        # Default to all complex properties
        additional_fields = self.get_folder_fields(target_cls=self._get_target_cls(), is_complex=True)

    # Add required fields
    additional_fields.update(
        (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
    )

    yield from GetFolder(account=self.account).call(
        folders=self.folders,
        additional_fields=additional_fields,
        shape=ID_ONLY,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.pull_subscription"><code class="name flex">
<span>def <span class="ident">pull_subscription</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pull_subscription(self, **kwargs):
    return PullSubscription(target=self, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.push_subscription"><code class="name flex">
<span>def <span class="ident">push_subscription</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_subscription(self, **kwargs):
    return PushSubscription(target=self, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve(self):
    # Looks up the folders or folder IDs in the collection and returns full Folder instances with all fields set.
    from .base import BaseFolder

    resolveable_folders = []
    for f in self.folders:
        if isinstance(f, BaseFolder) and not f.get_folder_allowed:
            log.debug(&#34;GetFolder not allowed on folder %s. Non-complex fields must be fetched with FindFolder&#34;, f)
            yield f
        else:
            resolveable_folders.append(f)
    # Fetch all properties for the remaining folders of folder IDs
    additional_fields = self.get_folder_fields(target_cls=self._get_target_cls())
    yield from self.__class__(account=self.account, folders=resolveable_folders).get_folders(
        additional_fields=additional_fields
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.streaming_subscription"><code class="name flex">
<span>def <span class="ident">streaming_subscription</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def streaming_subscription(self, **kwargs):
    return StreamingSubscription(target=self, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.subscribe_to_pull"><code class="name flex">
<span>def <span class="ident">subscribe_to_pull</span></span>(<span>self, event_types=None, watermark=None, timeout=60)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_pull(self, event_types=None, watermark=None, timeout=60):
    from ..services import SubscribeToPull

    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return None
    if event_types is None:
        event_types = SubscribeToPull.EVENT_TYPES
    return SubscribeToPull(account=self.account).get(
        folders=self.folders,
        event_types=event_types,
        watermark=watermark,
        timeout=timeout,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.subscribe_to_push"><code class="name flex">
<span>def <span class="ident">subscribe_to_push</span></span>(<span>self, callback_url, event_types=None, watermark=None, status_frequency=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_push(self, callback_url, event_types=None, watermark=None, status_frequency=1):
    from ..services import SubscribeToPush

    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return None
    if event_types is None:
        event_types = SubscribeToPush.EVENT_TYPES
    return SubscribeToPush(account=self.account).get(
        folders=self.folders,
        event_types=event_types,
        watermark=watermark,
        status_frequency=status_frequency,
        url=callback_url,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.subscribe_to_streaming"><code class="name flex">
<span>def <span class="ident">subscribe_to_streaming</span></span>(<span>self, event_types=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_streaming(self, event_types=None):
    from ..services import SubscribeToStreaming

    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return None
    if event_types is None:
        event_types = SubscribeToStreaming.EVENT_TYPES
    return SubscribeToStreaming(account=self.account).get(folders=self.folders, event_types=event_types)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.sync_hierarchy"><code class="name flex">
<span>def <span class="ident">sync_hierarchy</span></span>(<span>self, sync_state=None, only_fields=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync_hierarchy(self, sync_state=None, only_fields=None):
    from ..services import SyncFolderHierarchy

    folder = self._get_single_folder()
    if only_fields is None:
        # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
        additional_fields = {FieldPath(field=f) for f in folder.supported_fields(version=self.account.version)}
    else:
        additional_fields = set()
        for field_name in only_fields:
            folder.validate_field(field=field_name, version=self.account.version)
            f = folder.get_field_by_fieldname(fieldname=field_name)
            if not f.is_attribute:
                # Remove ItemId and ChangeKey. We get them unconditionally
                additional_fields.add(FieldPath(field=f))

    # Add required fields
    additional_fields.update(
        (FieldPath(field=folder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
    )

    svc = SyncFolderHierarchy(account=self.account)
    while True:
        yield from svc.call(
            folder=folder,
            shape=ID_ONLY,
            additional_fields=additional_fields,
            sync_state=sync_state,
        )
        if svc.sync_state == sync_state:
            # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
            break
        sync_state = svc.sync_state  # Set the new sync state in the next call
        if svc.includes_last_item_in_range:  # Try again if there are more items
            break
    raise SyncCompleted(sync_state=svc.sync_state)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.sync_items"><code class="name flex">
<span>def <span class="ident">sync_items</span></span>(<span>self, sync_state=None, only_fields=None, ignore=None, max_changes_returned=None, sync_scope=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync_items(self, sync_state=None, only_fields=None, ignore=None, max_changes_returned=None, sync_scope=None):
    from ..services import SyncFolderItems

    folder = self._get_single_folder()
    if only_fields is None:
        # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
        additional_fields = {FieldPath(field=f) for f in folder.allowed_item_fields(version=self.account.version)}
    else:
        for field in only_fields:
            folder.validate_item_field(field=field, version=self.account.version)
        # Remove ItemId and ChangeKey. We get them unconditionally
        additional_fields = {f for f in folder.normalize_fields(fields=only_fields) if not f.field.is_attribute}

    svc = SyncFolderItems(account=self.account)
    while True:
        yield from svc.call(
            folder=folder,
            shape=ID_ONLY,
            additional_fields=additional_fields,
            sync_state=sync_state,
            ignore=ignore,
            max_changes_returned=max_changes_returned,
            sync_scope=sync_scope,
        )
        if svc.sync_state == sync_state:
            # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
            break
        sync_state = svc.sync_state  # Set the new sync state in the next call
        if svc.includes_last_item_in_range:  # Try again if there are more items
            break
    raise SyncCompleted(sync_state=svc.sync_state)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.unsubscribe"><code class="name flex">
<span>def <span class="ident">unsubscribe</span></span>(<span>self, subscription_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Unsubscribe. Only applies to pull and streaming notifications.</p>
<p>:param subscription_id: A subscription ID as acquired by .subscribe_to_<a href="">pull|streaming</a>
:return: True</p>
<p>This method doesn't need the current collection instance, but it makes sense to keep the method along the other
sync methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unsubscribe(self, subscription_id):
    &#34;&#34;&#34;Unsubscribe. Only applies to pull and streaming notifications.

    :param subscription_id: A subscription ID as acquired by .subscribe_to_[pull|streaming]()
    :return: True

    This method doesn&#39;t need the current collection instance, but it makes sense to keep the method along the other
    sync methods.
    &#34;&#34;&#34;
    from ..services import Unsubscribe

    return Unsubscribe(account=self.account).get(subscription_id=subscription_id)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.validate_item_field"><code class="name flex">
<span>def <span class="ident">validate_item_field</span></span>(<span>self, field, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_item_field(self, field, version):
    # Takes a fieldname, Field or FieldPath object pointing to an item field, and checks that it is valid
    # for the item types supported by this folder collection.
    for item_model in self.supported_item_models:
        try:
            item_model.validate_field(field=field, version=version)
            break
        except InvalidField:
            continue
    else:
        raise InvalidField(f&#34;{field!r} is not a valid field on {self.supported_item_models}&#34;)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.view"><code class="name flex">
<span>def <span class="ident">view</span></span>(<span>self, start, end, max_items=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the CalendarView option to FindItem. The difference between 'filter' and 'view' is that 'filter'
only returns the master CalendarItem for recurring items, while 'view' unfolds recurring items and returns all
CalendarItem occurrences as one would normally expect when presenting a calendar.</p>
<p>Supports the same semantics as filter, except for 'start' and 'end' keyword attributes which are both required
and behave differently than filter. Here, they denote the start and end of the timespan of the view. All items
the overlap the timespan are returned (items that end exactly on 'start' are also returned, for some reason).</p>
<p>EWS does not allow combining CalendarView with search restrictions (filter and exclude).</p>
<p>'max_items' defines the maximum number of items returned in this view. Optional.</p>
<p>:param start:
:param end:
:param max_items:
(Default value = None)
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view(self, start, end, max_items=None):
    &#34;&#34;&#34;Implement the CalendarView option to FindItem. The difference between &#39;filter&#39; and &#39;view&#39; is that &#39;filter&#39;
    only returns the master CalendarItem for recurring items, while &#39;view&#39; unfolds recurring items and returns all
    CalendarItem occurrences as one would normally expect when presenting a calendar.

    Supports the same semantics as filter, except for &#39;start&#39; and &#39;end&#39; keyword attributes which are both required
    and behave differently than filter. Here, they denote the start and end of the timespan of the view. All items
    the overlap the timespan are returned (items that end exactly on &#39;start&#39; are also returned, for some reason).

    EWS does not allow combining CalendarView with search restrictions (filter and exclude).

    &#39;max_items&#39; defines the maximum number of items returned in this view. Optional.

    :param start:
    :param end:
    :param max_items:  (Default value = None)
    :return:
    &#34;&#34;&#34;
    qs = QuerySet(self)
    qs.calendar_view = CalendarView(start=start, end=end, max_items=max_items)
    return qs</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.queryset.SearchableMixIn" href="queryset.html#exchangelib.queryset.SearchableMixIn">SearchableMixIn</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.queryset.SearchableMixIn.all" href="queryset.html#exchangelib.queryset.SearchableMixIn.all">all</a></code></li>
<li><code><a title="exchangelib.queryset.SearchableMixIn.exclude" href="queryset.html#exchangelib.queryset.SearchableMixIn.exclude">exclude</a></code></li>
<li><code><a title="exchangelib.queryset.SearchableMixIn.get" href="queryset.html#exchangelib.queryset.SearchableMixIn.get">get</a></code></li>
<li><code><a title="exchangelib.queryset.SearchableMixIn.none" href="queryset.html#exchangelib.queryset.SearchableMixIn.none">none</a></code></li>
<li><code><a title="exchangelib.queryset.SearchableMixIn.people" href="queryset.html#exchangelib.queryset.SearchableMixIn.people">people</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.ForwardItem"><code class="flex name class">
<span>class <span class="ident">ForwardItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/forwarditem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/forwarditem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForwardItem(BaseReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/forwarditem&#34;&#34;&#34;

    ELEMENT_NAME = &#34;ForwardItem&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ForwardItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.base.BaseReplyItem.account" href="items/base.html#exchangelib.items.base.BaseReplyItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.save" href="items/base.html#exchangelib.items.base.BaseReplyItem.save">save</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.HTMLBody"><code class="flex name class">
<span>class <span class="ident">HTMLBody</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to mark the 'body' field as a complex attribute.</p>
<p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HTMLBody(Body):
    &#34;&#34;&#34;Helper to mark the &#39;body&#39; field as a complex attribute.

    MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body
    &#34;&#34;&#34;

    body_type = &#34;HTML&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.Body" href="properties.html#exchangelib.properties.Body">Body</a></li>
<li>builtins.str</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.HTMLBody.body_type"><code class="name">var <span class="ident">body_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.Body" href="properties.html#exchangelib.properties.Body">Body</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.Body.format" href="properties.html#exchangelib.properties.Body.format">format</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Identity"><code class="flex name class">
<span>class <span class="ident">Identity</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains information that uniquely identifies an account. Currently only used for SOAP impersonation headers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Identity(EWSElement):
    &#34;&#34;&#34;Contains information that uniquely identifies an account. Currently only used for SOAP impersonation headers.&#34;&#34;&#34;

    ELEMENT_NAME = &#34;ConnectingSID&#34;

    # We have multiple options for uniquely identifying the user. Here&#39;s a prioritized list in accordance with
    # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/connectingsid
    sid = TextField(field_uri=&#34;SID&#34;)
    upn = TextField(field_uri=&#34;PrincipalName&#34;)
    smtp_address = TextField(field_uri=&#34;SmtpAddress&#34;)  # The (non-)primary email address for the account
    primary_smtp_address = TextField(field_uri=&#34;PrimarySmtpAddress&#34;)  # The primary email address for the account</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Identity.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Identity.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Identity.primary_smtp_address"><code class="name">var <span class="ident">primary_smtp_address</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Identity.sid"><code class="name">var <span class="ident">sid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Identity.smtp_address"><code class="name">var <span class="ident">smtp_address</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Identity.upn"><code class="name">var <span class="ident">upn</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.EWSElement.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.ItemAttachment"><code class="flex name class">
<span>class <span class="ident">ItemAttachment</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemattachment">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemattachment</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ItemAttachment(Attachment):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemattachment&#34;&#34;&#34;

    ELEMENT_NAME = &#34;ItemAttachment&#34;

    _item = ItemField(field_uri=&#34;Item&#34;)

    def __init__(self, **kwargs):
        kwargs[&#34;_item&#34;] = kwargs.pop(&#34;item&#34;, None)
        super().__init__(**kwargs)

    @property
    def item(self):
        from .folders import BaseFolder
        from .services import GetAttachment

        if self.attachment_id is None:
            return self._item
        if self._item is not None:
            return self._item
        # We have an ID to the data but still haven&#39;t called GetAttachment to get the actual data. Do that now.
        if not self.parent_item or not self.parent_item.account:
            raise ValueError(f&#34;{self.__class__.__name__} must have an account&#34;)
        additional_fields = {
            FieldPath(field=f) for f in BaseFolder.allowed_item_fields(version=self.parent_item.account.version)
        }
        attachment = GetAttachment(account=self.parent_item.account).get(
            items=[self.attachment_id],
            include_mime_content=True,
            body_type=None,
            filter_html_content=None,
            additional_fields=additional_fields,
        )
        self._item = attachment.item
        return self._item

    @item.setter
    def item(self, value):
        from .items import Item

        if not isinstance(value, Item):
            raise InvalidTypeError(&#34;value&#34;, value, Item)
        self._item = value

    @classmethod
    def from_xml(cls, elem, account):
        kwargs = {f.name: f.from_xml(elem=elem, account=account) for f in cls.FIELDS}
        kwargs[&#34;item&#34;] = kwargs.pop(&#34;_item&#34;)
        cls._clear(elem)
        return cls(**kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.attachments.Attachment" href="attachments.html#exchangelib.attachments.Attachment">Attachment</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ItemAttachment.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ItemAttachment.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.ItemAttachment.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    kwargs = {f.name: f.from_xml(elem=elem, account=account) for f in cls.FIELDS}
    kwargs[&#34;item&#34;] = kwargs.pop(&#34;_item&#34;)
    cls._clear(elem)
    return cls(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.ItemAttachment.item"><code class="name">var <span class="ident">item</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def item(self):
    from .folders import BaseFolder
    from .services import GetAttachment

    if self.attachment_id is None:
        return self._item
    if self._item is not None:
        return self._item
    # We have an ID to the data but still haven&#39;t called GetAttachment to get the actual data. Do that now.
    if not self.parent_item or not self.parent_item.account:
        raise ValueError(f&#34;{self.__class__.__name__} must have an account&#34;)
    additional_fields = {
        FieldPath(field=f) for f in BaseFolder.allowed_item_fields(version=self.parent_item.account.version)
    }
    attachment = GetAttachment(account=self.parent_item.account).get(
        items=[self.attachment_id],
        include_mime_content=True,
        body_type=None,
        filter_html_content=None,
        additional_fields=additional_fields,
    )
    self._item = attachment.item
    return self._item</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.attachments.Attachment" href="attachments.html#exchangelib.attachments.Attachment">Attachment</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.attachments.Attachment.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.parent_item" href="attachments.html#exchangelib.attachments.Attachment.parent_item">parent_item</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.ItemId"><code class="flex name class">
<span>class <span class="ident">ItemId</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>'id' and 'changekey' are UUIDs generated by Exchange.</p>
<p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemid">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemid</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ItemId(BaseItemId):
    &#34;&#34;&#34;&#39;id&#39; and &#39;changekey&#39; are UUIDs generated by Exchange.

    MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemid
    &#34;&#34;&#34;

    ELEMENT_NAME = &#34;ItemId&#34;
    ID_ATTR = &#34;Id&#34;
    CHANGEKEY_ATTR = &#34;ChangeKey&#34;

    id = IdField(field_uri=ID_ATTR, is_required=True)
    changekey = IdField(field_uri=CHANGEKEY_ATTR, is_required=False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.BaseItemId" href="properties.html#exchangelib.properties.BaseItemId">BaseItemId</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.AssociatedCalendarItemId" href="properties.html#exchangelib.properties.AssociatedCalendarItemId">AssociatedCalendarItemId</a></li>
<li><a title="exchangelib.properties.ConversationId" href="properties.html#exchangelib.properties.ConversationId">ConversationId</a></li>
<li><a title="exchangelib.properties.FolderId" href="properties.html#exchangelib.properties.FolderId">FolderId</a></li>
<li><a title="exchangelib.properties.MovedItemId" href="properties.html#exchangelib.properties.MovedItemId">MovedItemId</a></li>
<li><a title="exchangelib.properties.OldItemId" href="properties.html#exchangelib.properties.OldItemId">OldItemId</a></li>
<li><a title="exchangelib.properties.ParentFolderId" href="properties.html#exchangelib.properties.ParentFolderId">ParentFolderId</a></li>
<li><a title="exchangelib.properties.ParentItemId" href="properties.html#exchangelib.properties.ParentItemId">ParentItemId</a></li>
<li><a title="exchangelib.properties.PersonaId" href="properties.html#exchangelib.properties.PersonaId">PersonaId</a></li>
<li><a title="exchangelib.properties.ReferenceItemId" href="properties.html#exchangelib.properties.ReferenceItemId">ReferenceItemId</a></li>
<li><a title="exchangelib.properties.SourceId" href="properties.html#exchangelib.properties.SourceId">SourceId</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ItemId.CHANGEKEY_ATTR"><code class="name">var <span class="ident">CHANGEKEY_ATTR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ItemId.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ItemId.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ItemId.ID_ATTR"><code class="name">var <span class="ident">ID_ATTR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.ItemId.changekey"><code class="name">var <span class="ident">changekey</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ItemId.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.BaseItemId" href="properties.html#exchangelib.properties.BaseItemId">BaseItemId</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.BaseItemId.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.BaseItemId.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.BaseItemId.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.BaseItemId.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Mailbox"><code class="flex name class">
<span>class <span class="ident">Mailbox</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/mailbox">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/mailbox</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mailbox(EWSElement):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/mailbox&#34;&#34;&#34;

    ELEMENT_NAME = &#34;Mailbox&#34;
    MAILBOX = &#34;Mailbox&#34;
    ONE_OFF = &#34;OneOff&#34;
    MAILBOX_TYPE_CHOICES = {
        Choice(MAILBOX),
        Choice(&#34;PublicDL&#34;),
        Choice(&#34;PrivateDL&#34;),
        Choice(&#34;Contact&#34;),
        Choice(&#34;PublicFolder&#34;),
        Choice(&#34;Unknown&#34;),
        Choice(ONE_OFF),
        Choice(&#34;GroupMailbox&#34;, supported_from=EXCHANGE_2013),
    }

    name = TextField(field_uri=&#34;Name&#34;)
    email_address = EmailAddressField(field_uri=&#34;EmailAddress&#34;)
    # RoutingType values are not restricted:
    # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/routingtype-emailaddresstype
    routing_type = TextField(field_uri=&#34;RoutingType&#34;, default=&#34;SMTP&#34;)
    mailbox_type = ChoiceField(field_uri=&#34;MailboxType&#34;, choices=MAILBOX_TYPE_CHOICES, default=MAILBOX)
    item_id = EWSElementField(value_cls=ItemId, is_read_only=True)

    def clean(self, version=None):
        super().clean(version=version)

        if self.mailbox_type != self.ONE_OFF and not self.email_address and not self.item_id:
            # A OneOff Mailbox (a one-off member of a personal distribution list) may lack these fields, but other
            # Mailboxes require at least one. See also &#34;Remarks&#34; section of
            # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/mailbox
            raise ValueError(f&#34;Mailbox type {self.mailbox_type!r} must have either &#39;email_address&#39; or &#39;item_id&#39; set&#34;)

    def __hash__(self):
        # Exchange may add &#39;mailbox_type&#39; and &#39;name&#39; on insert. We&#39;re satisfied if the item_id or email address matches.
        if self.item_id:
            return hash(self.item_id)
        if self.email_address:
            return hash(self.email_address.lower())
        return super().__hash__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.Address" href="properties.html#exchangelib.properties.Address">Address</a></li>
<li><a title="exchangelib.properties.DLMailbox" href="properties.html#exchangelib.properties.DLMailbox">DLMailbox</a></li>
<li><a title="exchangelib.properties.EmailAddress" href="properties.html#exchangelib.properties.EmailAddress">EmailAddress</a></li>
<li><a title="exchangelib.properties.EmailAddressTypeValue" href="properties.html#exchangelib.properties.EmailAddressTypeValue">EmailAddressTypeValue</a></li>
<li><a title="exchangelib.properties.PersonaPostalAddressTypeValue" href="properties.html#exchangelib.properties.PersonaPostalAddressTypeValue">PersonaPostalAddressTypeValue</a></li>
<li><a title="exchangelib.properties.RecipientAddress" href="properties.html#exchangelib.properties.RecipientAddress">RecipientAddress</a></li>
<li><a title="exchangelib.properties.Room" href="properties.html#exchangelib.properties.Room">Room</a></li>
<li><a title="exchangelib.properties.RoomList" href="properties.html#exchangelib.properties.RoomList">RoomList</a></li>
<li><a title="exchangelib.properties.SendingAs" href="properties.html#exchangelib.properties.SendingAs">SendingAs</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Mailbox.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.MAILBOX"><code class="name">var <span class="ident">MAILBOX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.MAILBOX_TYPE_CHOICES"><code class="name">var <span class="ident">MAILBOX_TYPE_CHOICES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.ONE_OFF"><code class="name">var <span class="ident">ONE_OFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Mailbox.email_address"><code class="name">var <span class="ident">email_address</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.item_id"><code class="name">var <span class="ident">item_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.mailbox_type"><code class="name">var <span class="ident">mailbox_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.routing_type"><code class="name">var <span class="ident">routing_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Mailbox.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    super().clean(version=version)

    if self.mailbox_type != self.ONE_OFF and not self.email_address and not self.item_id:
        # A OneOff Mailbox (a one-off member of a personal distribution list) may lack these fields, but other
        # Mailboxes require at least one. See also &#34;Remarks&#34; section of
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/mailbox
        raise ValueError(f&#34;Mailbox type {self.mailbox_type!r} must have either &#39;email_address&#39; or &#39;item_id&#39; set&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.EWSElement.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Message"><code class="flex name class">
<span>class <span class="ident">Message</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN:
<a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/message-ex15websvcsotherref">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/message-ex15websvcsotherref</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Message(Item):
    &#34;&#34;&#34;MSDN:
    https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/message-ex15websvcsotherref
    &#34;&#34;&#34;

    ELEMENT_NAME = &#34;Message&#34;

    sender = MailboxField(field_uri=&#34;message:Sender&#34;, is_read_only=True, is_read_only_after_send=True)
    to_recipients = MailboxListField(
        field_uri=&#34;message:ToRecipients&#34;, is_read_only_after_send=True, is_searchable=False
    )
    cc_recipients = MailboxListField(
        field_uri=&#34;message:CcRecipients&#34;, is_read_only_after_send=True, is_searchable=False
    )
    bcc_recipients = MailboxListField(
        field_uri=&#34;message:BccRecipients&#34;, is_read_only_after_send=True, is_searchable=False
    )
    is_read_receipt_requested = BooleanField(
        field_uri=&#34;message:IsReadReceiptRequested&#34;, is_required=True, default=False, is_read_only_after_send=True
    )
    is_delivery_receipt_requested = BooleanField(
        field_uri=&#34;message:IsDeliveryReceiptRequested&#34;, is_required=True, default=False, is_read_only_after_send=True
    )
    conversation_index = Base64Field(field_uri=&#34;message:ConversationIndex&#34;, is_read_only=True)
    conversation_topic = CharField(field_uri=&#34;message:ConversationTopic&#34;, is_read_only=True)
    # Rename &#39;From&#39; to &#39;author&#39;. We can&#39;t use field name &#39;from&#39; since it&#39;s a Python keyword.
    author = MailboxField(field_uri=&#34;message:From&#34;, is_read_only_after_send=True)
    message_id = TextField(field_uri=&#34;message:InternetMessageId&#34;, is_read_only_after_send=True)
    is_read = BooleanField(field_uri=&#34;message:IsRead&#34;, is_required=True, default=False)
    is_response_requested = BooleanField(field_uri=&#34;message:IsResponseRequested&#34;, default=False, is_required=True)
    references = TextField(field_uri=&#34;message:References&#34;)
    reply_to = MailboxListField(field_uri=&#34;message:ReplyTo&#34;, is_read_only_after_send=True, is_searchable=False)
    received_by = MailboxField(field_uri=&#34;message:ReceivedBy&#34;, is_read_only=True)
    received_representing = MailboxField(field_uri=&#34;message:ReceivedRepresenting&#34;, is_read_only=True)
    reminder_message_data = EWSElementField(
        field_uri=&#34;message:ReminderMessageData&#34;,
        value_cls=ReminderMessageData,
        supported_from=EXCHANGE_2013_SP1,
        is_read_only=True,
    )

    @require_account
    def send(
        self,
        save_copy=True,
        copy_to_folder=None,
        conflict_resolution=AUTO_RESOLVE,
        send_meeting_invitations=SEND_TO_NONE,
    ):
        from ..services import SendItem

        # Only sends a message. The message can either be an existing draft stored in EWS or a new message that does
        # not yet exist in EWS.
        if copy_to_folder and not save_copy:
            raise AttributeError(&#34;&#39;save_copy&#39; must be True when &#39;copy_to_folder&#39; is set&#34;)
        if save_copy and not copy_to_folder:
            copy_to_folder = self.account.sent  # &#39;Sent&#39; is default EWS behaviour
        if self.id:
            SendItem(account=self.account).get(items=[self], saved_item_folder=copy_to_folder)
            # The item will be deleted from the original folder
            self._id = None
            self.folder = copy_to_folder
            return None

        # New message
        if copy_to_folder:
            # This would better be done via send_and_save() but let&#39;s just support it here
            self.folder = copy_to_folder
            return self.send_and_save(
                conflict_resolution=conflict_resolution, send_meeting_invitations=send_meeting_invitations
            )

        if self.account.version.build &lt; EXCHANGE_2013 and self.attachments:
            # At least some versions prior to Exchange 2013 can&#39;t send attachments immediately. You need to first save,
            # then attach, then send. This is done in send_and_save(). send() will delete the item again.
            self.send_and_save(
                conflict_resolution=conflict_resolution, send_meeting_invitations=send_meeting_invitations
            )
            return None

        self._create(message_disposition=SEND_ONLY, send_meeting_invitations=send_meeting_invitations)
        return None

    def send_and_save(
        self, update_fields=None, conflict_resolution=AUTO_RESOLVE, send_meeting_invitations=SEND_TO_NONE
    ):
        # Sends Message and saves a copy in the parent folder. Does not return an ItemId.
        if self.id:
            return self._update(
                update_fieldnames=update_fields,
                message_disposition=SEND_AND_SAVE_COPY,
                conflict_resolution=conflict_resolution,
                send_meeting_invitations=send_meeting_invitations,
            )
        if self.account.version.build &lt; EXCHANGE_2013 and self.attachments:
            # At least some versions prior to Exchange 2013 can&#39;t send-and-save attachments immediately. You need
            # to first save, then attach, then send. This is done in save().
            self.save(
                update_fields=update_fields,
                conflict_resolution=conflict_resolution,
                send_meeting_invitations=send_meeting_invitations,
            )
            return self.send(
                save_copy=False,
                conflict_resolution=conflict_resolution,
                send_meeting_invitations=send_meeting_invitations,
            )
        return self._create(message_disposition=SEND_AND_SAVE_COPY, send_meeting_invitations=send_meeting_invitations)

    @require_id
    def create_reply(self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None, author=None):
        if not to_recipients:
            if not self.author:
                raise ValueError(&#34;&#39;to_recipients&#39; must be set when message has no &#39;author&#39;&#34;)
            to_recipients = [self.author]
        return ReplyToItem(
            account=self.account,
            reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
            subject=subject,
            new_body=body,
            to_recipients=to_recipients,
            cc_recipients=cc_recipients,
            bcc_recipients=bcc_recipients,
            author=author,
        )

    def reply(self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None, author=None):
        return self.create_reply(subject, body, to_recipients, cc_recipients, bcc_recipients, author).send()

    @require_id
    def create_reply_all(self, subject, body, author=None):
        me = MailboxField().clean(self.account.primary_smtp_address.lower())
        to_recipients = set(self.to_recipients or [])
        to_recipients.discard(me)
        cc_recipients = set(self.cc_recipients or [])
        cc_recipients.discard(me)
        bcc_recipients = set(self.bcc_recipients or [])
        bcc_recipients.discard(me)
        if self.author:
            to_recipients.add(self.author)
        return ReplyAllToItem(
            account=self.account,
            reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
            subject=subject,
            new_body=body,
            to_recipients=list(to_recipients),
            cc_recipients=list(cc_recipients),
            bcc_recipients=list(bcc_recipients),
            author=author,
        )

    def reply_all(self, subject, body, author=None):
        return self.create_reply_all(subject, body, author).send()

    def mark_as_junk(self, is_junk=True, move_item=True):
        &#34;&#34;&#34;Mark or un-marks items as junk email.

        :param is_junk: If True, the sender will be added from the blocked sender list. Otherwise, the sender will be
        removed.
        :param move_item: If true, the item will be moved to the junk folder.
        :return:
        &#34;&#34;&#34;
        from ..services import MarkAsJunk

        res = MarkAsJunk(account=self.account).get(
            items=[self], is_junk=is_junk, move_item=move_item, expect_result=None
        )
        if res is None:
            return
        self.folder = self.account.junk if is_junk else self.account.inbox
        self.id, self.changekey = res</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Message.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Message.author"><code class="name">var <span class="ident">author</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.bcc_recipients"><code class="name">var <span class="ident">bcc_recipients</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.cc_recipients"><code class="name">var <span class="ident">cc_recipients</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.conversation_index"><code class="name">var <span class="ident">conversation_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.conversation_topic"><code class="name">var <span class="ident">conversation_topic</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.is_delivery_receipt_requested"><code class="name">var <span class="ident">is_delivery_receipt_requested</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.is_read"><code class="name">var <span class="ident">is_read</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.is_read_receipt_requested"><code class="name">var <span class="ident">is_read_receipt_requested</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.is_response_requested"><code class="name">var <span class="ident">is_response_requested</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.message_id"><code class="name">var <span class="ident">message_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.received_by"><code class="name">var <span class="ident">received_by</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.received_representing"><code class="name">var <span class="ident">received_representing</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.references"><code class="name">var <span class="ident">references</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.reminder_message_data"><code class="name">var <span class="ident">reminder_message_data</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.reply_to"><code class="name">var <span class="ident">reply_to</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.sender"><code class="name">var <span class="ident">sender</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.to_recipients"><code class="name">var <span class="ident">to_recipients</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Message.create_reply"><code class="name flex">
<span>def <span class="ident">create_reply</span></span>(<span>self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None, author=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_id
def create_reply(self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None, author=None):
    if not to_recipients:
        if not self.author:
            raise ValueError(&#34;&#39;to_recipients&#39; must be set when message has no &#39;author&#39;&#34;)
        to_recipients = [self.author]
    return ReplyToItem(
        account=self.account,
        reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
        subject=subject,
        new_body=body,
        to_recipients=to_recipients,
        cc_recipients=cc_recipients,
        bcc_recipients=bcc_recipients,
        author=author,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.create_reply_all"><code class="name flex">
<span>def <span class="ident">create_reply_all</span></span>(<span>self, subject, body, author=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_id
def create_reply_all(self, subject, body, author=None):
    me = MailboxField().clean(self.account.primary_smtp_address.lower())
    to_recipients = set(self.to_recipients or [])
    to_recipients.discard(me)
    cc_recipients = set(self.cc_recipients or [])
    cc_recipients.discard(me)
    bcc_recipients = set(self.bcc_recipients or [])
    bcc_recipients.discard(me)
    if self.author:
        to_recipients.add(self.author)
    return ReplyAllToItem(
        account=self.account,
        reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
        subject=subject,
        new_body=body,
        to_recipients=list(to_recipients),
        cc_recipients=list(cc_recipients),
        bcc_recipients=list(bcc_recipients),
        author=author,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.mark_as_junk"><code class="name flex">
<span>def <span class="ident">mark_as_junk</span></span>(<span>self, is_junk=True, move_item=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Mark or un-marks items as junk email.</p>
<p>:param is_junk: If True, the sender will be added from the blocked sender list. Otherwise, the sender will be
removed.
:param move_item: If true, the item will be moved to the junk folder.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_as_junk(self, is_junk=True, move_item=True):
    &#34;&#34;&#34;Mark or un-marks items as junk email.

    :param is_junk: If True, the sender will be added from the blocked sender list. Otherwise, the sender will be
    removed.
    :param move_item: If true, the item will be moved to the junk folder.
    :return:
    &#34;&#34;&#34;
    from ..services import MarkAsJunk

    res = MarkAsJunk(account=self.account).get(
        items=[self], is_junk=is_junk, move_item=move_item, expect_result=None
    )
    if res is None:
        return
    self.folder = self.account.junk if is_junk else self.account.inbox
    self.id, self.changekey = res</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.reply"><code class="name flex">
<span>def <span class="ident">reply</span></span>(<span>self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None, author=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reply(self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None, author=None):
    return self.create_reply(subject, body, to_recipients, cc_recipients, bcc_recipients, author).send()</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.reply_all"><code class="name flex">
<span>def <span class="ident">reply_all</span></span>(<span>self, subject, body, author=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reply_all(self, subject, body, author=None):
    return self.create_reply_all(subject, body, author).send()</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, save_copy=True, copy_to_folder=None, conflict_resolution='AutoResolve', send_meeting_invitations='SendToNone')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_account
def send(
    self,
    save_copy=True,
    copy_to_folder=None,
    conflict_resolution=AUTO_RESOLVE,
    send_meeting_invitations=SEND_TO_NONE,
):
    from ..services import SendItem

    # Only sends a message. The message can either be an existing draft stored in EWS or a new message that does
    # not yet exist in EWS.
    if copy_to_folder and not save_copy:
        raise AttributeError(&#34;&#39;save_copy&#39; must be True when &#39;copy_to_folder&#39; is set&#34;)
    if save_copy and not copy_to_folder:
        copy_to_folder = self.account.sent  # &#39;Sent&#39; is default EWS behaviour
    if self.id:
        SendItem(account=self.account).get(items=[self], saved_item_folder=copy_to_folder)
        # The item will be deleted from the original folder
        self._id = None
        self.folder = copy_to_folder
        return None

    # New message
    if copy_to_folder:
        # This would better be done via send_and_save() but let&#39;s just support it here
        self.folder = copy_to_folder
        return self.send_and_save(
            conflict_resolution=conflict_resolution, send_meeting_invitations=send_meeting_invitations
        )

    if self.account.version.build &lt; EXCHANGE_2013 and self.attachments:
        # At least some versions prior to Exchange 2013 can&#39;t send attachments immediately. You need to first save,
        # then attach, then send. This is done in send_and_save(). send() will delete the item again.
        self.send_and_save(
            conflict_resolution=conflict_resolution, send_meeting_invitations=send_meeting_invitations
        )
        return None

    self._create(message_disposition=SEND_ONLY, send_meeting_invitations=send_meeting_invitations)
    return None</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.send_and_save"><code class="name flex">
<span>def <span class="ident">send_and_save</span></span>(<span>self, update_fields=None, conflict_resolution='AutoResolve', send_meeting_invitations='SendToNone')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_and_save(
    self, update_fields=None, conflict_resolution=AUTO_RESOLVE, send_meeting_invitations=SEND_TO_NONE
):
    # Sends Message and saves a copy in the parent folder. Does not return an ItemId.
    if self.id:
        return self._update(
            update_fieldnames=update_fields,
            message_disposition=SEND_AND_SAVE_COPY,
            conflict_resolution=conflict_resolution,
            send_meeting_invitations=send_meeting_invitations,
        )
    if self.account.version.build &lt; EXCHANGE_2013 and self.attachments:
        # At least some versions prior to Exchange 2013 can&#39;t send-and-save attachments immediately. You need
        # to first save, then attach, then send. This is done in save().
        self.save(
            update_fields=update_fields,
            conflict_resolution=conflict_resolution,
            send_meeting_invitations=send_meeting_invitations,
        )
        return self.send(
            save_copy=False,
            conflict_resolution=conflict_resolution,
            send_meeting_invitations=send_meeting_invitations,
        )
    return self._create(message_disposition=SEND_AND_SAVE_COPY, send_meeting_invitations=send_meeting_invitations)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.NoVerifyHTTPAdapter"><code class="flex name class">
<span>class <span class="ident">NoVerifyHTTPAdapter</span></span>
<span>(</span><span>pool_connections=10, pool_maxsize=10, max_retries=0, pool_block=False)</span>
</code></dt>
<dd>
<div class="desc"><p>An HTTP adapter that ignores TLS validation errors. Use at own risk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoVerifyHTTPAdapter(requests.adapters.HTTPAdapter):
    &#34;&#34;&#34;An HTTP adapter that ignores TLS validation errors. Use at own risk.&#34;&#34;&#34;

    def cert_verify(self, conn, url, verify, cert):
        # pylint: disable=unused-argument
        # We&#39;re overriding a method, so we have to keep the signature
        super().cert_verify(conn=conn, url=url, verify=False, cert=cert)

    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):
        # pylint: disable=unused-argument
        # Required for requests &gt;= 2.32.3
        # See: https://github.com/psf/requests/pull/6710
        return super().get_connection_with_tls_context(request=request, verify=False, proxies=proxies, cert=cert)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>requests.adapters.HTTPAdapter</li>
<li>requests.adapters.BaseAdapter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.NoVerifyHTTPAdapter.cert_verify"><code class="name flex">
<span>def <span class="ident">cert_verify</span></span>(<span>self, conn, url, verify, cert)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify a SSL certificate. This method should not be called from user
code, and is only exposed for use when subclassing the
:class:<code>HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;</code>.</p>
<p>:param conn: The urllib3 connection object associated with the cert.
:param url: The requested URL.
:param verify: Either a boolean, in which case it controls whether we verify
the server's TLS certificate, or a string, in which case it must be a path
to a CA bundle to use
:param cert: The SSL certificate to verify.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cert_verify(self, conn, url, verify, cert):
    # pylint: disable=unused-argument
    # We&#39;re overriding a method, so we have to keep the signature
    super().cert_verify(conn=conn, url=url, verify=False, cert=cert)</code></pre>
</details>
</dd>
<dt id="exchangelib.NoVerifyHTTPAdapter.get_connection_with_tls_context"><code class="name flex">
<span>def <span class="ident">get_connection_with_tls_context</span></span>(<span>self, request, verify, proxies=None, cert=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):
    # pylint: disable=unused-argument
    # Required for requests &gt;= 2.32.3
    # See: https://github.com/psf/requests/pull/6710
    return super().get_connection_with_tls_context(request=request, verify=False, proxies=proxies, cert=cert)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.O365InteractiveConfiguration"><code class="flex name class">
<span>class <span class="ident">O365InteractiveConfiguration</span></span>
<span>(</span><span>client_id, username)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains information needed to create an authenticated connection to an EWS endpoint.</p>
<p>The 'credentials' argument contains the credentials needed to authenticate with the server. Multiple credentials
implementations are available in 'exchangelib.credentials'.</p>
<p>config = Configuration(credentials=Credentials('john@example.com', 'MY_SECRET'), &hellip;)</p>
<p>The 'server' and 'service_endpoint' arguments are mutually exclusive. The former must contain only a domain name,
the latter a full URL:</p>
<pre><code>config = Configuration(server='example.com', ...)
config = Configuration(service_endpoint='https://mail.example.com/EWS/Exchange.asmx', ...)
</code></pre>
<p>If you know which authentication type the server uses, you add that as a hint in 'auth_type'. Likewise, you can
add the server version as a hint. This allows to skip the auth type and version guessing routines:</p>
<pre><code>config = Configuration(auth_type=NTLM, ...)
config = Configuration(version=Version(build=Build(15, 1, 2, 3)), ...)
</code></pre>
<p>You can use 'retry_policy' to define a custom retry policy for handling server connection failures:</p>
<pre><code>config = Configuration(retry_policy=FaultTolerance(max_wait=3600), ...)
</code></pre>
<p>'max_connections' defines the max number of connections allowed for this server. This may be restricted by
policies on the Exchange server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class O365InteractiveConfiguration(Configuration):
    SERVER = &#34;outlook.office365.com&#34;

    def __init__(self, client_id, username):
        credentials = O365InteractiveCredentials(client_id=client_id, username=username)
        super().__init__(server=self.SERVER, auth_type=OAUTH2, credentials=credentials)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.configuration.Configuration" href="configuration.html#exchangelib.configuration.Configuration">Configuration</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.O365InteractiveConfiguration.SERVER"><code class="name">var <span class="ident">SERVER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="exchangelib.OAuth2AuthorizationCodeCredentials"><code class="flex name class">
<span>class <span class="ident">OAuth2AuthorizationCodeCredentials</span></span>
<span>(</span><span>authorization_code=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Login info for OAuth 2.0 authentication using the authorization code grant type. This can be used in one of
several ways:
* Given an authorization code, client ID, and client secret, fetch a token ourselves and refresh it as needed if
supplied with a refresh token.
* Given an existing access token, client ID, and client secret, use the access token until it expires and then
refresh it as needed.
* Given only an existing access token, use it until it expires. This can be used to let the calling application
refresh tokens itself by subclassing and implementing refresh().</p>
<p>Unlike the base (client credentials) grant, authorization code credentials don't require a Microsoft tenant ID
because each access token (and the authorization code used to get the access token) is restricted to a single
tenant.</p>
<p>:param authorization_code: Code obtained when authorizing the application to access an account. In combination
with client_id and client_secret, will be used to obtain an access token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OAuth2AuthorizationCodeCredentials(BaseOAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 authentication using the authorization code grant type. This can be used in one of
    several ways:
    * Given an authorization code, client ID, and client secret, fetch a token ourselves and refresh it as needed if
      supplied with a refresh token.
    * Given an existing access token, client ID, and client secret, use the access token until it expires and then
      refresh it as needed.
    * Given only an existing access token, use it until it expires. This can be used to let the calling application
      refresh tokens itself by subclassing and implementing refresh().

    Unlike the base (client credentials) grant, authorization code credentials don&#39;t require a Microsoft tenant ID
    because each access token (and the authorization code used to get the access token) is restricted to a single
    tenant.
    &#34;&#34;&#34;

    def __init__(self, authorization_code=None, **kwargs):
        &#34;&#34;&#34;

        :param authorization_code: Code obtained when authorizing the application to access an account. In combination
          with client_id and client_secret, will be used to obtain an access token.
        &#34;&#34;&#34;
        for attr in (&#34;client_id&#34;, &#34;client_secret&#34;):
            # Allow omitting these kwargs
            kwargs[attr] = kwargs.pop(attr, None)
        super().__init__(**kwargs)
        self.authorization_code = authorization_code

    @property
    def scope(self):
        res = super().scope
        res.append(&#34;offline_access&#34;)
        return res

    def token_params(self):
        res = super().token_params()
        res[&#34;code&#34;] = self.authorization_code  # Auth code may be None
        self.authorization_code = None  # We can only use the code once
        return res

    @threaded_cached_property
    def client(self):
        return oauthlib.oauth2.WebApplicationClient(client_id=self.client_id)

    def __repr__(self):
        return self.__class__.__name__ + repr(
            (self.client_id, &#34;[client_secret]&#34;, &#34;[authorization_code]&#34;, &#34;[access_token]&#34;)
        )

    def __str__(self):
        client_id = self.client_id
        credential = (
            &#34;[access_token]&#34;
            if self.access_token is not None
            else (&#34;[authorization_code]&#34; if self.authorization_code is not None else None)
        )
        description = &#34; &#34;.join(filter(None, [client_id, credential]))
        return description or &#34;[underspecified credentials]&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseOAuth2Credentials" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></li>
<li><a title="exchangelib.credentials.BaseCredentials" href="credentials.html#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.O365InteractiveCredentials" href="credentials.html#exchangelib.credentials.O365InteractiveCredentials">O365InteractiveCredentials</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.BaseOAuth2Credentials" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.client" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.client">client</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed">on_token_auto_refreshed</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.refresh" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.refresh">refresh</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.scope" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.scope">scope</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.session_params" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.session_params">session_params</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.token_params" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.token_params">token_params</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.token_url" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.token_url">token_url</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.OAuth2Credentials"><code class="flex name class">
<span>class <span class="ident">OAuth2Credentials</span></span>
<span>(</span><span>client_id, client_secret, tenant_id=None, identity=None, access_token=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Login info for OAuth 2.0 client credentials authentication, as well as a base for other OAuth 2.0 grant types.</p>
<p>This is primarily useful for in-house applications accessing data from a single Microsoft account. For applications
that will access multiple tenants' data, the client credentials flow does not give the application enough
information to restrict end users' access to the appropriate account. Use OAuth2AuthorizationCodeCredentials and
the associated auth code grant type for multi-tenant applications.</p>
<p>:param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
:param client_secret: Secret associated with the OAuth application
:param tenant_id: Microsoft tenant ID of the account to access
:param identity: An Identity object representing the account that these credentials are connected to.
:param access_token: Previously-obtained access token, as a dict or an oauthlib.oauth2.OAuth2Token</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OAuth2Credentials(BaseOAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 client credentials authentication, as well as a base for other OAuth 2.0 grant types.

    This is primarily useful for in-house applications accessing data from a single Microsoft account. For applications
    that will access multiple tenants&#39; data, the client credentials flow does not give the application enough
    information to restrict end users&#39; access to the appropriate account. Use OAuth2AuthorizationCodeCredentials and
    the associated auth code grant type for multi-tenant applications.
    &#34;&#34;&#34;

    @threaded_cached_property
    def client(self):
        return oauthlib.oauth2.BackendApplicationClient(client_id=self.client_id)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseOAuth2Credentials" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></li>
<li><a title="exchangelib.credentials.BaseCredentials" href="credentials.html#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.OAuth2LegacyCredentials" href="credentials.html#exchangelib.credentials.OAuth2LegacyCredentials">OAuth2LegacyCredentials</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.BaseOAuth2Credentials" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.client" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.client">client</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed">on_token_auto_refreshed</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.refresh" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.refresh">refresh</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.scope" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.scope">scope</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.session_params" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.session_params">session_params</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.token_params" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.token_params">token_params</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.token_url" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.token_url">token_url</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.OAuth2LegacyCredentials"><code class="flex name class">
<span>class <span class="ident">OAuth2LegacyCredentials</span></span>
<span>(</span><span>username, password, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Login info for OAuth 2.0 authentication using delegated permissions and application permissions.</p>
<p>This requires the app to acquire username and password from the user and pass that when requesting authentication
tokens for the given user. This allows the app to act as the signed-in user.</p>
<p>:param username: The username of the user to act as
:param password: The password of the user to act as</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OAuth2LegacyCredentials(OAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 authentication using delegated permissions and application permissions.

    This requires the app to acquire username and password from the user and pass that when requesting authentication
    tokens for the given user. This allows the app to act as the signed-in user.
    &#34;&#34;&#34;

    def __init__(self, username, password, **kwargs):
        &#34;&#34;&#34;
        :param username: The username of the user to act as
        :param password: The password of the user to act as
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.username = username
        self.password = password

    def token_params(self):
        res = super().token_params()
        res.update(
            {
                &#34;username&#34;: self.username,
                &#34;password&#34;: self.password,
            }
        )
        return res

    @threaded_cached_property
    def client(self):
        return oauthlib.oauth2.LegacyApplicationClient(client_id=self.client_id)

    @property
    def scope(self):
        return [&#34;https://outlook.office365.com/EWS.AccessAsUser.All&#34;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.OAuth2Credentials" href="credentials.html#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></li>
<li><a title="exchangelib.credentials.BaseOAuth2Credentials" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></li>
<li><a title="exchangelib.credentials.BaseCredentials" href="credentials.html#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.OAuth2Credentials" href="credentials.html#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.OAuth2Credentials.token_params" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.token_params">token_params</a></code></li>
</ul>
</li>
<li><code><b><a title="exchangelib.credentials.OAuth2Credentials" href="credentials.html#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.OAuth2Credentials.on_token_auto_refreshed" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed">on_token_auto_refreshed</a></code></li>
<li><code><a title="exchangelib.credentials.OAuth2Credentials.refresh" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.refresh">refresh</a></code></li>
<li><code><a title="exchangelib.credentials.OAuth2Credentials.scope" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.scope">scope</a></code></li>
<li><code><a title="exchangelib.credentials.OAuth2Credentials.session_params" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.session_params">session_params</a></code></li>
<li><code><a title="exchangelib.credentials.OAuth2Credentials.token_url" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.token_url">token_url</a></code></li>
</ul>
</li>
<li><code><b><a title="exchangelib.credentials.BaseOAuth2Credentials" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.client" href="credentials.html#exchangelib.credentials.BaseOAuth2Credentials.client">client</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.OofSettings"><code class="flex name class">
<span>class <span class="ident">OofSettings</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/oofsettings">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/oofsettings</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OofSettings(EWSElement):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/oofsettings&#34;&#34;&#34;

    ELEMENT_NAME = &#34;OofSettings&#34;
    REQUEST_ELEMENT_NAME = &#34;UserOofSettings&#34;

    ENABLED = &#34;Enabled&#34;
    SCHEDULED = &#34;Scheduled&#34;
    DISABLED = &#34;Disabled&#34;
    STATE_CHOICES = (ENABLED, SCHEDULED, DISABLED)

    state = ChoiceField(field_uri=&#34;OofState&#34;, is_required=True, choices={Choice(c) for c in STATE_CHOICES})
    external_audience = ChoiceField(
        field_uri=&#34;ExternalAudience&#34;, choices={Choice(&#34;None&#34;), Choice(&#34;Known&#34;), Choice(&#34;All&#34;)}, default=&#34;All&#34;
    )
    start = DateTimeField(field_uri=&#34;StartTime&#34;)
    end = DateTimeField(field_uri=&#34;EndTime&#34;)
    internal_reply = MessageField(field_uri=&#34;InternalReply&#34;)
    external_reply = MessageField(field_uri=&#34;ExternalReply&#34;)

    def clean(self, version=None):
        super().clean(version=version)
        if self.state == self.SCHEDULED:
            if not self.start or not self.end:
                raise ValueError(f&#34;&#39;start&#39; and &#39;end&#39; must be set when state is {self.SCHEDULED!r}&#34;)
            if self.start &gt;= self.end:
                raise ValueError(&#34;&#39;start&#39; must be before &#39;end&#39;&#34;)
            if self.end &lt; datetime.datetime.now(tz=UTC):
                raise ValueError(&#34;&#39;end&#39; must be in the future&#34;)
        if self.state != self.DISABLED and (not self.internal_reply or not self.external_reply):
            raise ValueError(f&#34;&#39;internal_reply&#39; and &#39;external_reply&#39; must be set when state is not {self.DISABLED!r}&#34;)

    @classmethod
    def from_xml(cls, elem, account):
        kwargs = {}
        for attr in (&#34;state&#34;, &#34;external_audience&#34;, &#34;internal_reply&#34;, &#34;external_reply&#34;):
            f = cls.get_field_by_fieldname(attr)
            kwargs[attr] = f.from_xml(elem=elem, account=account)
        kwargs.update(OutOfOffice.duration_to_start_end(elem=elem, account=account))
        cls._clear(elem)
        return cls(**kwargs)

    def to_xml(self, version):
        self.clean(version=version)
        elem = create_element(f&#34;t:{self.REQUEST_ELEMENT_NAME}&#34;)
        for attr in (&#34;state&#34;, &#34;external_audience&#34;):
            value = getattr(self, attr)
            f = self.get_field_by_fieldname(attr)
            set_xml_value(elem, f.to_xml(value, version=version))
        if self.start or self.end:
            duration = create_element(&#34;t:Duration&#34;)
            if self.start:
                f = self.get_field_by_fieldname(&#34;start&#34;)
                set_xml_value(duration, f.to_xml(self.start, version=version))
            if self.end:
                f = self.get_field_by_fieldname(&#34;end&#34;)
                set_xml_value(duration, f.to_xml(self.end, version=version))
            elem.append(duration)
        for attr in (&#34;internal_reply&#34;, &#34;external_reply&#34;):
            value = getattr(self, attr)
            if value is None:
                value = &#34;&#34;  # The value can be empty, but the XML element must always be present
            f = self.get_field_by_fieldname(attr)
            set_xml_value(elem, f.to_xml(value, version=version))
        return elem

    def __hash__(self):
        # Customize comparison
        if self.state == self.DISABLED:
            # All values except state are ignored by the server
            relevant_attrs = (&#34;state&#34;,)
        elif self.state != self.SCHEDULED:
            # &#39;start&#39; and &#39;end&#39; values are ignored by the server, and the server always returns today&#39;s date
            relevant_attrs = tuple(f.name for f in self.FIELDS if f.name not in (&#34;start&#34;, &#34;end&#34;))
        else:
            relevant_attrs = tuple(f.name for f in self.FIELDS)
        return hash(tuple(getattr(self, attr) for attr in relevant_attrs))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.OofSettings.DISABLED"><code class="name">var <span class="ident">DISABLED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.ENABLED"><code class="name">var <span class="ident">ENABLED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.REQUEST_ELEMENT_NAME"><code class="name">var <span class="ident">REQUEST_ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.SCHEDULED"><code class="name">var <span class="ident">SCHEDULED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.STATE_CHOICES"><code class="name">var <span class="ident">STATE_CHOICES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.OofSettings.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    kwargs = {}
    for attr in (&#34;state&#34;, &#34;external_audience&#34;, &#34;internal_reply&#34;, &#34;external_reply&#34;):
        f = cls.get_field_by_fieldname(attr)
        kwargs[attr] = f.from_xml(elem=elem, account=account)
    kwargs.update(OutOfOffice.duration_to_start_end(elem=elem, account=account))
    cls._clear(elem)
    return cls(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.OofSettings.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.external_audience"><code class="name">var <span class="ident">external_audience</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.external_reply"><code class="name">var <span class="ident">external_reply</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.internal_reply"><code class="name">var <span class="ident">internal_reply</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.start"><code class="name">var <span class="ident">start</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.OofSettings.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    super().clean(version=version)
    if self.state == self.SCHEDULED:
        if not self.start or not self.end:
            raise ValueError(f&#34;&#39;start&#39; and &#39;end&#39; must be set when state is {self.SCHEDULED!r}&#34;)
        if self.start &gt;= self.end:
            raise ValueError(&#34;&#39;start&#39; must be before &#39;end&#39;&#34;)
        if self.end &lt; datetime.datetime.now(tz=UTC):
            raise ValueError(&#34;&#39;end&#39; must be in the future&#34;)
    if self.state != self.DISABLED and (not self.internal_reply or not self.external_reply):
        raise ValueError(f&#34;&#39;internal_reply&#39; and &#39;external_reply&#39; must be set when state is not {self.DISABLED!r}&#34;)</code></pre>
</details>
</dd>
<dt id="exchangelib.OofSettings.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self, version):
    self.clean(version=version)
    elem = create_element(f&#34;t:{self.REQUEST_ELEMENT_NAME}&#34;)
    for attr in (&#34;state&#34;, &#34;external_audience&#34;):
        value = getattr(self, attr)
        f = self.get_field_by_fieldname(attr)
        set_xml_value(elem, f.to_xml(value, version=version))
    if self.start or self.end:
        duration = create_element(&#34;t:Duration&#34;)
        if self.start:
            f = self.get_field_by_fieldname(&#34;start&#34;)
            set_xml_value(duration, f.to_xml(self.start, version=version))
        if self.end:
            f = self.get_field_by_fieldname(&#34;end&#34;)
            set_xml_value(duration, f.to_xml(self.end, version=version))
        elem.append(duration)
    for attr in (&#34;internal_reply&#34;, &#34;external_reply&#34;):
        value = getattr(self, attr)
        if value is None:
            value = &#34;&#34;  # The value can be empty, but the XML element must always be present
        f = self.get_field_by_fieldname(attr)
        set_xml_value(elem, f.to_xml(value, version=version))
    return elem</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.EWSElement.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.PostItem"><code class="flex name class">
<span>class <span class="ident">PostItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/postitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/postitem</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PostItem(Item):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/postitem&#34;&#34;&#34;

    ELEMENT_NAME = &#34;PostItem&#34;

    conversation_index = Message.FIELDS[&#34;conversation_index&#34;]
    conversation_topic = Message.FIELDS[&#34;conversation_topic&#34;]

    author = Message.FIELDS[&#34;author&#34;]
    message_id = Message.FIELDS[&#34;message_id&#34;]
    is_read = Message.FIELDS[&#34;is_read&#34;]

    posted_time = DateTimeField(field_uri=&#34;postitem:PostedTime&#34;, is_read_only=True)
    references = TextField(field_uri=&#34;message:References&#34;)
    sender = MailboxField(field_uri=&#34;message:Sender&#34;, is_read_only=True, is_read_only_after_send=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.PostItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.PostItem.author"><code class="name">var <span class="ident">author</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.conversation_index"><code class="name">var <span class="ident">conversation_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.conversation_topic"><code class="name">var <span class="ident">conversation_topic</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.is_read"><code class="name">var <span class="ident">is_read</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.message_id"><code class="name">var <span class="ident">message_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.posted_time"><code class="name">var <span class="ident">posted_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.references"><code class="name">var <span class="ident">references</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.sender"><code class="name">var <span class="ident">sender</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.PostReplyItem"><code class="flex name class">
<span>class <span class="ident">PostReplyItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/postreplyitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/postreplyitem</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PostReplyItem(Item):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/postreplyitem&#34;&#34;&#34;

    ELEMENT_NAME = &#34;PostReplyItem&#34;

    # This element only has Item fields up to, and including, &#39;culture&#39;
    # TDO: Plus all message fields
    new_body = BodyField(field_uri=&#34;NewBodyContent&#34;)  # Accepts and returns Body or HTMLBody instances

    culture_idx = Item.FIELDS.index_by_name(&#34;culture&#34;)
    sender_idx = Message.FIELDS.index_by_name(&#34;sender&#34;)
    FIELDS = Item.FIELDS[: culture_idx + 1] + Message.FIELDS[sender_idx:]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.PostReplyItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.culture_idx"><code class="name">var <span class="ident">culture_idx</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.sender_idx"><code class="name">var <span class="ident">sender_idx</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.PostReplyItem.author"><code class="name">var <span class="ident">author</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.bcc_recipients"><code class="name">var <span class="ident">bcc_recipients</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.cc_recipients"><code class="name">var <span class="ident">cc_recipients</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.conversation_index"><code class="name">var <span class="ident">conversation_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.conversation_topic"><code class="name">var <span class="ident">conversation_topic</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.is_delivery_receipt_requested"><code class="name">var <span class="ident">is_delivery_receipt_requested</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.is_read"><code class="name">var <span class="ident">is_read</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.is_read_receipt_requested"><code class="name">var <span class="ident">is_read_receipt_requested</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.is_response_requested"><code class="name">var <span class="ident">is_response_requested</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.message_id"><code class="name">var <span class="ident">message_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.new_body"><code class="name">var <span class="ident">new_body</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.received_by"><code class="name">var <span class="ident">received_by</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.received_representing"><code class="name">var <span class="ident">received_representing</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.references"><code class="name">var <span class="ident">references</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.reminder_message_data"><code class="name">var <span class="ident">reminder_message_data</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.reply_to"><code class="name">var <span class="ident">reply_to</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.sender"><code class="name">var <span class="ident">sender</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostReplyItem.to_recipients"><code class="name">var <span class="ident">to_recipients</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Q"><code class="flex name class">
<span>class <span class="ident">Q</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A class with an API similar to Django Q objects. Used to implement advanced filtering logic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Q:
    &#34;&#34;&#34;A class with an API similar to Django Q objects. Used to implement advanced filtering logic.&#34;&#34;&#34;

    # Connection types
    AND = &#34;AND&#34;
    OR = &#34;OR&#34;
    NOT = &#34;NOT&#34;
    NEVER = &#34;NEVER&#34;  # This is not specified by EWS. We use it for queries that will never match, e.g. &#39;foo__in=()&#39;
    CONN_TYPES = {AND, OR, NOT, NEVER}

    # EWS Operators
    EQ = &#34;==&#34;
    NE = &#34;!=&#34;
    GT = &#34;&gt;&#34;
    GTE = &#34;&gt;=&#34;
    LT = &#34;&lt;&#34;
    LTE = &#34;&lt;=&#34;
    EXACT = &#34;exact&#34;
    IEXACT = &#34;iexact&#34;
    CONTAINS = &#34;contains&#34;
    ICONTAINS = &#34;icontains&#34;
    STARTSWITH = &#34;startswith&#34;
    ISTARTSWITH = &#34;istartswith&#34;
    EXISTS = &#34;exists&#34;
    OP_TYPES = {EQ, NE, GT, GTE, LT, LTE, EXACT, IEXACT, CONTAINS, ICONTAINS, STARTSWITH, ISTARTSWITH, EXISTS}
    CONTAINS_OPS = {EXACT, IEXACT, CONTAINS, ICONTAINS, STARTSWITH, ISTARTSWITH}

    # Valid lookups
    LOOKUP_RANGE = &#34;range&#34;
    LOOKUP_IN = &#34;in&#34;
    LOOKUP_NOT = &#34;not&#34;
    LOOKUP_GT = &#34;gt&#34;
    LOOKUP_GTE = &#34;gte&#34;
    LOOKUP_LT = &#34;lt&#34;
    LOOKUP_LTE = &#34;lte&#34;
    LOOKUP_EXACT = &#34;exact&#34;
    LOOKUP_IEXACT = &#34;iexact&#34;
    LOOKUP_CONTAINS = &#34;contains&#34;
    LOOKUP_ICONTAINS = &#34;icontains&#34;
    LOOKUP_STARTSWITH = &#34;startswith&#34;
    LOOKUP_ISTARTSWITH = &#34;istartswith&#34;
    LOOKUP_EXISTS = &#34;exists&#34;
    LOOKUP_TYPES = {
        LOOKUP_RANGE,
        LOOKUP_IN,
        LOOKUP_NOT,
        LOOKUP_GT,
        LOOKUP_GTE,
        LOOKUP_LT,
        LOOKUP_LTE,
        LOOKUP_EXACT,
        LOOKUP_IEXACT,
        LOOKUP_CONTAINS,
        LOOKUP_ICONTAINS,
        LOOKUP_STARTSWITH,
        LOOKUP_ISTARTSWITH,
        LOOKUP_EXISTS,
    }

    __slots__ = &#34;conn_type&#34;, &#34;field_path&#34;, &#34;op&#34;, &#34;value&#34;, &#34;children&#34;, &#34;query_string&#34;

    def __init__(self, *args, **kwargs):
        self.conn_type = kwargs.pop(&#34;conn_type&#34;, self.AND)

        self.field_path = None  # Name of the field we want to filter on
        self.op = None
        self.value = None
        self.query_string = None

        # Parsing of args and kwargs may require child elements
        self.children = []

        # Check for query string as the only argument
        if not kwargs and len(args) == 1 and isinstance(args[0], str):
            self.query_string = args[0]
            args = ()

        # Parse args which must now be Q objects
        for q in args:
            if not isinstance(q, self.__class__):
                raise TypeError(f&#34;Non-keyword arg {q!r} must be of type {Q}&#34;)
        self.children.extend(args)

        # Parse keyword args and extract the filter
        is_single_kwarg = not args and len(kwargs) == 1
        for key, value in kwargs.items():
            self.children.extend(self._get_children_from_kwarg(key=key, value=value, is_single_kwarg=is_single_kwarg))

        # Simplify this object
        self.reduce()

        # Final sanity check
        self._check_integrity()

    def _get_children_from_kwarg(self, key, value, is_single_kwarg=False):
        &#34;&#34;&#34;Generate Q objects corresponding to a single keyword argument. Make this a leaf if there are no children to
        generate.
        &#34;&#34;&#34;
        key_parts = key.rsplit(&#34;__&#34;, 1)
        if len(key_parts) == 2 and key_parts[1] in self.LOOKUP_TYPES:
            # This is a kwarg with a lookup at the end
            field_path, lookup = key_parts
            if lookup == self.LOOKUP_EXISTS:
                # value=True will fall through to further processing
                if not value:
                    return (~self.__class__(**{key: True}),)

            if lookup == self.LOOKUP_RANGE:
                # EWS doesn&#39;t have a &#39;range&#39; operator. Emulate &#39;foo__range=(1, 2)&#39; as &#39;foo__gte=1 and foo__lte=2&#39;
                # (both values inclusive).
                if len(value) != 2:
                    raise ValueError(f&#34;Value of lookup {key!r} must have exactly 2 elements&#34;)
                return (
                    self.__class__(**{f&#34;{field_path}__gte&#34;: value[0]}),
                    self.__class__(**{f&#34;{field_path}__lte&#34;: value[1]}),
                )

            # Filtering on list types is a bit quirky. The only lookup type I have found to work is:
            #
            #     item:Categories == &#39;foo&#39; AND item:Categories == &#39;bar&#39; AND ...
            #
            #     item:Categories == &#39;foo&#39; OR item:Categories == &#39;bar&#39; OR ...
            #
            # The former returns items that have all these categories, but maybe also others. The latter returns
            # items that have at least one of these categories. This translates to the &#39;contains&#39; and &#39;in&#39; lookups,
            # respectively. Both versions are case-insensitive.
            #
            # Exact matching and case-sensitive or partial-string matching is not possible since that requires the
            # &#39;Contains&#39; element which only supports matching on string elements, not arrays.
            #
            # Exact matching of categories (i.e. match [&#39;a&#39;, &#39;b&#39;] but not [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) could be implemented by
            # post-processing items by fetching the categories field unconditionally and removing the items that don&#39;t
            # have an exact match.
            if lookup == self.LOOKUP_IN:
                # EWS doesn&#39;t have an &#39;__in&#39; operator. Allow &#39;__in&#39; lookups on list and non-list field types,
                # specifying a list value. We&#39;ll emulate it as a set of OR&#39;ed exact matches.
                if not is_iterable(value, generators_allowed=True):
                    raise TypeError(f&#34;Value for lookup {key!r} must be of type {list}&#34;)
                children = tuple(self.__class__(**{field_path: v}) for v in value)
                if not children:
                    # This is an &#39;__in&#39; operator with an empty list as the value. We interpret it to mean &#34;is foo
                    # contained in the empty set?&#34; which is always false. Mark this Q object as such.
                    return (self.__class__(conn_type=self.NEVER),)
                return (self.__class__(*children, conn_type=self.OR),)

            if lookup == self.LOOKUP_CONTAINS and is_iterable(value, generators_allowed=True):
                # A &#39;__contains&#39; lookup with a list as the value ony makes sense for list fields, since exact match
                # on multiple distinct values will always fail for single-value fields.
                #
                # An empty list as value is allowed. We interpret it to mean &#34;are all values in the empty set contained
                # in foo?&#34; which is always true.
                children = tuple(self.__class__(**{field_path: v}) for v in value)
                return (self.__class__(*children, conn_type=self.AND),)

            try:
                op = self._lookup_to_op(lookup)
            except KeyError:
                raise ValueError(f&#34;Lookup {lookup!r} is not supported (called as &#39;{key}={value!r}&#39;)&#34;)
        else:
            field_path, op = key, self.EQ

        if not is_single_kwarg:
            return (self.__class__(**{key: value}),)

        # This is a single-kwarg Q object with a lookup that requires a single value. Make this a leaf
        self.field_path = field_path
        self.op = op
        self.value = value
        return ()

    def reduce(self):
        &#34;&#34;&#34;Simplify this object, if possible.&#34;&#34;&#34;
        self._reduce_children()
        self._promote()

    def _reduce_children(self):
        &#34;&#34;&#34;Look at the children of this object and remove unnecessary items.&#34;&#34;&#34;
        children = self.children
        if any((isinstance(a, self.__class__) and a.is_never()) for a in children):
            # We have at least one &#39;never&#39; arg
            if self.conn_type == self.AND:
                # Remove all other args since nothing we AND together with a &#39;never&#39; arg can change the result
                children = [self.__class__(conn_type=self.NEVER)]
            elif self.conn_type == self.OR:
                # Remove all &#39;never&#39; args because all other args will decide the result. Keep one &#39;never&#39; arg in case
                # all args are &#39;never&#39; args.
                children = [a for a in children if not (isinstance(a, self.__class__) and a.is_never())]
                if not children:
                    children = [self.__class__(conn_type=self.NEVER)]
            elif self.conn_type == self.NOT:
                # Let&#39;s interpret &#39;not never&#39; to mean &#39;always&#39;. Remove all &#39;never&#39; args
                children = [a for a in children if not (isinstance(a, self.__class__) and a.is_never())]

        # Remove any empty Q elements in args before proceeding
        children = [a for a in children if not (isinstance(a, self.__class__) and a.is_empty())]
        self.children = children

    def _promote(self):
        &#34;&#34;&#34;When we only have one child and no expression on ourselves, we are a no-op. Flatten by taking over the only
        child.
        &#34;&#34;&#34;
        if len(self.children) != 1 or self.field_path is not None or self.conn_type == self.NOT:
            return

        q = self.children[0]
        self.conn_type = q.conn_type
        self.field_path = q.field_path
        self.op = q.op
        self.value = q.value
        self.query_string = q.query_string
        self.children = q.children

    def clean(self, version):
        &#34;&#34;&#34;Do some basic checks on the attributes, using a generic folder. to_xml() does a good job of
        validating. There&#39;s no reason to replicate much of that here.
        &#34;&#34;&#34;
        from .folders import Folder

        self.to_xml(folders=[Folder()], version=version, applies_to=Restriction.ITEMS)

    @classmethod
    def _lookup_to_op(cls, lookup):
        return {
            cls.LOOKUP_NOT: cls.NE,
            cls.LOOKUP_GT: cls.GT,
            cls.LOOKUP_GTE: cls.GTE,
            cls.LOOKUP_LT: cls.LT,
            cls.LOOKUP_LTE: cls.LTE,
            cls.LOOKUP_EXACT: cls.EXACT,
            cls.LOOKUP_IEXACT: cls.IEXACT,
            cls.LOOKUP_CONTAINS: cls.CONTAINS,
            cls.LOOKUP_ICONTAINS: cls.ICONTAINS,
            cls.LOOKUP_STARTSWITH: cls.STARTSWITH,
            cls.LOOKUP_ISTARTSWITH: cls.ISTARTSWITH,
            cls.LOOKUP_EXISTS: cls.EXISTS,
        }[lookup]

    @classmethod
    def _conn_to_xml(cls, conn_type):
        xml_tag_map = {
            cls.AND: &#34;t:And&#34;,
            cls.OR: &#34;t:Or&#34;,
            cls.NOT: &#34;t:Not&#34;,
        }
        return create_element(xml_tag_map[conn_type])

    @classmethod
    def _op_to_xml(cls, op):
        xml_tag_map = {
            cls.EQ: &#34;t:IsEqualTo&#34;,
            cls.NE: &#34;t:IsNotEqualTo&#34;,
            cls.GTE: &#34;t:IsGreaterThanOrEqualTo&#34;,
            cls.LTE: &#34;t:IsLessThanOrEqualTo&#34;,
            cls.LT: &#34;t:IsLessThan&#34;,
            cls.GT: &#34;t:IsGreaterThan&#34;,
            cls.EXISTS: &#34;t:Exists&#34;,
        }
        if op in xml_tag_map:
            return create_element(xml_tag_map[op])
        valid_ops = cls.EXACT, cls.IEXACT, cls.CONTAINS, cls.ICONTAINS, cls.STARTSWITH, cls.ISTARTSWITH
        if op not in valid_ops:
            raise InvalidEnumValue(&#34;op&#34;, op, valid_ops)

        # For description of Contains attribute values, see
        #     https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/contains
        #
        # Possible ContainmentMode values:
        #     FullString, Prefixed, Substring, PrefixOnWords, ExactPhrase
        # Django lookups have no equivalent of PrefixOnWords and ExactPhrase (and I&#39;m unsure how they actually
        # work).
        #
        # EWS has no equivalent of &#39;__endswith&#39; or &#39;__iendswith&#39;. That could be emulated using &#39;__contains&#39; and
        # &#39;__icontains&#39; and filtering results afterwards in Python. But it could be inefficient because we might be
        # fetching and discarding a lot of non-matching items, plus we would need to always fetch the field we&#39;re
        # matching on, to be able to do the filtering. I think it&#39;s better to leave this to the consumer, i.e.:
        #
        # items = [i for i in fld.filter(subject__contains=suffix) if i.subject.endswith(suffix)]
        # items = [i for i in fld.filter(subject__icontains=suffix) if i.subject.lower().endswith(suffix.lower())]
        #
        # Possible ContainmentComparison values (there are more, but the rest are &#34;To be removed&#34;):
        #     Exact, IgnoreCase, IgnoreNonSpacingCharacters, IgnoreCaseAndNonSpacingCharacters
        # I&#39;m unsure about non-spacing characters, but as I read
        #    https://en.wikipedia.org/wiki/Graphic_character#Spacing_and_non-spacing_characters
        # we shouldn&#39;t ignore them (&#39;a&#39; would match both &#39;a&#39; and &#39;å&#39;, the latter having a non-spacing character).
        if op in {cls.EXACT, cls.IEXACT}:
            match_mode = &#34;FullString&#34;
        elif op in (cls.CONTAINS, cls.ICONTAINS):
            match_mode = &#34;Substring&#34;
        elif op in (cls.STARTSWITH, cls.ISTARTSWITH):
            match_mode = &#34;Prefixed&#34;
        else:
            raise ValueError(f&#34;Unsupported op: {op}&#34;)
        if op in (cls.IEXACT, cls.ICONTAINS, cls.ISTARTSWITH):
            compare_mode = &#34;IgnoreCase&#34;
        else:
            compare_mode = &#34;Exact&#34;
        return create_element(&#34;t:Contains&#34;, attrs=dict(ContainmentMode=match_mode, ContainmentComparison=compare_mode))

    def is_leaf(self):
        return not self.children

    def is_empty(self):
        &#34;&#34;&#34;Return True if this object is without any restrictions at all.&#34;&#34;&#34;
        return self.is_leaf() and self.field_path is None and self.query_string is None and self.conn_type != self.NEVER

    def is_never(self):
        &#34;&#34;&#34;Return True if this object has a restriction that will never match anything.&#34;&#34;&#34;
        return self.conn_type == self.NEVER

    def expr(self):
        if self.is_empty():
            return None
        if self.is_never():
            return self.NEVER
        if self.query_string:
            return self.query_string
        if self.is_leaf():
            expr = f&#34;{self.field_path} {self.op} {self.value!r}&#34;
        else:
            # Sort children by field name, so we get stable output (for easier testing). Children should never be empty.
            expr = f&#34; {self.AND if self.conn_type == self.NOT else self.conn_type} &#34;.join(
                (c.expr() if c.is_leaf() or c.conn_type == self.NOT else f&#34;({c.expr()})&#34;)
                for c in sorted(self.children, key=lambda i: i.field_path or &#34;&#34;)
            )
        if self.conn_type == self.NOT:
            # Add the NOT operator. Put children in parens if there is more than one child.
            if self.is_leaf() or len(self.children) == 1:
                return self.conn_type + f&#34; {expr}&#34;
            return self.conn_type + f&#34; ({expr})&#34;
        return expr

    def to_xml(self, folders, version, applies_to):
        if self.query_string:
            self._check_integrity()
            if version.build &lt; EXCHANGE_2010:
                raise NotImplementedError(&#34;QueryString filtering is only supported for Exchange 2010 servers and later&#34;)
            elem = create_element(&#34;m:QueryString&#34;)
            elem.text = self.query_string
            return elem
        # Translate this Q object to a valid Restriction XML tree
        elem = self.xml_elem(folders=folders, version=version, applies_to=applies_to)
        if elem is None:
            return None
        restriction = create_element(&#34;m:Restriction&#34;)
        restriction.append(elem)
        return restriction

    def _check_integrity(self):
        if self.is_empty():
            return
        if self.conn_type == self.NEVER:
            if any([self.field_path, self.op, self.value, self.children]):
                raise ValueError(&#34;&#39;never&#39; queries cannot be combined with other settings&#34;)
            return
        if self.query_string:
            if any([self.field_path, self.op, self.value, self.children]):
                raise ValueError(&#34;Query strings cannot be combined with other settings&#34;)
            return
        if self.conn_type not in self.CONN_TYPES:
            raise InvalidEnumValue(&#34;conn_type&#34;, self.conn_type, self.CONN_TYPES)
        if not self.is_leaf():
            for q in self.children:
                if q.query_string and len(self.children) &gt; 1:
                    raise ValueError(&#34;A query string cannot be combined with other restrictions&#34;)
            return
        if not self.field_path:
            raise ValueError(&#34;&#39;field_path&#39; must be set&#34;)
        if self.op not in self.OP_TYPES:
            raise InvalidEnumValue(&#34;op&#34;, self.op, self.OP_TYPES)
        if self.op == self.EXISTS and self.value is not True:
            raise ValueError(&#34;&#39;value&#39; must be True when operator is EXISTS&#34;)
        if self.value is None:
            raise ValueError(f&#34;Value for filter on field path {self.field_path!r} cannot be None&#34;)
        if is_iterable(self.value, generators_allowed=True):
            raise ValueError(
                f&#34;Value {self.value!r} for filter on field path {self.field_path!r} must be a single value&#34;
            )

    def _validate_field_path(self, field_path, folder, applies_to, version):
        from .indexed_properties import MultiFieldIndexedElement

        if applies_to == Restriction.FOLDERS:
            # This is a restriction on Folder fields
            folder.validate_field(field=field_path.field, version=version)
        else:
            folder.validate_item_field(field=field_path.field, version=version)
        if not field_path.field.is_searchable:
            raise ValueError(f&#34;EWS does not support filtering on field {field_path.field.name!r}&#34;)
        if field_path.subfield and not field_path.subfield.is_searchable:
            raise ValueError(f&#34;EWS does not support filtering on subfield {field_path.subfield.name!r}&#34;)
        if issubclass(field_path.field.value_cls, MultiFieldIndexedElement) and not field_path.subfield:
            raise ValueError(f&#34;Field path {self.field_path!r} must contain a subfield&#34;)

    def _get_field_path(self, folders, applies_to, version):
        # Convert the string field path to a real FieldPath object. The path is validated using the given folders.
        for folder in folders:
            try:
                if applies_to == Restriction.FOLDERS:
                    # This is a restriction on Folder fields
                    field = folder.get_field_by_fieldname(fieldname=self.field_path)
                    field_path = FieldPath(field=field)
                else:
                    field_path = FieldPath.from_string(field_path=self.field_path, folder=folder)
            except ValueError:
                continue
            self._validate_field_path(field_path=field_path, folder=folder, applies_to=applies_to, version=version)
            break
        else:
            raise InvalidField(f&#34;Unknown field path {self.field_path!r} on folders {folders}&#34;)
        return field_path

    def _get_clean_value(self, field_path, version):
        if self.op == self.EXISTS:
            return None
        clean_field = field_path.subfield if (field_path.subfield and field_path.label) else field_path.field
        if clean_field.is_list:
            # __contains and __in are implemented as multiple leaves, with one value per leaf. clean() on list fields
            # only works on lists, so clean a one-element list.
            return clean_field.clean(value=[self.value], version=version)[0]
        return clean_field.clean(value=self.value, version=version)

    def xml_elem(self, folders, version, applies_to):
        # Recursively build an XML tree structure of this Q object. If this is an empty leaf (the equivalent of Q()),
        # return None.
        from .indexed_properties import SingleFieldIndexedElement

        # Don&#39;t check self.value just yet. We want to return error messages on the field path first, and then the value.
        # This is done in _get_field_path() and _get_clean_value(), respectively.
        self._check_integrity()
        if self.is_empty():
            return None
        if self.is_never():
            raise ValueError(&#34;EWS does not support &#39;never&#39; queries&#34;)
        if self.is_leaf():
            elem = self._op_to_xml(self.op)
            field_path = self._get_field_path(folders, applies_to=applies_to, version=version)
            clean_value = self._get_clean_value(field_path=field_path, version=version)
            if issubclass(field_path.field.value_cls, SingleFieldIndexedElement) and not field_path.label:
                # We allow a filter shortcut of e.g. email_addresses__contains=EmailAddress(label=&#39;Foo&#39;, ...) instead of
                # email_addresses__Foo_email_address=.... Set FieldPath label now, so we can generate the field_uri.
                field_path.label = clean_value.label
            elif isinstance(field_path.field, DateTimeBackedDateField):
                # We need to convert to datetime
                clean_value = field_path.field.date_to_datetime(clean_value)
            elem.append(field_path.to_xml())
            if self.op != self.EXISTS:
                constant = create_element(&#34;t:Constant&#34;, attrs=dict(Value=value_to_xml_text(clean_value)))
                if self.op in self.CONTAINS_OPS:
                    elem.append(constant)
                else:
                    uriorconst = create_element(&#34;t:FieldURIOrConstant&#34;)
                    uriorconst.append(constant)
                    elem.append(uriorconst)
        elif len(self.children) == 1:
            # We have only one child
            elem = self.children[0].xml_elem(folders=folders, version=version, applies_to=applies_to)
        else:
            # We have multiple children. If conn_type is NOT, then group children with AND. We&#39;ll add the NOT later
            elem = self._conn_to_xml(self.AND if self.conn_type == self.NOT else self.conn_type)
            # Sort children by field name, so we get stable output (for easier testing). Children should never be empty
            for c in sorted(self.children, key=lambda i: i.field_path or &#34;&#34;):
                elem.append(c.xml_elem(folders=folders, version=version, applies_to=applies_to))
        if elem is None:
            return None  # Should not be necessary, but play safe
        if self.conn_type == self.NOT:
            # Encapsulate everything in the NOT element
            not_elem = self._conn_to_xml(self.conn_type)
            not_elem.append(elem)
            return not_elem
        return elem

    def __and__(self, other):
        # &amp; operator. Return a new Q with two children and conn_type AND
        return self.__class__(self, other, conn_type=self.AND)

    def __or__(self, other):
        # | operator. Return a new Q with two children and conn_type OR
        return self.__class__(self, other, conn_type=self.OR)

    def __invert__(self):
        # ~ operator. If op has an inverse, change op. Else return a new Q with conn_type NOT
        if self.conn_type == self.NOT:
            # This is &#39;NOT NOT&#39;. Change to &#39;AND&#39;
            new = copy(self)
            new.conn_type = self.AND
            new.reduce()
            return new
        if self.is_leaf():
            inverse_ops = {
                self.EQ: self.NE,
                self.NE: self.EQ,
                self.GT: self.LTE,
                self.GTE: self.LT,
                self.LT: self.GTE,
                self.LTE: self.GT,
            }
            with suppress(KeyError):
                new = copy(self)
                new.op = inverse_ops[self.op]
                new.reduce()
                return new
        return self.__class__(self, conn_type=self.NOT)

    def __eq__(self, other):
        return repr(self) == repr(other)

    def __hash__(self):
        return hash(repr(self))

    def __str__(self):
        return self.expr() or &#34;Q()&#34;

    def __repr__(self):
        if self.is_leaf():
            if self.query_string:
                return self.__class__.__name__ + f&#34;({self.query_string!r})&#34;
            if self.is_never():
                return self.__class__.__name__ + f&#34;(conn_type={self.conn_type!r})&#34;
            return self.__class__.__name__ + f&#34;({self.field_path} {self.op} {self.value!r})&#34;
        sorted_children = tuple(sorted(self.children, key=lambda i: i.field_path or &#34;&#34;))
        if self.conn_type == self.NOT or len(self.children) &gt; 1:
            return self.__class__.__name__ + repr((self.conn_type,) + sorted_children)
        return self.__class__.__name__ + repr(sorted_children)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Q.AND"><code class="name">var <span class="ident">AND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.CONN_TYPES"><code class="name">var <span class="ident">CONN_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.CONTAINS"><code class="name">var <span class="ident">CONTAINS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.CONTAINS_OPS"><code class="name">var <span class="ident">CONTAINS_OPS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.EQ"><code class="name">var <span class="ident">EQ</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.EXACT"><code class="name">var <span class="ident">EXACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.EXISTS"><code class="name">var <span class="ident">EXISTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.GT"><code class="name">var <span class="ident">GT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.GTE"><code class="name">var <span class="ident">GTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.ICONTAINS"><code class="name">var <span class="ident">ICONTAINS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.IEXACT"><code class="name">var <span class="ident">IEXACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.ISTARTSWITH"><code class="name">var <span class="ident">ISTARTSWITH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_CONTAINS"><code class="name">var <span class="ident">LOOKUP_CONTAINS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_EXACT"><code class="name">var <span class="ident">LOOKUP_EXACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_EXISTS"><code class="name">var <span class="ident">LOOKUP_EXISTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_GT"><code class="name">var <span class="ident">LOOKUP_GT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_GTE"><code class="name">var <span class="ident">LOOKUP_GTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_ICONTAINS"><code class="name">var <span class="ident">LOOKUP_ICONTAINS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_IEXACT"><code class="name">var <span class="ident">LOOKUP_IEXACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_IN"><code class="name">var <span class="ident">LOOKUP_IN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_ISTARTSWITH"><code class="name">var <span class="ident">LOOKUP_ISTARTSWITH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_LT"><code class="name">var <span class="ident">LOOKUP_LT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_LTE"><code class="name">var <span class="ident">LOOKUP_LTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_NOT"><code class="name">var <span class="ident">LOOKUP_NOT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_RANGE"><code class="name">var <span class="ident">LOOKUP_RANGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_STARTSWITH"><code class="name">var <span class="ident">LOOKUP_STARTSWITH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_TYPES"><code class="name">var <span class="ident">LOOKUP_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LT"><code class="name">var <span class="ident">LT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LTE"><code class="name">var <span class="ident">LTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.NE"><code class="name">var <span class="ident">NE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.NEVER"><code class="name">var <span class="ident">NEVER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.NOT"><code class="name">var <span class="ident">NOT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.OP_TYPES"><code class="name">var <span class="ident">OP_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.OR"><code class="name">var <span class="ident">OR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.STARTSWITH"><code class="name">var <span class="ident">STARTSWITH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Q.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Q.conn_type"><code class="name">var <span class="ident">conn_type</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Q.field_path"><code class="name">var <span class="ident">field_path</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Q.op"><code class="name">var <span class="ident">op</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Q.query_string"><code class="name">var <span class="ident">query_string</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Q.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Q.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"><p>Do some basic checks on the attributes, using a generic folder. to_xml() does a good job of
validating. There's no reason to replicate much of that here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version):
    &#34;&#34;&#34;Do some basic checks on the attributes, using a generic folder. to_xml() does a good job of
    validating. There&#39;s no reason to replicate much of that here.
    &#34;&#34;&#34;
    from .folders import Folder

    self.to_xml(folders=[Folder()], version=version, applies_to=Restriction.ITEMS)</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.expr"><code class="name flex">
<span>def <span class="ident">expr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expr(self):
    if self.is_empty():
        return None
    if self.is_never():
        return self.NEVER
    if self.query_string:
        return self.query_string
    if self.is_leaf():
        expr = f&#34;{self.field_path} {self.op} {self.value!r}&#34;
    else:
        # Sort children by field name, so we get stable output (for easier testing). Children should never be empty.
        expr = f&#34; {self.AND if self.conn_type == self.NOT else self.conn_type} &#34;.join(
            (c.expr() if c.is_leaf() or c.conn_type == self.NOT else f&#34;({c.expr()})&#34;)
            for c in sorted(self.children, key=lambda i: i.field_path or &#34;&#34;)
        )
    if self.conn_type == self.NOT:
        # Add the NOT operator. Put children in parens if there is more than one child.
        if self.is_leaf() or len(self.children) == 1:
            return self.conn_type + f&#34; {expr}&#34;
        return self.conn_type + f&#34; ({expr})&#34;
    return expr</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if this object is without any restrictions at all.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self):
    &#34;&#34;&#34;Return True if this object is without any restrictions at all.&#34;&#34;&#34;
    return self.is_leaf() and self.field_path is None and self.query_string is None and self.conn_type != self.NEVER</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.is_leaf"><code class="name flex">
<span>def <span class="ident">is_leaf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_leaf(self):
    return not self.children</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.is_never"><code class="name flex">
<span>def <span class="ident">is_never</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if this object has a restriction that will never match anything.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_never(self):
    &#34;&#34;&#34;Return True if this object has a restriction that will never match anything.&#34;&#34;&#34;
    return self.conn_type == self.NEVER</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.reduce"><code class="name flex">
<span>def <span class="ident">reduce</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Simplify this object, if possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce(self):
    &#34;&#34;&#34;Simplify this object, if possible.&#34;&#34;&#34;
    self._reduce_children()
    self._promote()</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self, folders, version, applies_to)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self, folders, version, applies_to):
    if self.query_string:
        self._check_integrity()
        if version.build &lt; EXCHANGE_2010:
            raise NotImplementedError(&#34;QueryString filtering is only supported for Exchange 2010 servers and later&#34;)
        elem = create_element(&#34;m:QueryString&#34;)
        elem.text = self.query_string
        return elem
    # Translate this Q object to a valid Restriction XML tree
    elem = self.xml_elem(folders=folders, version=version, applies_to=applies_to)
    if elem is None:
        return None
    restriction = create_element(&#34;m:Restriction&#34;)
    restriction.append(elem)
    return restriction</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.xml_elem"><code class="name flex">
<span>def <span class="ident">xml_elem</span></span>(<span>self, folders, version, applies_to)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml_elem(self, folders, version, applies_to):
    # Recursively build an XML tree structure of this Q object. If this is an empty leaf (the equivalent of Q()),
    # return None.
    from .indexed_properties import SingleFieldIndexedElement

    # Don&#39;t check self.value just yet. We want to return error messages on the field path first, and then the value.
    # This is done in _get_field_path() and _get_clean_value(), respectively.
    self._check_integrity()
    if self.is_empty():
        return None
    if self.is_never():
        raise ValueError(&#34;EWS does not support &#39;never&#39; queries&#34;)
    if self.is_leaf():
        elem = self._op_to_xml(self.op)
        field_path = self._get_field_path(folders, applies_to=applies_to, version=version)
        clean_value = self._get_clean_value(field_path=field_path, version=version)
        if issubclass(field_path.field.value_cls, SingleFieldIndexedElement) and not field_path.label:
            # We allow a filter shortcut of e.g. email_addresses__contains=EmailAddress(label=&#39;Foo&#39;, ...) instead of
            # email_addresses__Foo_email_address=.... Set FieldPath label now, so we can generate the field_uri.
            field_path.label = clean_value.label
        elif isinstance(field_path.field, DateTimeBackedDateField):
            # We need to convert to datetime
            clean_value = field_path.field.date_to_datetime(clean_value)
        elem.append(field_path.to_xml())
        if self.op != self.EXISTS:
            constant = create_element(&#34;t:Constant&#34;, attrs=dict(Value=value_to_xml_text(clean_value)))
            if self.op in self.CONTAINS_OPS:
                elem.append(constant)
            else:
                uriorconst = create_element(&#34;t:FieldURIOrConstant&#34;)
                uriorconst.append(constant)
                elem.append(uriorconst)
    elif len(self.children) == 1:
        # We have only one child
        elem = self.children[0].xml_elem(folders=folders, version=version, applies_to=applies_to)
    else:
        # We have multiple children. If conn_type is NOT, then group children with AND. We&#39;ll add the NOT later
        elem = self._conn_to_xml(self.AND if self.conn_type == self.NOT else self.conn_type)
        # Sort children by field name, so we get stable output (for easier testing). Children should never be empty
        for c in sorted(self.children, key=lambda i: i.field_path or &#34;&#34;):
            elem.append(c.xml_elem(folders=folders, version=version, applies_to=applies_to))
    if elem is None:
        return None  # Should not be necessary, but play safe
    if self.conn_type == self.NOT:
        # Encapsulate everything in the NOT element
        not_elem = self._conn_to_xml(self.conn_type)
        not_elem.append(elem)
        return not_elem
    return elem</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.ReplyAllToItem"><code class="flex name class">
<span>class <span class="ident">ReplyAllToItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replyalltoitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replyalltoitem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplyAllToItem(BaseReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replyalltoitem&#34;&#34;&#34;

    ELEMENT_NAME = &#34;ReplyAllToItem&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ReplyAllToItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.base.BaseReplyItem.account" href="items/base.html#exchangelib.items.base.BaseReplyItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.save" href="items/base.html#exchangelib.items.base.BaseReplyItem.save">save</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.ReplyToItem"><code class="flex name class">
<span>class <span class="ident">ReplyToItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replytoitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replytoitem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplyToItem(BaseReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replytoitem&#34;&#34;&#34;

    ELEMENT_NAME = &#34;ReplyToItem&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ReplyToItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.base.BaseReplyItem.account" href="items/base.html#exchangelib.items.base.BaseReplyItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.save" href="items/base.html#exchangelib.items.base.BaseReplyItem.save">save</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Room"><code class="flex name class">
<span>class <span class="ident">Room</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/room">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/room</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Room(Mailbox):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/room&#34;&#34;&#34;

    ELEMENT_NAME = &#34;Room&#34;

    @classmethod
    def from_xml(cls, elem, account):
        id_elem = elem.find(f&#34;{{{TNS}}}Id&#34;)
        item_id_elem = id_elem.find(ItemId.response_tag())
        kwargs = dict(
            name=get_xml_attr(id_elem, f&#34;{{{TNS}}}Name&#34;),
            email_address=get_xml_attr(id_elem, f&#34;{{{TNS}}}EmailAddress&#34;),
            mailbox_type=get_xml_attr(id_elem, f&#34;{{{TNS}}}MailboxType&#34;),
            item_id=ItemId.from_xml(elem=item_id_elem, account=account) if item_id_elem else None,
        )
        cls._clear(elem)
        return cls(**kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Room.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.Room.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    id_elem = elem.find(f&#34;{{{TNS}}}Id&#34;)
    item_id_elem = id_elem.find(ItemId.response_tag())
    kwargs = dict(
        name=get_xml_attr(id_elem, f&#34;{{{TNS}}}Name&#34;),
        email_address=get_xml_attr(id_elem, f&#34;{{{TNS}}}EmailAddress&#34;),
        mailbox_type=get_xml_attr(id_elem, f&#34;{{{TNS}}}MailboxType&#34;),
        item_id=ItemId.from_xml(elem=item_id_elem, account=account) if item_id_elem else None,
    )
    cls._clear(elem)
    return cls(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.Mailbox.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.RoomList"><code class="flex name class">
<span>class <span class="ident">RoomList</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/roomlist">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/roomlist</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoomList(Mailbox):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/roomlist&#34;&#34;&#34;

    ELEMENT_NAME = &#34;RoomList&#34;
    NAMESPACE = MNS

    @classmethod
    def response_tag(cls):
        # In a GetRoomLists response, room lists are delivered as Address elements. See
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/address-emailaddresstype
        return f&#34;{{{TNS}}}Address&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.RoomList.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.RoomList.NAMESPACE"><code class="name">var <span class="ident">NAMESPACE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.RoomList.response_tag"><code class="name flex">
<span>def <span class="ident">response_tag</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def response_tag(cls):
    # In a GetRoomLists response, room lists are delivered as Address elements. See
    # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/address-emailaddresstype
    return f&#34;{{{TNS}}}Address&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.Mailbox.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.RootOfHierarchy"><code class="flex name class">
<span>class <span class="ident">RootOfHierarchy</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for folders that implement the root of a folder hierarchy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RootOfHierarchy(BaseFolder, metaclass=EWSMeta):
    &#34;&#34;&#34;Base class for folders that implement the root of a folder hierarchy.&#34;&#34;&#34;

    # A list of wellknown, or &#34;distinguished&#34;, folders that are belong in this folder hierarchy. See
    # https://docs.microsoft.com/en-us/dotnet/api/microsoft.exchange.webservices.data.wellknownfoldername
    # and https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/distinguishedfolderid
    # &#39;RootOfHierarchy&#39; subclasses must not be in this list.
    WELLKNOWN_FOLDERS = []

    # This folder type also has &#39;folder:PermissionSet&#39; on some server versions, but requesting it sometimes causes
    # &#39;ErrorAccessDenied&#39;, as reported by some users. Ignore it entirely for root folders - it&#39;s usefulness is
    # deemed minimal at best.
    effective_rights = EffectiveRightsField(
        field_uri=&#34;folder:EffectiveRights&#34;, is_read_only=True, supported_from=EXCHANGE_2007_SP1
    )

    __slots__ = &#34;_account&#34;, &#34;_subfolders&#34;, &#34;_subfolders_lock&#34;

    # A special folder that acts as the top of a folder hierarchy. Finds and caches sub-folders at arbitrary depth.
    def __init__(self, **kwargs):
        self._account = kwargs.pop(&#34;account&#34;, None)  # A pointer back to the account holding the folder hierarchy
        super().__init__(**kwargs)
        self._subfolders = None  # See self._folders_map()
        self._subfolders_lock = Lock()

    @property
    def account(self):
        return self._account

    @property
    def root(self):
        return self

    @property
    def parent(self):
        return None

    @classmethod
    def register(cls, *args, **kwargs):
        if cls is not RootOfHierarchy:
            raise TypeError(&#34;For folder roots, custom fields must be registered on the RootOfHierarchy class&#34;)
        return super().register(*args, **kwargs)

    @classmethod
    def deregister(cls, *args, **kwargs):
        if cls is not RootOfHierarchy:
            raise TypeError(&#34;For folder roots, custom fields must be registered on the RootOfHierarchy class&#34;)
        return super().deregister(*args, **kwargs)

    def get_folder(self, folder):
        if not folder.id:
            raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
        return self._folders_map.get(folder.id)

    def add_folder(self, folder):
        if not folder.id:
            raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
        self._folders_map[folder.id] = folder

    def update_folder(self, folder):
        if not folder.id:
            raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
        self._folders_map[folder.id] = folder

    def remove_folder(self, folder):
        if not folder.id:
            raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
        with suppress(KeyError):
            del self._folders_map[folder.id]

    def clear_cache(self):
        with self._subfolders_lock:
            self._subfolders = None

    def get_children(self, folder):
        for f in self._folders_map.values():
            if not f.parent:
                continue
            if f.parent.id == folder.id:
                yield f

    def get_default_folder(self, folder_cls):
        &#34;&#34;&#34;Return the distinguished folder instance of type folder_cls belonging to this account. If no distinguished
        folder was found, try as best we can to return the default folder of type &#39;folder_cls&#39;
        &#34;&#34;&#34;
        if not folder_cls.DISTINGUISHED_FOLDER_ID:
            raise ValueError(f&#34;&#39;folder_cls&#39; {folder_cls} must have a DISTINGUISHED_FOLDER_ID value&#34;)
        # Use cached distinguished folder instance, but only if cache has already been prepped. This is an optimization
        # for accessing e.g. &#39;account.contacts&#39; without fetching all folders of the account.
        if self._subfolders is not None:
            for f in self._folders_map.values():
                # Require exact class, to not match subclasses, e.g. RecipientCache instead of Contacts
                if f.__class__ == folder_cls and f.is_distinguished:
                    log.debug(&#34;Found cached distinguished %s folder&#34;, folder_cls)
                    return f
        try:
            log.debug(&#34;Requesting distinguished %s folder explicitly&#34;, folder_cls)
            return folder_cls.get_distinguished(root=self)
        except ErrorAccessDenied:
            # Maybe we just don&#39;t have GetFolder access? Try FindItem instead
            log.debug(&#34;Testing default %s folder with FindItem&#34;, folder_cls)
            fld = folder_cls(
                _distinguished_id=DistinguishedFolderId(
                    id=folder_cls.DISTINGUISHED_FOLDER_ID,
                    mailbox=Mailbox(email_address=self.account.primary_smtp_address),
                ),
                root=self,
            )
            fld.test_access()
            return self._folders_map.get(fld.id, fld)  # Use cached instance if available
        except MISSING_FOLDER_ERRORS:
            # The Exchange server does not return a distinguished folder of this type
            pass
        raise ErrorFolderNotFound(f&#34;No usable default {folder_cls} folders&#34;)

    @classmethod
    def get_distinguished(cls, account):
        &#34;&#34;&#34;Get the distinguished folder for this folder class.

        :param account:
        :return:
        &#34;&#34;&#34;
        return cls._get_distinguished(
            folder=cls(
                _distinguished_id=DistinguishedFolderId(
                    id=cls.DISTINGUISHED_FOLDER_ID,
                    mailbox=Mailbox(email_address=account.primary_smtp_address),
                ),
                account=account,
            )
        )

    @property
    def _folders_map(self):
        if self._subfolders is not None:
            return self._subfolders

        with self._subfolders_lock:
            # Map root, and all sub-folders of root, at arbitrary depth by folder ID. First get distinguished folders,
            # so we are sure to apply the correct Folder class, then fetch all sub-folders of this root.
            folders_map = {self.id: self}
            distinguished_folders = [
                cls(
                    _distinguished_id=DistinguishedFolderId(
                        id=cls.DISTINGUISHED_FOLDER_ID,
                        mailbox=Mailbox(email_address=self.account.primary_smtp_address),
                    ),
                    root=self,
                )
                for cls in self.WELLKNOWN_FOLDERS
                if cls.get_folder_allowed and cls.supports_version(self.account.version)
            ]
            for f in FolderCollection(account=self.account, folders=distinguished_folders).resolve():
                if isinstance(f, MISSING_FOLDER_ERRORS):
                    # This is just a distinguished folder the server does not have
                    continue
                if isinstance(f, ErrorInvalidOperation):
                    # This is probably a distinguished folder the server does not have. We previously tested the exact
                    # error message (f.value), but some Exchange servers return localized error messages, so that&#39;s not
                    # possible to do reliably.
                    continue
                if isinstance(f, ErrorAccessDenied):
                    # We may not have GetFolder access, either to this folder or at all
                    continue
                if isinstance(f, Exception):
                    raise f
                folders_map[f.id] = f
            for f in (
                SingleFolderQuerySet(account=self.account, folder=self).depth(self.DEFAULT_FOLDER_TRAVERSAL_DEPTH).all()
            ):
                if isinstance(f, ErrorAccessDenied):
                    # We may not have FindFolder access, or GetFolder access, either to this folder or at all
                    continue
                if isinstance(f, MISSING_FOLDER_ERRORS):
                    # We were unlucky. The folder disappeared between the FindFolder and the GetFolder calls
                    continue
                if isinstance(f, Exception):
                    raise f
                if f.id in folders_map:
                    # Already exists. Probably a distinguished folder
                    continue
                folders_map[f.id] = f
            self._subfolders = folders_map
            return folders_map

    @classmethod
    def from_xml(cls, elem, account):
        kwargs = cls._kwargs_from_elem(elem=elem, account=account)
        cls._clear(elem)
        return cls(account=account, **kwargs)

    @classmethod
    def folder_cls_from_folder_name(cls, folder_name, folder_class, locale):
        &#34;&#34;&#34;Return the folder class that matches a localized folder name. Take into account the &#39;folder_class&#39; of the
        folder, to not identify an &#39;IPF.Note&#39; folder as a &#39;Calendar&#39; class just because it&#39;s called e.g. &#39;Kalender&#39; and
        the locale is &#39;da_DK&#39;.

        Some folders, e.g. `System`, don&#39;t define a `folder_class`. For these folders, we match on localized folder name
        if the folder class does not have its &#39;CONTAINER_CLASS&#39; set.

        :param folder_name:
        :param folder_class:
        :param locale: a string, e.g. &#39;da_DK&#39;
        &#34;&#34;&#34;
        for folder_cls in cls.WELLKNOWN_FOLDERS + NON_DELETABLE_FOLDERS + MISC_FOLDERS:
            if folder_cls.CONTAINER_CLASS != folder_class:
                continue
            if folder_name.lower() not in folder_cls.localized_names(locale):
                continue
            return folder_cls
        raise KeyError()

    def __getstate__(self):
        # The lock cannot be pickled
        state = {k: getattr(self, k) for k in self._slots_keys}
        del state[&#34;_subfolders_lock&#34;]
        return state

    def __setstate__(self, state):
        # Restore the lock
        for k in self._slots_keys:
            setattr(self, k, state.get(k))
        self._subfolders_lock = Lock()

    def __repr__(self):
        # Let&#39;s not create an infinite loop when printing self.root
        return self.__class__.__name__ + repr(
            (
                self.account,
                &#34;[self]&#34;,
                self.name,
                self.total_count,
                self.unread_count,
                self.child_folder_count,
                self.folder_class,
                self.id,
                self.changekey,
            )
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.base.BaseFolder" href="folders/base.html#exchangelib.folders.base.BaseFolder">BaseFolder</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
<li><a title="exchangelib.queryset.SearchableMixIn" href="queryset.html#exchangelib.queryset.SearchableMixIn">SearchableMixIn</a></li>
<li><a title="exchangelib.version.SupportedVersionClassMixIn" href="version.html#exchangelib.version.SupportedVersionClassMixIn">SupportedVersionClassMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.roots.ArchiveRoot" href="folders/roots.html#exchangelib.folders.roots.ArchiveRoot">ArchiveRoot</a></li>
<li><a title="exchangelib.folders.roots.PublicFoldersRoot" href="folders/roots.html#exchangelib.folders.roots.PublicFoldersRoot">PublicFoldersRoot</a></li>
<li><a title="exchangelib.folders.roots.Root" href="folders/roots.html#exchangelib.folders.roots.Root">Root</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.RootOfHierarchy.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.RootOfHierarchy.WELLKNOWN_FOLDERS"><code class="name">var <span class="ident">WELLKNOWN_FOLDERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.RootOfHierarchy.folder_cls_from_folder_name"><code class="name flex">
<span>def <span class="ident">folder_cls_from_folder_name</span></span>(<span>folder_name, folder_class, locale)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the folder class that matches a localized folder name. Take into account the 'folder_class' of the
folder, to not identify an 'IPF.Note' folder as a 'Calendar' class just because it's called e.g. 'Kalender' and
the locale is 'da_DK'.</p>
<p>Some folders, e.g. <code>System</code>, don't define a <code>folder_class</code>. For these folders, we match on localized folder name
if the folder class does not have its 'CONTAINER_CLASS' set.</p>
<p>:param folder_name:
:param folder_class:
:param locale: a string, e.g. 'da_DK'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def folder_cls_from_folder_name(cls, folder_name, folder_class, locale):
    &#34;&#34;&#34;Return the folder class that matches a localized folder name. Take into account the &#39;folder_class&#39; of the
    folder, to not identify an &#39;IPF.Note&#39; folder as a &#39;Calendar&#39; class just because it&#39;s called e.g. &#39;Kalender&#39; and
    the locale is &#39;da_DK&#39;.

    Some folders, e.g. `System`, don&#39;t define a `folder_class`. For these folders, we match on localized folder name
    if the folder class does not have its &#39;CONTAINER_CLASS&#39; set.

    :param folder_name:
    :param folder_class:
    :param locale: a string, e.g. &#39;da_DK&#39;
    &#34;&#34;&#34;
    for folder_cls in cls.WELLKNOWN_FOLDERS + NON_DELETABLE_FOLDERS + MISC_FOLDERS:
        if folder_cls.CONTAINER_CLASS != folder_class:
            continue
        if folder_name.lower() not in folder_cls.localized_names(locale):
            continue
        return folder_cls
    raise KeyError()</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    kwargs = cls._kwargs_from_elem(elem=elem, account=account)
    cls._clear(elem)
    return cls(account=account, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.get_distinguished"><code class="name flex">
<span>def <span class="ident">get_distinguished</span></span>(<span>account)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the distinguished folder for this folder class.</p>
<p>:param account:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_distinguished(cls, account):
    &#34;&#34;&#34;Get the distinguished folder for this folder class.

    :param account:
    :return:
    &#34;&#34;&#34;
    return cls._get_distinguished(
        folder=cls(
            _distinguished_id=DistinguishedFolderId(
                id=cls.DISTINGUISHED_FOLDER_ID,
                mailbox=Mailbox(email_address=account.primary_smtp_address),
            ),
            account=account,
        )
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.RootOfHierarchy.effective_rights"><code class="name">var <span class="ident">effective_rights</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.RootOfHierarchy.add_folder"><code class="name flex">
<span>def <span class="ident">add_folder</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_folder(self, folder):
    if not folder.id:
        raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
    self._folders_map[folder.id] = folder</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self):
    with self._subfolders_lock:
        self._subfolders = None</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.get_children"><code class="name flex">
<span>def <span class="ident">get_children</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_children(self, folder):
    for f in self._folders_map.values():
        if not f.parent:
            continue
        if f.parent.id == folder.id:
            yield f</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.get_default_folder"><code class="name flex">
<span>def <span class="ident">get_default_folder</span></span>(<span>self, folder_cls)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the distinguished folder instance of type folder_cls belonging to this account. If no distinguished
folder was found, try as best we can to return the default folder of type 'folder_cls'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_folder(self, folder_cls):
    &#34;&#34;&#34;Return the distinguished folder instance of type folder_cls belonging to this account. If no distinguished
    folder was found, try as best we can to return the default folder of type &#39;folder_cls&#39;
    &#34;&#34;&#34;
    if not folder_cls.DISTINGUISHED_FOLDER_ID:
        raise ValueError(f&#34;&#39;folder_cls&#39; {folder_cls} must have a DISTINGUISHED_FOLDER_ID value&#34;)
    # Use cached distinguished folder instance, but only if cache has already been prepped. This is an optimization
    # for accessing e.g. &#39;account.contacts&#39; without fetching all folders of the account.
    if self._subfolders is not None:
        for f in self._folders_map.values():
            # Require exact class, to not match subclasses, e.g. RecipientCache instead of Contacts
            if f.__class__ == folder_cls and f.is_distinguished:
                log.debug(&#34;Found cached distinguished %s folder&#34;, folder_cls)
                return f
    try:
        log.debug(&#34;Requesting distinguished %s folder explicitly&#34;, folder_cls)
        return folder_cls.get_distinguished(root=self)
    except ErrorAccessDenied:
        # Maybe we just don&#39;t have GetFolder access? Try FindItem instead
        log.debug(&#34;Testing default %s folder with FindItem&#34;, folder_cls)
        fld = folder_cls(
            _distinguished_id=DistinguishedFolderId(
                id=folder_cls.DISTINGUISHED_FOLDER_ID,
                mailbox=Mailbox(email_address=self.account.primary_smtp_address),
            ),
            root=self,
        )
        fld.test_access()
        return self._folders_map.get(fld.id, fld)  # Use cached instance if available
    except MISSING_FOLDER_ERRORS:
        # The Exchange server does not return a distinguished folder of this type
        pass
    raise ErrorFolderNotFound(f&#34;No usable default {folder_cls} folders&#34;)</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.get_folder"><code class="name flex">
<span>def <span class="ident">get_folder</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folder(self, folder):
    if not folder.id:
        raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
    return self._folders_map.get(folder.id)</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.remove_folder"><code class="name flex">
<span>def <span class="ident">remove_folder</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_folder(self, folder):
    if not folder.id:
        raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
    with suppress(KeyError):
        del self._folders_map[folder.id]</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.update_folder"><code class="name flex">
<span>def <span class="ident">update_folder</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_folder(self, folder):
    if not folder.id:
        raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
    self._folders_map[folder.id] = folder</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.folders.base.BaseFolder" href="folders/base.html#exchangelib.folders.base.BaseFolder">BaseFolder</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.folders.base.BaseFolder.ID_ELEMENT_CLS" href="folders/base.html#exchangelib.folders.base.BaseFolder.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.account" href="folders/base.html#exchangelib.folders.base.BaseFolder.account">account</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.all" href="queryset.html#exchangelib.queryset.SearchableMixIn.all">all</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.exclude" href="queryset.html#exchangelib.queryset.SearchableMixIn.exclude">exclude</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.filter" href="queryset.html#exchangelib.queryset.SearchableMixIn.filter">filter</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.folder_cls_from_container_class" href="folders/base.html#exchangelib.folders.base.BaseFolder.folder_cls_from_container_class">folder_cls_from_container_class</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.folder_sync_state" href="folders/base.html#exchangelib.folders.base.BaseFolder.folder_sync_state">folder_sync_state</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.get" href="queryset.html#exchangelib.queryset.SearchableMixIn.get">get</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.get_events" href="folders/base.html#exchangelib.folders.base.BaseFolder.get_events">get_events</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.get_streaming_events" href="folders/base.html#exchangelib.folders.base.BaseFolder.get_streaming_events">get_streaming_events</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.item_sync_state" href="folders/base.html#exchangelib.folders.base.BaseFolder.item_sync_state">item_sync_state</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.none" href="queryset.html#exchangelib.queryset.SearchableMixIn.none">none</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.parent" href="folders/base.html#exchangelib.folders.base.BaseFolder.parent">parent</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.people" href="queryset.html#exchangelib.queryset.SearchableMixIn.people">people</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.root" href="folders/base.html#exchangelib.folders.base.BaseFolder.root">root</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_pull" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_pull">subscribe_to_pull</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_push" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_push">subscribe_to_push</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_streaming" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_streaming">subscribe_to_streaming</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.sync_hierarchy" href="folders/base.html#exchangelib.folders.base.BaseFolder.sync_hierarchy">sync_hierarchy</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.sync_items" href="folders/base.html#exchangelib.folders.base.BaseFolder.sync_items">sync_items</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.test_access" href="folders/base.html#exchangelib.folders.base.BaseFolder.test_access">test_access</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.tree" href="folders/base.html#exchangelib.folders.base.BaseFolder.tree">tree</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.unsubscribe" href="folders/base.html#exchangelib.folders.base.BaseFolder.unsubscribe">unsubscribe</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.TLSClientAuth"><code class="flex name class">
<span>class <span class="ident">TLSClientAuth</span></span>
<span>(</span><span>pool_connections=10, pool_maxsize=10, max_retries=0, pool_block=False)</span>
</code></dt>
<dd>
<div class="desc"><p>An HTTP adapter that implements Certificate Based Authentication (CBA).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TLSClientAuth(requests.adapters.HTTPAdapter):
    &#34;&#34;&#34;An HTTP adapter that implements Certificate Based Authentication (CBA).&#34;&#34;&#34;

    cert_file = None

    def init_poolmanager(self, *args, **kwargs):
        kwargs[&#34;cert_file&#34;] = self.cert_file
        return super().init_poolmanager(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>requests.adapters.HTTPAdapter</li>
<li>requests.adapters.BaseAdapter</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.TLSClientAuth.cert_file"><code class="name">var <span class="ident">cert_file</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.TLSClientAuth.init_poolmanager"><code class="name flex">
<span>def <span class="ident">init_poolmanager</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a urllib3 PoolManager.</p>
<p>This method should not be called from user code, and is only
exposed for use when subclassing the
:class:<code>HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;</code>.</p>
<p>:param connections: The number of urllib3 connection pools to cache.
:param maxsize: The maximum number of connections to save in the pool.
:param block: Block when no free connections are available.
:param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_poolmanager(self, *args, **kwargs):
    kwargs[&#34;cert_file&#34;] = self.cert_file
    return super().init_poolmanager(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Task"><code class="flex name class">
<span>class <span class="ident">Task</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/task">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/task</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Task(Item):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/task&#34;&#34;&#34;

    ELEMENT_NAME = &#34;Task&#34;
    NOT_STARTED = &#34;NotStarted&#34;
    COMPLETED = &#34;Completed&#34;

    actual_work = IntegerField(field_uri=&#34;task:ActualWork&#34;, min=0)
    assigned_time = DateTimeField(field_uri=&#34;task:AssignedTime&#34;, is_read_only=True)
    billing_information = TextField(field_uri=&#34;task:BillingInformation&#34;)
    change_count = IntegerField(field_uri=&#34;task:ChangeCount&#34;, is_read_only=True, min=0)
    companies = TextListField(field_uri=&#34;task:Companies&#34;)
    # &#39;complete_date&#39; can be set, but is ignored by the server, which sets it to now()
    complete_date = DateTimeField(field_uri=&#34;task:CompleteDate&#34;, is_read_only=True)
    contacts = TextListField(field_uri=&#34;task:Contacts&#34;)
    delegation_state = ChoiceField(
        field_uri=&#34;task:DelegationState&#34;,
        choices={
            Choice(&#34;NoMatch&#34;),
            Choice(&#34;OwnNew&#34;),
            Choice(&#34;Owned&#34;),
            Choice(&#34;Accepted&#34;),
            Choice(&#34;Declined&#34;),
            Choice(&#34;Max&#34;),
        },
        is_read_only=True,
    )
    delegator = CharField(field_uri=&#34;task:Delegator&#34;, is_read_only=True)
    due_date = DateTimeBackedDateField(field_uri=&#34;task:DueDate&#34;)
    is_editable = BooleanField(field_uri=&#34;task:IsAssignmentEditable&#34;, is_read_only=True)
    is_complete = BooleanField(field_uri=&#34;task:IsComplete&#34;, is_read_only=True)
    is_recurring = BooleanField(field_uri=&#34;task:IsRecurring&#34;, is_read_only=True)
    is_team_task = BooleanField(field_uri=&#34;task:IsTeamTask&#34;, is_read_only=True)
    mileage = TextField(field_uri=&#34;task:Mileage&#34;)
    owner = CharField(field_uri=&#34;task:Owner&#34;, is_read_only=True)
    percent_complete = DecimalField(
        field_uri=&#34;task:PercentComplete&#34;,
        is_required=True,
        default=Decimal(0.0),
        min=Decimal(0),
        max=Decimal(100),
        is_searchable=False,
    )
    recurrence = TaskRecurrenceField(field_uri=&#34;task:Recurrence&#34;, is_searchable=False)
    start_date = DateTimeBackedDateField(field_uri=&#34;task:StartDate&#34;)
    status = ChoiceField(
        field_uri=&#34;task:Status&#34;,
        choices={
            Choice(NOT_STARTED),
            Choice(&#34;InProgress&#34;),
            Choice(COMPLETED),
            Choice(&#34;WaitingOnOthers&#34;),
            Choice(&#34;Deferred&#34;),
        },
        is_required=True,
        is_searchable=False,
        default=NOT_STARTED,
    )
    status_description = CharField(field_uri=&#34;task:StatusDescription&#34;, is_read_only=True)
    total_work = IntegerField(field_uri=&#34;task:TotalWork&#34;, min=0)

    # O365 throws ErrorInternalServerError &#34;[0x004f0102] MapiReplyToBlob&#34; if UniqueBody is requested
    unique_body_idx = Item.FIELDS.index_by_name(&#34;unique_body&#34;)
    FIELDS = Item.FIELDS[:unique_body_idx] + Item.FIELDS[unique_body_idx + 1 :]

    def clean(self, version=None):
        super().clean(version=version)
        if self.due_date and self.start_date and self.due_date &lt; self.start_date:
            log.warning(
                &#34;&#39;due_date&#39; must be greater than &#39;start_date&#39; (%s vs %s). Resetting &#39;due_date&#39;&#34;,
                self.due_date,
                self.start_date,
            )
            self.due_date = self.start_date
        if self.complete_date:
            if self.status != self.COMPLETED:
                log.warning(
                    &#34;&#39;status&#39; must be &#39;%s&#39; when &#39;complete_date&#39; is set (%s). Resetting&#34;, self.COMPLETED, self.status
                )
                self.status = self.COMPLETED
            now = datetime.datetime.now(tz=UTC)
            if (self.complete_date - now).total_seconds() &gt; 120:
                # Reset complete_date values that are in the future
                # &#39;complete_date&#39; can be set automatically by the server. Allow some grace between local and server time
                log.warning(&#34;&#39;complete_date&#39; must be in the past (%s vs %s). Resetting&#34;, self.complete_date, now)
                self.complete_date = now
            if self.start_date and self.complete_date.date() &lt; self.start_date:
                log.warning(
                    &#34;&#39;complete_date&#39; must be greater than &#39;start_date&#39; (%s vs %s). Resetting&#34;,
                    self.complete_date,
                    self.start_date,
                )
                self.complete_date = EWSDateTime.combine(self.start_date, datetime.time(0, 0)).replace(tzinfo=UTC)
        if self.percent_complete is not None:
            if self.status == self.COMPLETED and self.percent_complete != Decimal(100):
                # percent_complete must be 100% if task is complete
                log.warning(
                    &#34;&#39;percent_complete&#39; must be 100 when &#39;status&#39; is &#39;%s&#39; (%s). Resetting&#34;,
                    self.COMPLETED,
                    self.percent_complete,
                )
                self.percent_complete = Decimal(100)
            elif self.status == self.NOT_STARTED and self.percent_complete != Decimal(0):
                # percent_complete must be 0% if task is not started
                log.warning(
                    &#34;&#39;percent_complete&#39; must be 0 when &#39;status&#39; is &#39;%s&#39; (%s). Resetting&#34;,
                    self.NOT_STARTED,
                    self.percent_complete,
                )
                self.percent_complete = Decimal(0)

    def complete(self):
        # A helper method to mark a task as complete on the server
        self.status = Task.COMPLETED
        self.percent_complete = Decimal(100)
        self.save()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Task.COMPLETED"><code class="name">var <span class="ident">COMPLETED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.NOT_STARTED"><code class="name">var <span class="ident">NOT_STARTED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.unique_body_idx"><code class="name">var <span class="ident">unique_body_idx</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Task.actual_work"><code class="name">var <span class="ident">actual_work</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.assigned_time"><code class="name">var <span class="ident">assigned_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.billing_information"><code class="name">var <span class="ident">billing_information</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.change_count"><code class="name">var <span class="ident">change_count</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.companies"><code class="name">var <span class="ident">companies</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.complete_date"><code class="name">var <span class="ident">complete_date</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.contacts"><code class="name">var <span class="ident">contacts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.delegation_state"><code class="name">var <span class="ident">delegation_state</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.delegator"><code class="name">var <span class="ident">delegator</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.due_date"><code class="name">var <span class="ident">due_date</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.is_complete"><code class="name">var <span class="ident">is_complete</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.is_editable"><code class="name">var <span class="ident">is_editable</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.is_recurring"><code class="name">var <span class="ident">is_recurring</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.is_team_task"><code class="name">var <span class="ident">is_team_task</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.mileage"><code class="name">var <span class="ident">mileage</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.owner"><code class="name">var <span class="ident">owner</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.percent_complete"><code class="name">var <span class="ident">percent_complete</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.recurrence"><code class="name">var <span class="ident">recurrence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.start_date"><code class="name">var <span class="ident">start_date</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.status_description"><code class="name">var <span class="ident">status_description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.total_work"><code class="name">var <span class="ident">total_work</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Task.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    super().clean(version=version)
    if self.due_date and self.start_date and self.due_date &lt; self.start_date:
        log.warning(
            &#34;&#39;due_date&#39; must be greater than &#39;start_date&#39; (%s vs %s). Resetting &#39;due_date&#39;&#34;,
            self.due_date,
            self.start_date,
        )
        self.due_date = self.start_date
    if self.complete_date:
        if self.status != self.COMPLETED:
            log.warning(
                &#34;&#39;status&#39; must be &#39;%s&#39; when &#39;complete_date&#39; is set (%s). Resetting&#34;, self.COMPLETED, self.status
            )
            self.status = self.COMPLETED
        now = datetime.datetime.now(tz=UTC)
        if (self.complete_date - now).total_seconds() &gt; 120:
            # Reset complete_date values that are in the future
            # &#39;complete_date&#39; can be set automatically by the server. Allow some grace between local and server time
            log.warning(&#34;&#39;complete_date&#39; must be in the past (%s vs %s). Resetting&#34;, self.complete_date, now)
            self.complete_date = now
        if self.start_date and self.complete_date.date() &lt; self.start_date:
            log.warning(
                &#34;&#39;complete_date&#39; must be greater than &#39;start_date&#39; (%s vs %s). Resetting&#34;,
                self.complete_date,
                self.start_date,
            )
            self.complete_date = EWSDateTime.combine(self.start_date, datetime.time(0, 0)).replace(tzinfo=UTC)
    if self.percent_complete is not None:
        if self.status == self.COMPLETED and self.percent_complete != Decimal(100):
            # percent_complete must be 100% if task is complete
            log.warning(
                &#34;&#39;percent_complete&#39; must be 100 when &#39;status&#39; is &#39;%s&#39; (%s). Resetting&#34;,
                self.COMPLETED,
                self.percent_complete,
            )
            self.percent_complete = Decimal(100)
        elif self.status == self.NOT_STARTED and self.percent_complete != Decimal(0):
            # percent_complete must be 0% if task is not started
            log.warning(
                &#34;&#39;percent_complete&#39; must be 0 when &#39;status&#39; is &#39;%s&#39; (%s). Resetting&#34;,
                self.NOT_STARTED,
                self.percent_complete,
            )
            self.percent_complete = Decimal(0)</code></pre>
</details>
</dd>
<dt id="exchangelib.Task.complete"><code class="name flex">
<span>def <span class="ident">complete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete(self):
    # A helper method to mark a task as complete on the server
    self.status = Task.COMPLETED
    self.percent_complete = Decimal(100)
    self.save()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.TentativelyAcceptItem"><code class="flex name class">
<span>class <span class="ident">TentativelyAcceptItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/tentativelyacceptitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/tentativelyacceptitem</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TentativelyAcceptItem(BaseMeetingReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/tentativelyacceptitem&#34;&#34;&#34;

    ELEMENT_NAME = &#34;TentativelyAcceptItem&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.TentativelyAcceptItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.UID"><code class="flex name class">
<span>class <span class="ident">UID</span></span>
<span>(</span><span>uid)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class to encode Calendar UIDs. See issue #453. Example:</p>
<p>class GlobalObjectId(ExtendedProperty):
distinguished_property_set_id = 'Meeting'
property_id = 3
property_type = 'Binary'</p>
<p>CalendarItem.register('global_object_id', GlobalObjectId)
account.calendar.filter(global_object_id=UID('261cbc18-1f65-5a0a-bd11-23b1e224cc2f'))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UID(bytes):
    &#34;&#34;&#34;Helper class to encode Calendar UIDs. See issue #453. Example:

    class GlobalObjectId(ExtendedProperty):
        distinguished_property_set_id = &#39;Meeting&#39;
        property_id = 3
        property_type = &#39;Binary&#39;

    CalendarItem.register(&#39;global_object_id&#39;, GlobalObjectId)
    account.calendar.filter(global_object_id=UID(&#39;261cbc18-1f65-5a0a-bd11-23b1e224cc2f&#39;))
    &#34;&#34;&#34;

    _HEADER = binascii.hexlify(
        bytearray((0x04, 0x00, 0x00, 0x00, 0x82, 0x00, 0xE0, 0x00, 0x74, 0xC5, 0xB7, 0x10, 0x1A, 0x82, 0xE0, 0x08))
    )

    _EXCEPTION_REPLACEMENT_TIME = binascii.hexlify(bytearray((0, 0, 0, 0)))

    _CREATION_TIME = binascii.hexlify(bytearray((0, 0, 0, 0, 0, 0, 0, 0)))

    _RESERVED = binascii.hexlify(bytearray((0, 0, 0, 0, 0, 0, 0, 0)))

    # https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxocal/1d3aac05-a7b9-45cc-a213-47f0a0a2c5c1
    # https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-asemail/e7424ddc-dd10-431e-a0b7-5c794863370e
    # https://stackoverflow.com/questions/42259122
    # https://stackoverflow.com/questions/33757805

    def __new__(cls, uid):
        payload = binascii.hexlify(bytearray(f&#34;vCal-Uid\x01\x00\x00\x00{uid}\x00&#34;.encode(&#34;ascii&#34;)))
        length = binascii.hexlify(bytearray(struct.pack(&#34;&lt;I&#34;, int(len(payload) / 2))))
        encoding = b&#34;&#34;.join(
            [cls._HEADER, cls._EXCEPTION_REPLACEMENT_TIME, cls._CREATION_TIME, cls._RESERVED, length, payload]
        )
        return super().__new__(cls, codecs.decode(encoding, &#34;hex&#34;))

    @classmethod
    def to_global_object_id(cls, uid):
        &#34;&#34;&#34;Converts a UID as returned by EWS to GlobalObjectId format&#34;&#34;&#34;
        return binascii.unhexlify(uid)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.bytes</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.UID.to_global_object_id"><code class="name flex">
<span>def <span class="ident">to_global_object_id</span></span>(<span>uid)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a UID as returned by EWS to GlobalObjectId format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def to_global_object_id(cls, uid):
    &#34;&#34;&#34;Converts a UID as returned by EWS to GlobalObjectId format&#34;&#34;&#34;
    return binascii.unhexlify(uid)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Version"><code class="flex name class">
<span>class <span class="ident">Version</span></span>
<span>(</span><span>build, api_version=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds information about the server version.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Version:
    &#34;&#34;&#34;Holds information about the server version.&#34;&#34;&#34;

    __slots__ = &#34;build&#34;, &#34;api_version&#34;

    def __init__(self, build, api_version=None):
        if api_version is None:
            if not isinstance(build, Build):
                raise InvalidTypeError(&#34;build&#34;, build, Build)
            self.api_version = build.api_version()
        else:
            if not isinstance(build, (Build, type(None))):
                raise InvalidTypeError(&#34;build&#34;, build, Build)
            if not isinstance(api_version, str):
                raise InvalidTypeError(&#34;api_version&#34;, api_version, str)
            self.api_version = api_version
        self.build = build

    @property
    def fullname(self):
        for build, api_version, full_name in VERSIONS:
            if self.build and (
                self.build.major_version != build.major_version or self.build.minor_version != build.minor_version
            ):
                continue
            if self.api_version == api_version:
                return full_name
        log.warning(&#34;Full name for API version %s build %s is unknown&#34;, self.api_version, self.build)
        return &#34;UNKNOWN&#34;

    @classmethod
    def guess(cls, protocol, api_version_hint=None):
        &#34;&#34;&#34;Ask the server which version it has. We haven&#39;t set up an Account object yet, so we generate requests
        by hand. We only need a response header containing a ServerVersionInfo element.

        To get API version and build numbers from the server, we need to send a valid SOAP request. We can&#39;t do that
        without a valid API version. To solve this chicken-and-egg problem, we try all possible API versions that this
        package supports, until we get a valid response.

        :param protocol:
        :param api_version_hint:  (Default value = None)
        &#34;&#34;&#34;
        from .properties import ENTRY_ID, EWS_ID, AlternateId
        from .services import ConvertId

        # The protocol doesn&#39;t have a version yet, so default to the latest supported version if we don&#39;t have a hint.
        api_version = api_version_hint or ConvertId.supported_api_versions()[0]
        log.debug(&#34;Asking server for version info using API version %s&#34;, api_version)
        # We don&#39;t know the build version yet. Hopefully, the server will report it in the SOAP header. Lots of
        # places expect a version to have a build, so this is a bit dangerous, but passing a fake build around is also
        # dangerous.
        protocol.config.version = Version(build=None, api_version=api_version)
        # Use ConvertId as a minimal request to the server to test if the version is correct. If not, ConvertId will
        # try to guess the version automatically. Make sure the call to ConvertId does not require a version build.
        try:
            list(ConvertId(protocol=protocol).call([AlternateId(id=&#34;DUMMY&#34;, format=EWS_ID, mailbox=&#34;DUMMY&#34;)], ENTRY_ID))
        except ResponseMessageError as e:
            # We may have survived long enough to get a new version
            if not protocol.config.version.build:
                raise TransportError(f&#34;No valid version headers found in response ({e!r})&#34;)
        if not protocol.config.version.build:
            raise TransportError(&#34;No valid version headers found in response&#34;)
        return protocol.config.version

    @staticmethod
    def _is_invalid_version_string(version):
        # Check if a version string is bogus, e.g. V2_, V2015_ or V2018_
        return re.match(r&#34;V[0-9]{1,4}_.*&#34;, version)

    @classmethod
    def from_soap_header(cls, requested_api_version, header):
        info = header.find(f&#34;{{{TNS}}}ServerVersionInfo&#34;)
        if info is None:
            info = header.find(f&#34;{{{ANS}}}ServerVersionInfo&#34;)
            if info is None:
                raise TransportError(f&#34;No ServerVersionInfo in header: {xml_to_str(header)!r}&#34;)
        try:
            build = Build.from_xml(elem=info)
        except ValueError:
            raise TransportError(f&#34;Bad ServerVersionInfo in response: {xml_to_str(header)!r}&#34;)
        # Not all Exchange servers send the Version element
        api_version_from_server = info.get(&#34;Version&#34;) or get_xml_attr(info, f&#34;{{{ANS}}}Version&#34;) or build.api_version()
        if api_version_from_server != requested_api_version:
            if cls._is_invalid_version_string(api_version_from_server):
                # For unknown reasons, Office 365 may respond with an API version strings that is invalid in a request.
                # Detect these, so we can fall back to a valid version string.
                log.debug(
                    &#39;API version &#34;%s&#34; worked but server reports version &#34;%s&#34;. Using &#34;%s&#34;&#39;,
                    requested_api_version,
                    api_version_from_server,
                    requested_api_version,
                )
                api_version_from_server = requested_api_version
            else:
                # Trust API version from server response
                log.debug(
                    &#39;API version &#34;%s&#34; worked but server reports version &#34;%s&#34;. Using &#34;%s&#34;&#39;,
                    requested_api_version,
                    api_version_from_server,
                    api_version_from_server,
                )
        return cls(build=build, api_version=api_version_from_server)

    def copy(self):
        return self.__class__(build=self.build, api_version=self.api_version)

    @classmethod
    def all_versions(cls):
        # Return all supported versions, sorted newest to oldest
        return [cls(build=build, api_version=api_version) for build, api_version, _ in VERSIONS]

    def __hash__(self):
        return hash((self.build, self.api_version))

    def __eq__(self, other):
        if self.api_version != other.api_version:
            return False
        if self.build and not other.build:
            return False
        if other.build and not self.build:
            return False
        return self.build == other.build

    def __repr__(self):
        return self.__class__.__name__ + repr((self.build, self.api_version))

    def __str__(self):
        return f&#34;Build={self.build}, API={self.api_version}, Fullname={self.fullname}&#34;</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.Version.all_versions"><code class="name flex">
<span>def <span class="ident">all_versions</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def all_versions(cls):
    # Return all supported versions, sorted newest to oldest
    return [cls(build=build, api_version=api_version) for build, api_version, _ in VERSIONS]</code></pre>
</details>
</dd>
<dt id="exchangelib.Version.from_soap_header"><code class="name flex">
<span>def <span class="ident">from_soap_header</span></span>(<span>requested_api_version, header)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_soap_header(cls, requested_api_version, header):
    info = header.find(f&#34;{{{TNS}}}ServerVersionInfo&#34;)
    if info is None:
        info = header.find(f&#34;{{{ANS}}}ServerVersionInfo&#34;)
        if info is None:
            raise TransportError(f&#34;No ServerVersionInfo in header: {xml_to_str(header)!r}&#34;)
    try:
        build = Build.from_xml(elem=info)
    except ValueError:
        raise TransportError(f&#34;Bad ServerVersionInfo in response: {xml_to_str(header)!r}&#34;)
    # Not all Exchange servers send the Version element
    api_version_from_server = info.get(&#34;Version&#34;) or get_xml_attr(info, f&#34;{{{ANS}}}Version&#34;) or build.api_version()
    if api_version_from_server != requested_api_version:
        if cls._is_invalid_version_string(api_version_from_server):
            # For unknown reasons, Office 365 may respond with an API version strings that is invalid in a request.
            # Detect these, so we can fall back to a valid version string.
            log.debug(
                &#39;API version &#34;%s&#34; worked but server reports version &#34;%s&#34;. Using &#34;%s&#34;&#39;,
                requested_api_version,
                api_version_from_server,
                requested_api_version,
            )
            api_version_from_server = requested_api_version
        else:
            # Trust API version from server response
            log.debug(
                &#39;API version &#34;%s&#34; worked but server reports version &#34;%s&#34;. Using &#34;%s&#34;&#39;,
                requested_api_version,
                api_version_from_server,
                api_version_from_server,
            )
    return cls(build=build, api_version=api_version_from_server)</code></pre>
</details>
</dd>
<dt id="exchangelib.Version.guess"><code class="name flex">
<span>def <span class="ident">guess</span></span>(<span>protocol, api_version_hint=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Ask the server which version it has. We haven't set up an Account object yet, so we generate requests
by hand. We only need a response header containing a ServerVersionInfo element.</p>
<p>To get API version and build numbers from the server, we need to send a valid SOAP request. We can't do that
without a valid API version. To solve this chicken-and-egg problem, we try all possible API versions that this
package supports, until we get a valid response.</p>
<p>:param protocol:
:param api_version_hint:
(Default value = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def guess(cls, protocol, api_version_hint=None):
    &#34;&#34;&#34;Ask the server which version it has. We haven&#39;t set up an Account object yet, so we generate requests
    by hand. We only need a response header containing a ServerVersionInfo element.

    To get API version and build numbers from the server, we need to send a valid SOAP request. We can&#39;t do that
    without a valid API version. To solve this chicken-and-egg problem, we try all possible API versions that this
    package supports, until we get a valid response.

    :param protocol:
    :param api_version_hint:  (Default value = None)
    &#34;&#34;&#34;
    from .properties import ENTRY_ID, EWS_ID, AlternateId
    from .services import ConvertId

    # The protocol doesn&#39;t have a version yet, so default to the latest supported version if we don&#39;t have a hint.
    api_version = api_version_hint or ConvertId.supported_api_versions()[0]
    log.debug(&#34;Asking server for version info using API version %s&#34;, api_version)
    # We don&#39;t know the build version yet. Hopefully, the server will report it in the SOAP header. Lots of
    # places expect a version to have a build, so this is a bit dangerous, but passing a fake build around is also
    # dangerous.
    protocol.config.version = Version(build=None, api_version=api_version)
    # Use ConvertId as a minimal request to the server to test if the version is correct. If not, ConvertId will
    # try to guess the version automatically. Make sure the call to ConvertId does not require a version build.
    try:
        list(ConvertId(protocol=protocol).call([AlternateId(id=&#34;DUMMY&#34;, format=EWS_ID, mailbox=&#34;DUMMY&#34;)], ENTRY_ID))
    except ResponseMessageError as e:
        # We may have survived long enough to get a new version
        if not protocol.config.version.build:
            raise TransportError(f&#34;No valid version headers found in response ({e!r})&#34;)
    if not protocol.config.version.build:
        raise TransportError(&#34;No valid version headers found in response&#34;)
    return protocol.config.version</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Version.api_version"><code class="name">var <span class="ident">api_version</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Version.build"><code class="name">var <span class="ident">build</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Version.fullname"><code class="name">var <span class="ident">fullname</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fullname(self):
    for build, api_version, full_name in VERSIONS:
        if self.build and (
            self.build.major_version != build.major_version or self.build.minor_version != build.minor_version
        ):
            continue
        if self.api_version == api_version:
            return full_name
    log.warning(&#34;Full name for API version %s build %s is unknown&#34;, self.api_version, self.build)
    return &#34;UNKNOWN&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Version.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return self.__class__(build=self.build, api_version=self.api_version)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="exchangelib.account" href="account.html">exchangelib.account</a></code></li>
<li><code><a title="exchangelib.attachments" href="attachments.html">exchangelib.attachments</a></code></li>
<li><code><a title="exchangelib.autodiscover" href="autodiscover/index.html">exchangelib.autodiscover</a></code></li>
<li><code><a title="exchangelib.configuration" href="configuration.html">exchangelib.configuration</a></code></li>
<li><code><a title="exchangelib.credentials" href="credentials.html">exchangelib.credentials</a></code></li>
<li><code><a title="exchangelib.errors" href="errors.html">exchangelib.errors</a></code></li>
<li><code><a title="exchangelib.ewsdatetime" href="ewsdatetime.html">exchangelib.ewsdatetime</a></code></li>
<li><code><a title="exchangelib.extended_properties" href="extended_properties.html">exchangelib.extended_properties</a></code></li>
<li><code><a title="exchangelib.fields" href="fields.html">exchangelib.fields</a></code></li>
<li><code><a title="exchangelib.folders" href="folders/index.html">exchangelib.folders</a></code></li>
<li><code><a title="exchangelib.indexed_properties" href="indexed_properties.html">exchangelib.indexed_properties</a></code></li>
<li><code><a title="exchangelib.items" href="items/index.html">exchangelib.items</a></code></li>
<li><code><a title="exchangelib.properties" href="properties.html">exchangelib.properties</a></code></li>
<li><code><a title="exchangelib.protocol" href="protocol.html">exchangelib.protocol</a></code></li>
<li><code><a title="exchangelib.queryset" href="queryset.html">exchangelib.queryset</a></code></li>
<li><code><a title="exchangelib.recurrence" href="recurrence.html">exchangelib.recurrence</a></code></li>
<li><code><a title="exchangelib.restriction" href="restriction.html">exchangelib.restriction</a></code></li>
<li><code><a title="exchangelib.services" href="services/index.html">exchangelib.services</a></code></li>
<li><code><a title="exchangelib.settings" href="settings.html">exchangelib.settings</a></code></li>
<li><code><a title="exchangelib.transport" href="transport.html">exchangelib.transport</a></code></li>
<li><code><a title="exchangelib.util" href="util.html">exchangelib.util</a></code></li>
<li><code><a title="exchangelib.version" href="version.html">exchangelib.version</a></code></li>
<li><code><a title="exchangelib.winzone" href="winzone.html">exchangelib.winzone</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="exchangelib.UTC_NOW" href="#exchangelib.UTC_NOW">UTC_NOW</a></code></li>
<li><code><a title="exchangelib.close_connections" href="#exchangelib.close_connections">close_connections</a></code></li>
<li><code><a title="exchangelib.discover" href="#exchangelib.discover">discover</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.AcceptItem" href="#exchangelib.AcceptItem">AcceptItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.AcceptItem.ELEMENT_NAME" href="#exchangelib.AcceptItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Account" href="#exchangelib.Account">Account</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Account.admin_audit_logs" href="#exchangelib.Account.admin_audit_logs">admin_audit_logs</a></code></li>
<li><code><a title="exchangelib.Account.archive_deleted_items" href="#exchangelib.Account.archive_deleted_items">archive_deleted_items</a></code></li>
<li><code><a title="exchangelib.Account.archive_inbox" href="#exchangelib.Account.archive_inbox">archive_inbox</a></code></li>
<li><code><a title="exchangelib.Account.archive_msg_folder_root" href="#exchangelib.Account.archive_msg_folder_root">archive_msg_folder_root</a></code></li>
<li><code><a title="exchangelib.Account.archive_recoverable_items_deletions" href="#exchangelib.Account.archive_recoverable_items_deletions">archive_recoverable_items_deletions</a></code></li>
<li><code><a title="exchangelib.Account.archive_recoverable_items_purges" href="#exchangelib.Account.archive_recoverable_items_purges">archive_recoverable_items_purges</a></code></li>
<li><code><a title="exchangelib.Account.archive_recoverable_items_root" href="#exchangelib.Account.archive_recoverable_items_root">archive_recoverable_items_root</a></code></li>
<li><code><a title="exchangelib.Account.archive_recoverable_items_versions" href="#exchangelib.Account.archive_recoverable_items_versions">archive_recoverable_items_versions</a></code></li>
<li><code><a title="exchangelib.Account.archive_root" href="#exchangelib.Account.archive_root">archive_root</a></code></li>
<li><code><a title="exchangelib.Account.bulk_archive" href="#exchangelib.Account.bulk_archive">bulk_archive</a></code></li>
<li><code><a title="exchangelib.Account.bulk_copy" href="#exchangelib.Account.bulk_copy">bulk_copy</a></code></li>
<li><code><a title="exchangelib.Account.bulk_create" href="#exchangelib.Account.bulk_create">bulk_create</a></code></li>
<li><code><a title="exchangelib.Account.bulk_delete" href="#exchangelib.Account.bulk_delete">bulk_delete</a></code></li>
<li><code><a title="exchangelib.Account.bulk_mark_as_junk" href="#exchangelib.Account.bulk_mark_as_junk">bulk_mark_as_junk</a></code></li>
<li><code><a title="exchangelib.Account.bulk_move" href="#exchangelib.Account.bulk_move">bulk_move</a></code></li>
<li><code><a title="exchangelib.Account.bulk_send" href="#exchangelib.Account.bulk_send">bulk_send</a></code></li>
<li><code><a title="exchangelib.Account.bulk_update" href="#exchangelib.Account.bulk_update">bulk_update</a></code></li>
<li><code><a title="exchangelib.Account.calendar" href="#exchangelib.Account.calendar">calendar</a></code></li>
<li><code><a title="exchangelib.Account.conflicts" href="#exchangelib.Account.conflicts">conflicts</a></code></li>
<li><code><a title="exchangelib.Account.contacts" href="#exchangelib.Account.contacts">contacts</a></code></li>
<li><code><a title="exchangelib.Account.conversation_history" href="#exchangelib.Account.conversation_history">conversation_history</a></code></li>
<li><code><a title="exchangelib.Account.create_rule" href="#exchangelib.Account.create_rule">create_rule</a></code></li>
<li><code><a title="exchangelib.Account.delegates" href="#exchangelib.Account.delegates">delegates</a></code></li>
<li><code><a title="exchangelib.Account.delete_rule" href="#exchangelib.Account.delete_rule">delete_rule</a></code></li>
<li><code><a title="exchangelib.Account.directory" href="#exchangelib.Account.directory">directory</a></code></li>
<li><code><a title="exchangelib.Account.domain" href="#exchangelib.Account.domain">domain</a></code></li>
<li><code><a title="exchangelib.Account.drafts" href="#exchangelib.Account.drafts">drafts</a></code></li>
<li><code><a title="exchangelib.Account.export" href="#exchangelib.Account.export">export</a></code></li>
<li><code><a title="exchangelib.Account.favorites" href="#exchangelib.Account.favorites">favorites</a></code></li>
<li><code><a title="exchangelib.Account.fetch" href="#exchangelib.Account.fetch">fetch</a></code></li>
<li><code><a title="exchangelib.Account.fetch_personas" href="#exchangelib.Account.fetch_personas">fetch_personas</a></code></li>
<li><code><a title="exchangelib.Account.im_contact_list" href="#exchangelib.Account.im_contact_list">im_contact_list</a></code></li>
<li><code><a title="exchangelib.Account.inbox" href="#exchangelib.Account.inbox">inbox</a></code></li>
<li><code><a title="exchangelib.Account.journal" href="#exchangelib.Account.journal">journal</a></code></li>
<li><code><a title="exchangelib.Account.junk" href="#exchangelib.Account.junk">junk</a></code></li>
<li><code><a title="exchangelib.Account.local_failures" href="#exchangelib.Account.local_failures">local_failures</a></code></li>
<li><code><a title="exchangelib.Account.mail_tips" href="#exchangelib.Account.mail_tips">mail_tips</a></code></li>
<li><code><a title="exchangelib.Account.msg_folder_root" href="#exchangelib.Account.msg_folder_root">msg_folder_root</a></code></li>
<li><code><a title="exchangelib.Account.my_contacts" href="#exchangelib.Account.my_contacts">my_contacts</a></code></li>
<li><code><a title="exchangelib.Account.notes" href="#exchangelib.Account.notes">notes</a></code></li>
<li><code><a title="exchangelib.Account.oof_settings" href="#exchangelib.Account.oof_settings">oof_settings</a></code></li>
<li><code><a title="exchangelib.Account.outbox" href="#exchangelib.Account.outbox">outbox</a></code></li>
<li><code><a title="exchangelib.Account.people_connect" href="#exchangelib.Account.people_connect">people_connect</a></code></li>
<li><code><a title="exchangelib.Account.primary_smtp_address" href="#exchangelib.Account.primary_smtp_address">primary_smtp_address</a></code></li>
<li><code><a title="exchangelib.Account.public_folders_root" href="#exchangelib.Account.public_folders_root">public_folders_root</a></code></li>
<li><code><a title="exchangelib.Account.pull_subscription" href="#exchangelib.Account.pull_subscription">pull_subscription</a></code></li>
<li><code><a title="exchangelib.Account.push_subscription" href="#exchangelib.Account.push_subscription">push_subscription</a></code></li>
<li><code><a title="exchangelib.Account.quick_contacts" href="#exchangelib.Account.quick_contacts">quick_contacts</a></code></li>
<li><code><a title="exchangelib.Account.recipient_cache" href="#exchangelib.Account.recipient_cache">recipient_cache</a></code></li>
<li><code><a title="exchangelib.Account.recoverable_items_deletions" href="#exchangelib.Account.recoverable_items_deletions">recoverable_items_deletions</a></code></li>
<li><code><a title="exchangelib.Account.recoverable_items_purges" href="#exchangelib.Account.recoverable_items_purges">recoverable_items_purges</a></code></li>
<li><code><a title="exchangelib.Account.recoverable_items_root" href="#exchangelib.Account.recoverable_items_root">recoverable_items_root</a></code></li>
<li><code><a title="exchangelib.Account.recoverable_items_versions" href="#exchangelib.Account.recoverable_items_versions">recoverable_items_versions</a></code></li>
<li><code><a title="exchangelib.Account.root" href="#exchangelib.Account.root">root</a></code></li>
<li><code><a title="exchangelib.Account.rules" href="#exchangelib.Account.rules">rules</a></code></li>
<li><code><a title="exchangelib.Account.search_folders" href="#exchangelib.Account.search_folders">search_folders</a></code></li>
<li><code><a title="exchangelib.Account.sent" href="#exchangelib.Account.sent">sent</a></code></li>
<li><code><a title="exchangelib.Account.server_failures" href="#exchangelib.Account.server_failures">server_failures</a></code></li>
<li><code><a title="exchangelib.Account.set_rule" href="#exchangelib.Account.set_rule">set_rule</a></code></li>
<li><code><a title="exchangelib.Account.streaming_subscription" href="#exchangelib.Account.streaming_subscription">streaming_subscription</a></code></li>
<li><code><a title="exchangelib.Account.subscribe_to_pull" href="#exchangelib.Account.subscribe_to_pull">subscribe_to_pull</a></code></li>
<li><code><a title="exchangelib.Account.subscribe_to_push" href="#exchangelib.Account.subscribe_to_push">subscribe_to_push</a></code></li>
<li><code><a title="exchangelib.Account.subscribe_to_streaming" href="#exchangelib.Account.subscribe_to_streaming">subscribe_to_streaming</a></code></li>
<li><code><a title="exchangelib.Account.sync_issues" href="#exchangelib.Account.sync_issues">sync_issues</a></code></li>
<li><code><a title="exchangelib.Account.tasks" href="#exchangelib.Account.tasks">tasks</a></code></li>
<li><code><a title="exchangelib.Account.todo_search" href="#exchangelib.Account.todo_search">todo_search</a></code></li>
<li><code><a title="exchangelib.Account.trash" href="#exchangelib.Account.trash">trash</a></code></li>
<li><code><a title="exchangelib.Account.unsubscribe" href="#exchangelib.Account.unsubscribe">unsubscribe</a></code></li>
<li><code><a title="exchangelib.Account.upload" href="#exchangelib.Account.upload">upload</a></code></li>
<li><code><a title="exchangelib.Account.voice_mail" href="#exchangelib.Account.voice_mail">voice_mail</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Attendee" href="#exchangelib.Attendee">Attendee</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.Attendee.ELEMENT_NAME" href="#exchangelib.Attendee.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Attendee.FIELDS" href="#exchangelib.Attendee.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Attendee.RESPONSE_TYPES" href="#exchangelib.Attendee.RESPONSE_TYPES">RESPONSE_TYPES</a></code></li>
<li><code><a title="exchangelib.Attendee.last_response_time" href="#exchangelib.Attendee.last_response_time">last_response_time</a></code></li>
<li><code><a title="exchangelib.Attendee.mailbox" href="#exchangelib.Attendee.mailbox">mailbox</a></code></li>
<li><code><a title="exchangelib.Attendee.proposed_end" href="#exchangelib.Attendee.proposed_end">proposed_end</a></code></li>
<li><code><a title="exchangelib.Attendee.proposed_start" href="#exchangelib.Attendee.proposed_start">proposed_start</a></code></li>
<li><code><a title="exchangelib.Attendee.response_type" href="#exchangelib.Attendee.response_type">response_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.BaseProtocol" href="#exchangelib.BaseProtocol">BaseProtocol</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.BaseProtocol.CONNECTIONS_PER_SESSION" href="#exchangelib.BaseProtocol.CONNECTIONS_PER_SESSION">CONNECTIONS_PER_SESSION</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.HTTP_ADAPTER_CLS" href="#exchangelib.BaseProtocol.HTTP_ADAPTER_CLS">HTTP_ADAPTER_CLS</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.MAX_SESSION_USAGE_COUNT" href="#exchangelib.BaseProtocol.MAX_SESSION_USAGE_COUNT">MAX_SESSION_USAGE_COUNT</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.RETRY_WAIT" href="#exchangelib.BaseProtocol.RETRY_WAIT">RETRY_WAIT</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.SESSION_POOLSIZE" href="#exchangelib.BaseProtocol.SESSION_POOLSIZE">SESSION_POOLSIZE</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.TIMEOUT" href="#exchangelib.BaseProtocol.TIMEOUT">TIMEOUT</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.USERAGENT" href="#exchangelib.BaseProtocol.USERAGENT">USERAGENT</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.auth_type" href="#exchangelib.BaseProtocol.auth_type">auth_type</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.close" href="#exchangelib.BaseProtocol.close">close</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.close_session" href="#exchangelib.BaseProtocol.close_session">close_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.create_oauth2_session" href="#exchangelib.BaseProtocol.create_oauth2_session">create_oauth2_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.create_session" href="#exchangelib.BaseProtocol.create_session">create_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.credentials" href="#exchangelib.BaseProtocol.credentials">credentials</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.decrease_poolsize" href="#exchangelib.BaseProtocol.decrease_poolsize">decrease_poolsize</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.get_adapter" href="#exchangelib.BaseProtocol.get_adapter">get_adapter</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.get_auth_type" href="#exchangelib.BaseProtocol.get_auth_type">get_auth_type</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.get_session" href="#exchangelib.BaseProtocol.get_session">get_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.increase_poolsize" href="#exchangelib.BaseProtocol.increase_poolsize">increase_poolsize</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.max_connections" href="#exchangelib.BaseProtocol.max_connections">max_connections</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.raw_session" href="#exchangelib.BaseProtocol.raw_session">raw_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.refresh_credentials" href="#exchangelib.BaseProtocol.refresh_credentials">refresh_credentials</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.release_session" href="#exchangelib.BaseProtocol.release_session">release_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.renew_session" href="#exchangelib.BaseProtocol.renew_session">renew_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.retire_session" href="#exchangelib.BaseProtocol.retire_session">retire_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.retry_policy" href="#exchangelib.BaseProtocol.retry_policy">retry_policy</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.server" href="#exchangelib.BaseProtocol.server">server</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.service_endpoint" href="#exchangelib.BaseProtocol.service_endpoint">service_endpoint</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.session_pool_size" href="#exchangelib.BaseProtocol.session_pool_size">session_pool_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Body" href="#exchangelib.Body">Body</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Body.body_type" href="#exchangelib.Body.body_type">body_type</a></code></li>
<li><code><a title="exchangelib.Body.format" href="#exchangelib.Body.format">format</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Build" href="#exchangelib.Build">Build</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.Build.api_version" href="#exchangelib.Build.api_version">api_version</a></code></li>
<li><code><a title="exchangelib.Build.from_xml" href="#exchangelib.Build.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.Build.major_build" href="#exchangelib.Build.major_build">major_build</a></code></li>
<li><code><a title="exchangelib.Build.major_version" href="#exchangelib.Build.major_version">major_version</a></code></li>
<li><code><a title="exchangelib.Build.minor_build" href="#exchangelib.Build.minor_build">minor_build</a></code></li>
<li><code><a title="exchangelib.Build.minor_version" href="#exchangelib.Build.minor_version">minor_version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.CalendarItem" href="#exchangelib.CalendarItem">CalendarItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.CalendarItem.ELEMENT_NAME" href="#exchangelib.CalendarItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.CalendarItem.FIELDS" href="#exchangelib.CalendarItem.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.CalendarItem.adjacent_meeting_count" href="#exchangelib.CalendarItem.adjacent_meeting_count">adjacent_meeting_count</a></code></li>
<li><code><a title="exchangelib.CalendarItem.adjacent_meetings" href="#exchangelib.CalendarItem.adjacent_meetings">adjacent_meetings</a></code></li>
<li><code><a title="exchangelib.CalendarItem.allow_new_time_proposal" href="#exchangelib.CalendarItem.allow_new_time_proposal">allow_new_time_proposal</a></code></li>
<li><code><a title="exchangelib.CalendarItem.appointment_reply_time" href="#exchangelib.CalendarItem.appointment_reply_time">appointment_reply_time</a></code></li>
<li><code><a title="exchangelib.CalendarItem.appointment_sequence_number" href="#exchangelib.CalendarItem.appointment_sequence_number">appointment_sequence_number</a></code></li>
<li><code><a title="exchangelib.CalendarItem.appointment_state" href="#exchangelib.CalendarItem.appointment_state">appointment_state</a></code></li>
<li><code><a title="exchangelib.CalendarItem.cancel" href="#exchangelib.CalendarItem.cancel">cancel</a></code></li>
<li><code><a title="exchangelib.CalendarItem.clean" href="#exchangelib.CalendarItem.clean">clean</a></code></li>
<li><code><a title="exchangelib.CalendarItem.clean_timezone_fields" href="#exchangelib.CalendarItem.clean_timezone_fields">clean_timezone_fields</a></code></li>
<li><code><a title="exchangelib.CalendarItem.conference_type" href="#exchangelib.CalendarItem.conference_type">conference_type</a></code></li>
<li><code><a title="exchangelib.CalendarItem.conflicting_meeting_count" href="#exchangelib.CalendarItem.conflicting_meeting_count">conflicting_meeting_count</a></code></li>
<li><code><a title="exchangelib.CalendarItem.conflicting_meetings" href="#exchangelib.CalendarItem.conflicting_meetings">conflicting_meetings</a></code></li>
<li><code><a title="exchangelib.CalendarItem.date_to_datetime" href="#exchangelib.CalendarItem.date_to_datetime">date_to_datetime</a></code></li>
<li><code><a title="exchangelib.CalendarItem.deleted_occurrences" href="#exchangelib.CalendarItem.deleted_occurrences">deleted_occurrences</a></code></li>
<li><code><a title="exchangelib.CalendarItem.duration" href="#exchangelib.CalendarItem.duration">duration</a></code></li>
<li><code><a title="exchangelib.CalendarItem.end" href="#exchangelib.CalendarItem.end">end</a></code></li>
<li><code><a title="exchangelib.CalendarItem.first_occurrence" href="#exchangelib.CalendarItem.first_occurrence">first_occurrence</a></code></li>
<li><code><a title="exchangelib.CalendarItem.from_xml" href="#exchangelib.CalendarItem.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_all_day" href="#exchangelib.CalendarItem.is_all_day">is_all_day</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_cancelled" href="#exchangelib.CalendarItem.is_cancelled">is_cancelled</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_meeting" href="#exchangelib.CalendarItem.is_meeting">is_meeting</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_online_meeting" href="#exchangelib.CalendarItem.is_online_meeting">is_online_meeting</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_recurring" href="#exchangelib.CalendarItem.is_recurring">is_recurring</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_response_requested" href="#exchangelib.CalendarItem.is_response_requested">is_response_requested</a></code></li>
<li><code><a title="exchangelib.CalendarItem.last_occurrence" href="#exchangelib.CalendarItem.last_occurrence">last_occurrence</a></code></li>
<li><code><a title="exchangelib.CalendarItem.legacy_free_busy_status" href="#exchangelib.CalendarItem.legacy_free_busy_status">legacy_free_busy_status</a></code></li>
<li><code><a title="exchangelib.CalendarItem.location" href="#exchangelib.CalendarItem.location">location</a></code></li>
<li><code><a title="exchangelib.CalendarItem.meeting_request_was_sent" href="#exchangelib.CalendarItem.meeting_request_was_sent">meeting_request_was_sent</a></code></li>
<li><code><a title="exchangelib.CalendarItem.meeting_workspace_url" href="#exchangelib.CalendarItem.meeting_workspace_url">meeting_workspace_url</a></code></li>
<li><code><a title="exchangelib.CalendarItem.modified_occurrences" href="#exchangelib.CalendarItem.modified_occurrences">modified_occurrences</a></code></li>
<li><code><a title="exchangelib.CalendarItem.my_response_type" href="#exchangelib.CalendarItem.my_response_type">my_response_type</a></code></li>
<li><code><a title="exchangelib.CalendarItem.net_show_url" href="#exchangelib.CalendarItem.net_show_url">net_show_url</a></code></li>
<li><code><a title="exchangelib.CalendarItem.occurrence" href="#exchangelib.CalendarItem.occurrence">occurrence</a></code></li>
<li><code><a title="exchangelib.CalendarItem.optional_attendees" href="#exchangelib.CalendarItem.optional_attendees">optional_attendees</a></code></li>
<li><code><a title="exchangelib.CalendarItem.organizer" href="#exchangelib.CalendarItem.organizer">organizer</a></code></li>
<li><code><a title="exchangelib.CalendarItem.original_start" href="#exchangelib.CalendarItem.original_start">original_start</a></code></li>
<li><code><a title="exchangelib.CalendarItem.recurrence" href="#exchangelib.CalendarItem.recurrence">recurrence</a></code></li>
<li><code><a title="exchangelib.CalendarItem.recurrence_id" href="#exchangelib.CalendarItem.recurrence_id">recurrence_id</a></code></li>
<li><code><a title="exchangelib.CalendarItem.recurring_master" href="#exchangelib.CalendarItem.recurring_master">recurring_master</a></code></li>
<li><code><a title="exchangelib.CalendarItem.required_attendees" href="#exchangelib.CalendarItem.required_attendees">required_attendees</a></code></li>
<li><code><a title="exchangelib.CalendarItem.resources" href="#exchangelib.CalendarItem.resources">resources</a></code></li>
<li><code><a title="exchangelib.CalendarItem.start" href="#exchangelib.CalendarItem.start">start</a></code></li>
<li><code><a title="exchangelib.CalendarItem.timezone_fields" href="#exchangelib.CalendarItem.timezone_fields">timezone_fields</a></code></li>
<li><code><a title="exchangelib.CalendarItem.to_xml" href="#exchangelib.CalendarItem.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.CalendarItem.type" href="#exchangelib.CalendarItem.type">type</a></code></li>
<li><code><a title="exchangelib.CalendarItem.tz_field_for_field_name" href="#exchangelib.CalendarItem.tz_field_for_field_name">tz_field_for_field_name</a></code></li>
<li><code><a title="exchangelib.CalendarItem.uid" href="#exchangelib.CalendarItem.uid">uid</a></code></li>
<li><code><a title="exchangelib.CalendarItem.when" href="#exchangelib.CalendarItem.when">when</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.CancelCalendarItem" href="#exchangelib.CancelCalendarItem">CancelCalendarItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.CancelCalendarItem.ELEMENT_NAME" href="#exchangelib.CancelCalendarItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.CancelCalendarItem.FIELDS" href="#exchangelib.CancelCalendarItem.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.CancelCalendarItem.author_idx" href="#exchangelib.CancelCalendarItem.author_idx">author_idx</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Configuration" href="#exchangelib.Configuration">Configuration</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Configuration.credentials" href="#exchangelib.Configuration.credentials">credentials</a></code></li>
<li><code><a title="exchangelib.Configuration.server" href="#exchangelib.Configuration.server">server</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Contact" href="#exchangelib.Contact">Contact</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Contact.ELEMENT_NAME" href="#exchangelib.Contact.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Contact.FIELDS" href="#exchangelib.Contact.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Contact.assistant_name" href="#exchangelib.Contact.assistant_name">assistant_name</a></code></li>
<li><code><a title="exchangelib.Contact.birthday" href="#exchangelib.Contact.birthday">birthday</a></code></li>
<li><code><a title="exchangelib.Contact.business_homepage" href="#exchangelib.Contact.business_homepage">business_homepage</a></code></li>
<li><code><a title="exchangelib.Contact.children" href="#exchangelib.Contact.children">children</a></code></li>
<li><code><a title="exchangelib.Contact.companies" href="#exchangelib.Contact.companies">companies</a></code></li>
<li><code><a title="exchangelib.Contact.company_name" href="#exchangelib.Contact.company_name">company_name</a></code></li>
<li><code><a title="exchangelib.Contact.complete_name" href="#exchangelib.Contact.complete_name">complete_name</a></code></li>
<li><code><a title="exchangelib.Contact.contact_source" href="#exchangelib.Contact.contact_source">contact_source</a></code></li>
<li><code><a title="exchangelib.Contact.department" href="#exchangelib.Contact.department">department</a></code></li>
<li><code><a title="exchangelib.Contact.direct_reports" href="#exchangelib.Contact.direct_reports">direct_reports</a></code></li>
<li><code><a title="exchangelib.Contact.directory_id" href="#exchangelib.Contact.directory_id">directory_id</a></code></li>
<li><code><a title="exchangelib.Contact.display_name" href="#exchangelib.Contact.display_name">display_name</a></code></li>
<li><code><a title="exchangelib.Contact.email_addresses" href="#exchangelib.Contact.email_addresses">email_addresses</a></code></li>
<li><code><a title="exchangelib.Contact.email_alias" href="#exchangelib.Contact.email_alias">email_alias</a></code></li>
<li><code><a title="exchangelib.Contact.file_as" href="#exchangelib.Contact.file_as">file_as</a></code></li>
<li><code><a title="exchangelib.Contact.file_as_mapping" href="#exchangelib.Contact.file_as_mapping">file_as_mapping</a></code></li>
<li><code><a title="exchangelib.Contact.generation" href="#exchangelib.Contact.generation">generation</a></code></li>
<li><code><a title="exchangelib.Contact.given_name" href="#exchangelib.Contact.given_name">given_name</a></code></li>
<li><code><a title="exchangelib.Contact.has_picture" href="#exchangelib.Contact.has_picture">has_picture</a></code></li>
<li><code><a title="exchangelib.Contact.im_addresses" href="#exchangelib.Contact.im_addresses">im_addresses</a></code></li>
<li><code><a title="exchangelib.Contact.initials" href="#exchangelib.Contact.initials">initials</a></code></li>
<li><code><a title="exchangelib.Contact.job_title" href="#exchangelib.Contact.job_title">job_title</a></code></li>
<li><code><a title="exchangelib.Contact.manager" href="#exchangelib.Contact.manager">manager</a></code></li>
<li><code><a title="exchangelib.Contact.manager_mailbox" href="#exchangelib.Contact.manager_mailbox">manager_mailbox</a></code></li>
<li><code><a title="exchangelib.Contact.middle_name" href="#exchangelib.Contact.middle_name">middle_name</a></code></li>
<li><code><a title="exchangelib.Contact.mileage" href="#exchangelib.Contact.mileage">mileage</a></code></li>
<li><code><a title="exchangelib.Contact.ms_exchange_certificate" href="#exchangelib.Contact.ms_exchange_certificate">ms_exchange_certificate</a></code></li>
<li><code><a title="exchangelib.Contact.nickname" href="#exchangelib.Contact.nickname">nickname</a></code></li>
<li><code><a title="exchangelib.Contact.notes" href="#exchangelib.Contact.notes">notes</a></code></li>
<li><code><a title="exchangelib.Contact.office" href="#exchangelib.Contact.office">office</a></code></li>
<li><code><a title="exchangelib.Contact.phone_numbers" href="#exchangelib.Contact.phone_numbers">phone_numbers</a></code></li>
<li><code><a title="exchangelib.Contact.phonetic_first_name" href="#exchangelib.Contact.phonetic_first_name">phonetic_first_name</a></code></li>
<li><code><a title="exchangelib.Contact.phonetic_full_name" href="#exchangelib.Contact.phonetic_full_name">phonetic_full_name</a></code></li>
<li><code><a title="exchangelib.Contact.phonetic_last_name" href="#exchangelib.Contact.phonetic_last_name">phonetic_last_name</a></code></li>
<li><code><a title="exchangelib.Contact.photo" href="#exchangelib.Contact.photo">photo</a></code></li>
<li><code><a title="exchangelib.Contact.physical_addresses" href="#exchangelib.Contact.physical_addresses">physical_addresses</a></code></li>
<li><code><a title="exchangelib.Contact.postal_address_index" href="#exchangelib.Contact.postal_address_index">postal_address_index</a></code></li>
<li><code><a title="exchangelib.Contact.profession" href="#exchangelib.Contact.profession">profession</a></code></li>
<li><code><a title="exchangelib.Contact.spouse_name" href="#exchangelib.Contact.spouse_name">spouse_name</a></code></li>
<li><code><a title="exchangelib.Contact.surname" href="#exchangelib.Contact.surname">surname</a></code></li>
<li><code><a title="exchangelib.Contact.unique_body_idx" href="#exchangelib.Contact.unique_body_idx">unique_body_idx</a></code></li>
<li><code><a title="exchangelib.Contact.user_smime_certificate" href="#exchangelib.Contact.user_smime_certificate">user_smime_certificate</a></code></li>
<li><code><a title="exchangelib.Contact.wedding_anniversary" href="#exchangelib.Contact.wedding_anniversary">wedding_anniversary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Credentials" href="#exchangelib.Credentials">Credentials</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Credentials.DOMAIN" href="#exchangelib.Credentials.DOMAIN">DOMAIN</a></code></li>
<li><code><a title="exchangelib.Credentials.EMAIL" href="#exchangelib.Credentials.EMAIL">EMAIL</a></code></li>
<li><code><a title="exchangelib.Credentials.UPN" href="#exchangelib.Credentials.UPN">UPN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.DLMailbox" href="#exchangelib.DLMailbox">DLMailbox</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.DLMailbox.NAMESPACE" href="#exchangelib.DLMailbox.NAMESPACE">NAMESPACE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.DeclineItem" href="#exchangelib.DeclineItem">DeclineItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.DeclineItem.ELEMENT_NAME" href="#exchangelib.DeclineItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.DistributionList" href="#exchangelib.DistributionList">DistributionList</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.DistributionList.ELEMENT_NAME" href="#exchangelib.DistributionList.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.DistributionList.FIELDS" href="#exchangelib.DistributionList.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.DistributionList.contact_source" href="#exchangelib.DistributionList.contact_source">contact_source</a></code></li>
<li><code><a title="exchangelib.DistributionList.display_name" href="#exchangelib.DistributionList.display_name">display_name</a></code></li>
<li><code><a title="exchangelib.DistributionList.file_as" href="#exchangelib.DistributionList.file_as">file_as</a></code></li>
<li><code><a title="exchangelib.DistributionList.members" href="#exchangelib.DistributionList.members">members</a></code></li>
<li><code><a title="exchangelib.DistributionList.unique_body_idx" href="#exchangelib.DistributionList.unique_body_idx">unique_body_idx</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.EWSDate" href="#exchangelib.EWSDate">EWSDate</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.EWSDate.ewsformat" href="#exchangelib.EWSDate.ewsformat">ewsformat</a></code></li>
<li><code><a title="exchangelib.EWSDate.from_date" href="#exchangelib.EWSDate.from_date">from_date</a></code></li>
<li><code><a title="exchangelib.EWSDate.from_string" href="#exchangelib.EWSDate.from_string">from_string</a></code></li>
<li><code><a title="exchangelib.EWSDate.fromordinal" href="#exchangelib.EWSDate.fromordinal">fromordinal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.EWSDateTime" href="#exchangelib.EWSDateTime">EWSDateTime</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.EWSDateTime.astimezone" href="#exchangelib.EWSDateTime.astimezone">astimezone</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.date" href="#exchangelib.EWSDateTime.date">date</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.ewsformat" href="#exchangelib.EWSDateTime.ewsformat">ewsformat</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.from_datetime" href="#exchangelib.EWSDateTime.from_datetime">from_datetime</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.from_string" href="#exchangelib.EWSDateTime.from_string">from_string</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.fromisoformat" href="#exchangelib.EWSDateTime.fromisoformat">fromisoformat</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.fromtimestamp" href="#exchangelib.EWSDateTime.fromtimestamp">fromtimestamp</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.now" href="#exchangelib.EWSDateTime.now">now</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.utcfromtimestamp" href="#exchangelib.EWSDateTime.utcfromtimestamp">utcfromtimestamp</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.utcnow" href="#exchangelib.EWSDateTime.utcnow">utcnow</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.EWSTimeZone" href="#exchangelib.EWSTimeZone">EWSTimeZone</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.EWSTimeZone.IANA_TO_MS_MAP" href="#exchangelib.EWSTimeZone.IANA_TO_MS_MAP">IANA_TO_MS_MAP</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.MS_TO_IANA_MAP" href="#exchangelib.EWSTimeZone.MS_TO_IANA_MAP">MS_TO_IANA_MAP</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.from_datetime" href="#exchangelib.EWSTimeZone.from_datetime">from_datetime</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.from_dateutil" href="#exchangelib.EWSTimeZone.from_dateutil">from_dateutil</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.from_ms_id" href="#exchangelib.EWSTimeZone.from_ms_id">from_ms_id</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.from_pytz" href="#exchangelib.EWSTimeZone.from_pytz">from_pytz</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.from_timezone" href="#exchangelib.EWSTimeZone.from_timezone">from_timezone</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.from_zoneinfo" href="#exchangelib.EWSTimeZone.from_zoneinfo">from_zoneinfo</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.fromutc" href="#exchangelib.EWSTimeZone.fromutc">fromutc</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.localzone" href="#exchangelib.EWSTimeZone.localzone">localzone</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.ExtendedProperty" href="#exchangelib.ExtendedProperty">ExtendedProperty</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.ExtendedProperty.DISTINGUISHED_SETS" href="#exchangelib.ExtendedProperty.DISTINGUISHED_SETS">DISTINGUISHED_SETS</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.DISTINGUISHED_SET_ID_TO_NAME_MAP" href="#exchangelib.ExtendedProperty.DISTINGUISHED_SET_ID_TO_NAME_MAP">DISTINGUISHED_SET_ID_TO_NAME_MAP</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.DISTINGUISHED_SET_NAME_TO_ID_MAP" href="#exchangelib.ExtendedProperty.DISTINGUISHED_SET_NAME_TO_ID_MAP">DISTINGUISHED_SET_NAME_TO_ID_MAP</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.ELEMENT_NAME" href="#exchangelib.ExtendedProperty.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.PROPERTY_TYPES" href="#exchangelib.ExtendedProperty.PROPERTY_TYPES">PROPERTY_TYPES</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.as_object" href="#exchangelib.ExtendedProperty.as_object">as_object</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.clean" href="#exchangelib.ExtendedProperty.clean">clean</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.distinguished_property_set_id" href="#exchangelib.ExtendedProperty.distinguished_property_set_id">distinguished_property_set_id</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.from_xml" href="#exchangelib.ExtendedProperty.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.is_array_type" href="#exchangelib.ExtendedProperty.is_array_type">is_array_type</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.is_property_instance" href="#exchangelib.ExtendedProperty.is_property_instance">is_property_instance</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_id" href="#exchangelib.ExtendedProperty.property_id">property_id</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_name" href="#exchangelib.ExtendedProperty.property_name">property_name</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_set_id" href="#exchangelib.ExtendedProperty.property_set_id">property_set_id</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_tag" href="#exchangelib.ExtendedProperty.property_tag">property_tag</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_tag_as_hex" href="#exchangelib.ExtendedProperty.property_tag_as_hex">property_tag_as_hex</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_tag_as_int" href="#exchangelib.ExtendedProperty.property_tag_as_int">property_tag_as_int</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_type" href="#exchangelib.ExtendedProperty.property_type">property_type</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.python_type" href="#exchangelib.ExtendedProperty.python_type">python_type</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.to_xml" href="#exchangelib.ExtendedProperty.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.validate_cls" href="#exchangelib.ExtendedProperty.validate_cls">validate_cls</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.value" href="#exchangelib.ExtendedProperty.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.FailFast" href="#exchangelib.FailFast">FailFast</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.FaultTolerance" href="#exchangelib.FaultTolerance">FaultTolerance</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.FaultTolerance.DEFAULT_BACKOFF" href="#exchangelib.FaultTolerance.DEFAULT_BACKOFF">DEFAULT_BACKOFF</a></code></li>
<li><code><a title="exchangelib.FaultTolerance.back_off_until" href="#exchangelib.FaultTolerance.back_off_until">back_off_until</a></code></li>
<li><code><a title="exchangelib.FaultTolerance.raise_response_errors" href="#exchangelib.FaultTolerance.raise_response_errors">raise_response_errors</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.FileAttachment" href="#exchangelib.FileAttachment">FileAttachment</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.FileAttachment.ELEMENT_NAME" href="#exchangelib.FileAttachment.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.FileAttachment.FIELDS" href="#exchangelib.FileAttachment.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.FileAttachment.content" href="#exchangelib.FileAttachment.content">content</a></code></li>
<li><code><a title="exchangelib.FileAttachment.fp" href="#exchangelib.FileAttachment.fp">fp</a></code></li>
<li><code><a title="exchangelib.FileAttachment.from_xml" href="#exchangelib.FileAttachment.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.FileAttachment.is_contact_photo" href="#exchangelib.FileAttachment.is_contact_photo">is_contact_photo</a></code></li>
<li><code><a title="exchangelib.FileAttachment.to_xml" href="#exchangelib.FileAttachment.to_xml">to_xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Folder" href="#exchangelib.Folder">Folder</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.Folder.FIELDS" href="#exchangelib.Folder.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Folder.clean" href="#exchangelib.Folder.clean">clean</a></code></li>
<li><code><a title="exchangelib.Folder.effective_rights" href="#exchangelib.Folder.effective_rights">effective_rights</a></code></li>
<li><code><a title="exchangelib.Folder.from_xml_with_root" href="#exchangelib.Folder.from_xml_with_root">from_xml_with_root</a></code></li>
<li><code><a title="exchangelib.Folder.get_distinguished" href="#exchangelib.Folder.get_distinguished">get_distinguished</a></code></li>
<li><code><a title="exchangelib.Folder.permission_set" href="#exchangelib.Folder.permission_set">permission_set</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.FolderCollection" href="#exchangelib.FolderCollection">FolderCollection</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.FolderCollection.REQUIRED_FOLDER_FIELDS" href="#exchangelib.FolderCollection.REQUIRED_FOLDER_FIELDS">REQUIRED_FOLDER_FIELDS</a></code></li>
<li><code><a title="exchangelib.FolderCollection.allowed_item_fields" href="#exchangelib.FolderCollection.allowed_item_fields">allowed_item_fields</a></code></li>
<li><code><a title="exchangelib.FolderCollection.filter" href="#exchangelib.FolderCollection.filter">filter</a></code></li>
<li><code><a title="exchangelib.FolderCollection.find_folders" href="#exchangelib.FolderCollection.find_folders">find_folders</a></code></li>
<li><code><a title="exchangelib.FolderCollection.find_items" href="#exchangelib.FolderCollection.find_items">find_items</a></code></li>
<li><code><a title="exchangelib.FolderCollection.find_people" href="#exchangelib.FolderCollection.find_people">find_people</a></code></li>
<li><code><a title="exchangelib.FolderCollection.folders" href="#exchangelib.FolderCollection.folders">folders</a></code></li>
<li><code><a title="exchangelib.FolderCollection.get_folder_fields" href="#exchangelib.FolderCollection.get_folder_fields">get_folder_fields</a></code></li>
<li><code><a title="exchangelib.FolderCollection.get_folders" href="#exchangelib.FolderCollection.get_folders">get_folders</a></code></li>
<li><code><a title="exchangelib.FolderCollection.pull_subscription" href="#exchangelib.FolderCollection.pull_subscription">pull_subscription</a></code></li>
<li><code><a title="exchangelib.FolderCollection.push_subscription" href="#exchangelib.FolderCollection.push_subscription">push_subscription</a></code></li>
<li><code><a title="exchangelib.FolderCollection.resolve" href="#exchangelib.FolderCollection.resolve">resolve</a></code></li>
<li><code><a title="exchangelib.FolderCollection.streaming_subscription" href="#exchangelib.FolderCollection.streaming_subscription">streaming_subscription</a></code></li>
<li><code><a title="exchangelib.FolderCollection.subscribe_to_pull" href="#exchangelib.FolderCollection.subscribe_to_pull">subscribe_to_pull</a></code></li>
<li><code><a title="exchangelib.FolderCollection.subscribe_to_push" href="#exchangelib.FolderCollection.subscribe_to_push">subscribe_to_push</a></code></li>
<li><code><a title="exchangelib.FolderCollection.subscribe_to_streaming" href="#exchangelib.FolderCollection.subscribe_to_streaming">subscribe_to_streaming</a></code></li>
<li><code><a title="exchangelib.FolderCollection.supported_item_models" href="#exchangelib.FolderCollection.supported_item_models">supported_item_models</a></code></li>
<li><code><a title="exchangelib.FolderCollection.sync_hierarchy" href="#exchangelib.FolderCollection.sync_hierarchy">sync_hierarchy</a></code></li>
<li><code><a title="exchangelib.FolderCollection.sync_items" href="#exchangelib.FolderCollection.sync_items">sync_items</a></code></li>
<li><code><a title="exchangelib.FolderCollection.unsubscribe" href="#exchangelib.FolderCollection.unsubscribe">unsubscribe</a></code></li>
<li><code><a title="exchangelib.FolderCollection.validate_item_field" href="#exchangelib.FolderCollection.validate_item_field">validate_item_field</a></code></li>
<li><code><a title="exchangelib.FolderCollection.view" href="#exchangelib.FolderCollection.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.ForwardItem" href="#exchangelib.ForwardItem">ForwardItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.ForwardItem.ELEMENT_NAME" href="#exchangelib.ForwardItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.HTMLBody" href="#exchangelib.HTMLBody">HTMLBody</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.HTMLBody.body_type" href="#exchangelib.HTMLBody.body_type">body_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Identity" href="#exchangelib.Identity">Identity</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Identity.ELEMENT_NAME" href="#exchangelib.Identity.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Identity.FIELDS" href="#exchangelib.Identity.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Identity.primary_smtp_address" href="#exchangelib.Identity.primary_smtp_address">primary_smtp_address</a></code></li>
<li><code><a title="exchangelib.Identity.sid" href="#exchangelib.Identity.sid">sid</a></code></li>
<li><code><a title="exchangelib.Identity.smtp_address" href="#exchangelib.Identity.smtp_address">smtp_address</a></code></li>
<li><code><a title="exchangelib.Identity.upn" href="#exchangelib.Identity.upn">upn</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.ItemAttachment" href="#exchangelib.ItemAttachment">ItemAttachment</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.ItemAttachment.ELEMENT_NAME" href="#exchangelib.ItemAttachment.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.ItemAttachment.FIELDS" href="#exchangelib.ItemAttachment.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.ItemAttachment.from_xml" href="#exchangelib.ItemAttachment.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.ItemAttachment.item" href="#exchangelib.ItemAttachment.item">item</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.ItemId" href="#exchangelib.ItemId">ItemId</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.ItemId.CHANGEKEY_ATTR" href="#exchangelib.ItemId.CHANGEKEY_ATTR">CHANGEKEY_ATTR</a></code></li>
<li><code><a title="exchangelib.ItemId.ELEMENT_NAME" href="#exchangelib.ItemId.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.ItemId.FIELDS" href="#exchangelib.ItemId.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.ItemId.ID_ATTR" href="#exchangelib.ItemId.ID_ATTR">ID_ATTR</a></code></li>
<li><code><a title="exchangelib.ItemId.changekey" href="#exchangelib.ItemId.changekey">changekey</a></code></li>
<li><code><a title="exchangelib.ItemId.id" href="#exchangelib.ItemId.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Mailbox" href="#exchangelib.Mailbox">Mailbox</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Mailbox.ELEMENT_NAME" href="#exchangelib.Mailbox.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Mailbox.FIELDS" href="#exchangelib.Mailbox.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Mailbox.MAILBOX" href="#exchangelib.Mailbox.MAILBOX">MAILBOX</a></code></li>
<li><code><a title="exchangelib.Mailbox.MAILBOX_TYPE_CHOICES" href="#exchangelib.Mailbox.MAILBOX_TYPE_CHOICES">MAILBOX_TYPE_CHOICES</a></code></li>
<li><code><a title="exchangelib.Mailbox.ONE_OFF" href="#exchangelib.Mailbox.ONE_OFF">ONE_OFF</a></code></li>
<li><code><a title="exchangelib.Mailbox.clean" href="#exchangelib.Mailbox.clean">clean</a></code></li>
<li><code><a title="exchangelib.Mailbox.email_address" href="#exchangelib.Mailbox.email_address">email_address</a></code></li>
<li><code><a title="exchangelib.Mailbox.item_id" href="#exchangelib.Mailbox.item_id">item_id</a></code></li>
<li><code><a title="exchangelib.Mailbox.mailbox_type" href="#exchangelib.Mailbox.mailbox_type">mailbox_type</a></code></li>
<li><code><a title="exchangelib.Mailbox.name" href="#exchangelib.Mailbox.name">name</a></code></li>
<li><code><a title="exchangelib.Mailbox.routing_type" href="#exchangelib.Mailbox.routing_type">routing_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Message" href="#exchangelib.Message">Message</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Message.ELEMENT_NAME" href="#exchangelib.Message.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Message.FIELDS" href="#exchangelib.Message.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Message.author" href="#exchangelib.Message.author">author</a></code></li>
<li><code><a title="exchangelib.Message.bcc_recipients" href="#exchangelib.Message.bcc_recipients">bcc_recipients</a></code></li>
<li><code><a title="exchangelib.Message.cc_recipients" href="#exchangelib.Message.cc_recipients">cc_recipients</a></code></li>
<li><code><a title="exchangelib.Message.conversation_index" href="#exchangelib.Message.conversation_index">conversation_index</a></code></li>
<li><code><a title="exchangelib.Message.conversation_topic" href="#exchangelib.Message.conversation_topic">conversation_topic</a></code></li>
<li><code><a title="exchangelib.Message.create_reply" href="#exchangelib.Message.create_reply">create_reply</a></code></li>
<li><code><a title="exchangelib.Message.create_reply_all" href="#exchangelib.Message.create_reply_all">create_reply_all</a></code></li>
<li><code><a title="exchangelib.Message.is_delivery_receipt_requested" href="#exchangelib.Message.is_delivery_receipt_requested">is_delivery_receipt_requested</a></code></li>
<li><code><a title="exchangelib.Message.is_read" href="#exchangelib.Message.is_read">is_read</a></code></li>
<li><code><a title="exchangelib.Message.is_read_receipt_requested" href="#exchangelib.Message.is_read_receipt_requested">is_read_receipt_requested</a></code></li>
<li><code><a title="exchangelib.Message.is_response_requested" href="#exchangelib.Message.is_response_requested">is_response_requested</a></code></li>
<li><code><a title="exchangelib.Message.mark_as_junk" href="#exchangelib.Message.mark_as_junk">mark_as_junk</a></code></li>
<li><code><a title="exchangelib.Message.message_id" href="#exchangelib.Message.message_id">message_id</a></code></li>
<li><code><a title="exchangelib.Message.received_by" href="#exchangelib.Message.received_by">received_by</a></code></li>
<li><code><a title="exchangelib.Message.received_representing" href="#exchangelib.Message.received_representing">received_representing</a></code></li>
<li><code><a title="exchangelib.Message.references" href="#exchangelib.Message.references">references</a></code></li>
<li><code><a title="exchangelib.Message.reminder_message_data" href="#exchangelib.Message.reminder_message_data">reminder_message_data</a></code></li>
<li><code><a title="exchangelib.Message.reply" href="#exchangelib.Message.reply">reply</a></code></li>
<li><code><a title="exchangelib.Message.reply_all" href="#exchangelib.Message.reply_all">reply_all</a></code></li>
<li><code><a title="exchangelib.Message.reply_to" href="#exchangelib.Message.reply_to">reply_to</a></code></li>
<li><code><a title="exchangelib.Message.send" href="#exchangelib.Message.send">send</a></code></li>
<li><code><a title="exchangelib.Message.send_and_save" href="#exchangelib.Message.send_and_save">send_and_save</a></code></li>
<li><code><a title="exchangelib.Message.sender" href="#exchangelib.Message.sender">sender</a></code></li>
<li><code><a title="exchangelib.Message.to_recipients" href="#exchangelib.Message.to_recipients">to_recipients</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.NoVerifyHTTPAdapter" href="#exchangelib.NoVerifyHTTPAdapter">NoVerifyHTTPAdapter</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.NoVerifyHTTPAdapter.cert_verify" href="#exchangelib.NoVerifyHTTPAdapter.cert_verify">cert_verify</a></code></li>
<li><code><a title="exchangelib.NoVerifyHTTPAdapter.get_connection_with_tls_context" href="#exchangelib.NoVerifyHTTPAdapter.get_connection_with_tls_context">get_connection_with_tls_context</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.O365InteractiveConfiguration" href="#exchangelib.O365InteractiveConfiguration">O365InteractiveConfiguration</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.O365InteractiveConfiguration.SERVER" href="#exchangelib.O365InteractiveConfiguration.SERVER">SERVER</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.OAuth2AuthorizationCodeCredentials" href="#exchangelib.OAuth2AuthorizationCodeCredentials">OAuth2AuthorizationCodeCredentials</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.OAuth2Credentials" href="#exchangelib.OAuth2Credentials">OAuth2Credentials</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.OAuth2LegacyCredentials" href="#exchangelib.OAuth2LegacyCredentials">OAuth2LegacyCredentials</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.OofSettings" href="#exchangelib.OofSettings">OofSettings</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.OofSettings.DISABLED" href="#exchangelib.OofSettings.DISABLED">DISABLED</a></code></li>
<li><code><a title="exchangelib.OofSettings.ELEMENT_NAME" href="#exchangelib.OofSettings.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.OofSettings.ENABLED" href="#exchangelib.OofSettings.ENABLED">ENABLED</a></code></li>
<li><code><a title="exchangelib.OofSettings.FIELDS" href="#exchangelib.OofSettings.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.OofSettings.REQUEST_ELEMENT_NAME" href="#exchangelib.OofSettings.REQUEST_ELEMENT_NAME">REQUEST_ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.OofSettings.SCHEDULED" href="#exchangelib.OofSettings.SCHEDULED">SCHEDULED</a></code></li>
<li><code><a title="exchangelib.OofSettings.STATE_CHOICES" href="#exchangelib.OofSettings.STATE_CHOICES">STATE_CHOICES</a></code></li>
<li><code><a title="exchangelib.OofSettings.clean" href="#exchangelib.OofSettings.clean">clean</a></code></li>
<li><code><a title="exchangelib.OofSettings.end" href="#exchangelib.OofSettings.end">end</a></code></li>
<li><code><a title="exchangelib.OofSettings.external_audience" href="#exchangelib.OofSettings.external_audience">external_audience</a></code></li>
<li><code><a title="exchangelib.OofSettings.external_reply" href="#exchangelib.OofSettings.external_reply">external_reply</a></code></li>
<li><code><a title="exchangelib.OofSettings.from_xml" href="#exchangelib.OofSettings.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.OofSettings.internal_reply" href="#exchangelib.OofSettings.internal_reply">internal_reply</a></code></li>
<li><code><a title="exchangelib.OofSettings.start" href="#exchangelib.OofSettings.start">start</a></code></li>
<li><code><a title="exchangelib.OofSettings.state" href="#exchangelib.OofSettings.state">state</a></code></li>
<li><code><a title="exchangelib.OofSettings.to_xml" href="#exchangelib.OofSettings.to_xml">to_xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.PostItem" href="#exchangelib.PostItem">PostItem</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.PostItem.ELEMENT_NAME" href="#exchangelib.PostItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.PostItem.FIELDS" href="#exchangelib.PostItem.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.PostItem.author" href="#exchangelib.PostItem.author">author</a></code></li>
<li><code><a title="exchangelib.PostItem.conversation_index" href="#exchangelib.PostItem.conversation_index">conversation_index</a></code></li>
<li><code><a title="exchangelib.PostItem.conversation_topic" href="#exchangelib.PostItem.conversation_topic">conversation_topic</a></code></li>
<li><code><a title="exchangelib.PostItem.is_read" href="#exchangelib.PostItem.is_read">is_read</a></code></li>
<li><code><a title="exchangelib.PostItem.message_id" href="#exchangelib.PostItem.message_id">message_id</a></code></li>
<li><code><a title="exchangelib.PostItem.posted_time" href="#exchangelib.PostItem.posted_time">posted_time</a></code></li>
<li><code><a title="exchangelib.PostItem.references" href="#exchangelib.PostItem.references">references</a></code></li>
<li><code><a title="exchangelib.PostItem.sender" href="#exchangelib.PostItem.sender">sender</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.PostReplyItem" href="#exchangelib.PostReplyItem">PostReplyItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.PostReplyItem.ELEMENT_NAME" href="#exchangelib.PostReplyItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.FIELDS" href="#exchangelib.PostReplyItem.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.author" href="#exchangelib.PostReplyItem.author">author</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.bcc_recipients" href="#exchangelib.PostReplyItem.bcc_recipients">bcc_recipients</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.cc_recipients" href="#exchangelib.PostReplyItem.cc_recipients">cc_recipients</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.conversation_index" href="#exchangelib.PostReplyItem.conversation_index">conversation_index</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.conversation_topic" href="#exchangelib.PostReplyItem.conversation_topic">conversation_topic</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.culture_idx" href="#exchangelib.PostReplyItem.culture_idx">culture_idx</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.is_delivery_receipt_requested" href="#exchangelib.PostReplyItem.is_delivery_receipt_requested">is_delivery_receipt_requested</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.is_read" href="#exchangelib.PostReplyItem.is_read">is_read</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.is_read_receipt_requested" href="#exchangelib.PostReplyItem.is_read_receipt_requested">is_read_receipt_requested</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.is_response_requested" href="#exchangelib.PostReplyItem.is_response_requested">is_response_requested</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.message_id" href="#exchangelib.PostReplyItem.message_id">message_id</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.new_body" href="#exchangelib.PostReplyItem.new_body">new_body</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.received_by" href="#exchangelib.PostReplyItem.received_by">received_by</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.received_representing" href="#exchangelib.PostReplyItem.received_representing">received_representing</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.references" href="#exchangelib.PostReplyItem.references">references</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.reminder_message_data" href="#exchangelib.PostReplyItem.reminder_message_data">reminder_message_data</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.reply_to" href="#exchangelib.PostReplyItem.reply_to">reply_to</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.sender" href="#exchangelib.PostReplyItem.sender">sender</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.sender_idx" href="#exchangelib.PostReplyItem.sender_idx">sender_idx</a></code></li>
<li><code><a title="exchangelib.PostReplyItem.to_recipients" href="#exchangelib.PostReplyItem.to_recipients">to_recipients</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Q" href="#exchangelib.Q">Q</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.Q.AND" href="#exchangelib.Q.AND">AND</a></code></li>
<li><code><a title="exchangelib.Q.CONN_TYPES" href="#exchangelib.Q.CONN_TYPES">CONN_TYPES</a></code></li>
<li><code><a title="exchangelib.Q.CONTAINS" href="#exchangelib.Q.CONTAINS">CONTAINS</a></code></li>
<li><code><a title="exchangelib.Q.CONTAINS_OPS" href="#exchangelib.Q.CONTAINS_OPS">CONTAINS_OPS</a></code></li>
<li><code><a title="exchangelib.Q.EQ" href="#exchangelib.Q.EQ">EQ</a></code></li>
<li><code><a title="exchangelib.Q.EXACT" href="#exchangelib.Q.EXACT">EXACT</a></code></li>
<li><code><a title="exchangelib.Q.EXISTS" href="#exchangelib.Q.EXISTS">EXISTS</a></code></li>
<li><code><a title="exchangelib.Q.GT" href="#exchangelib.Q.GT">GT</a></code></li>
<li><code><a title="exchangelib.Q.GTE" href="#exchangelib.Q.GTE">GTE</a></code></li>
<li><code><a title="exchangelib.Q.ICONTAINS" href="#exchangelib.Q.ICONTAINS">ICONTAINS</a></code></li>
<li><code><a title="exchangelib.Q.IEXACT" href="#exchangelib.Q.IEXACT">IEXACT</a></code></li>
<li><code><a title="exchangelib.Q.ISTARTSWITH" href="#exchangelib.Q.ISTARTSWITH">ISTARTSWITH</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_CONTAINS" href="#exchangelib.Q.LOOKUP_CONTAINS">LOOKUP_CONTAINS</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_EXACT" href="#exchangelib.Q.LOOKUP_EXACT">LOOKUP_EXACT</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_EXISTS" href="#exchangelib.Q.LOOKUP_EXISTS">LOOKUP_EXISTS</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_GT" href="#exchangelib.Q.LOOKUP_GT">LOOKUP_GT</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_GTE" href="#exchangelib.Q.LOOKUP_GTE">LOOKUP_GTE</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_ICONTAINS" href="#exchangelib.Q.LOOKUP_ICONTAINS">LOOKUP_ICONTAINS</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_IEXACT" href="#exchangelib.Q.LOOKUP_IEXACT">LOOKUP_IEXACT</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_IN" href="#exchangelib.Q.LOOKUP_IN">LOOKUP_IN</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_ISTARTSWITH" href="#exchangelib.Q.LOOKUP_ISTARTSWITH">LOOKUP_ISTARTSWITH</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_LT" href="#exchangelib.Q.LOOKUP_LT">LOOKUP_LT</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_LTE" href="#exchangelib.Q.LOOKUP_LTE">LOOKUP_LTE</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_NOT" href="#exchangelib.Q.LOOKUP_NOT">LOOKUP_NOT</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_RANGE" href="#exchangelib.Q.LOOKUP_RANGE">LOOKUP_RANGE</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_STARTSWITH" href="#exchangelib.Q.LOOKUP_STARTSWITH">LOOKUP_STARTSWITH</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_TYPES" href="#exchangelib.Q.LOOKUP_TYPES">LOOKUP_TYPES</a></code></li>
<li><code><a title="exchangelib.Q.LT" href="#exchangelib.Q.LT">LT</a></code></li>
<li><code><a title="exchangelib.Q.LTE" href="#exchangelib.Q.LTE">LTE</a></code></li>
<li><code><a title="exchangelib.Q.NE" href="#exchangelib.Q.NE">NE</a></code></li>
<li><code><a title="exchangelib.Q.NEVER" href="#exchangelib.Q.NEVER">NEVER</a></code></li>
<li><code><a title="exchangelib.Q.NOT" href="#exchangelib.Q.NOT">NOT</a></code></li>
<li><code><a title="exchangelib.Q.OP_TYPES" href="#exchangelib.Q.OP_TYPES">OP_TYPES</a></code></li>
<li><code><a title="exchangelib.Q.OR" href="#exchangelib.Q.OR">OR</a></code></li>
<li><code><a title="exchangelib.Q.STARTSWITH" href="#exchangelib.Q.STARTSWITH">STARTSWITH</a></code></li>
<li><code><a title="exchangelib.Q.children" href="#exchangelib.Q.children">children</a></code></li>
<li><code><a title="exchangelib.Q.clean" href="#exchangelib.Q.clean">clean</a></code></li>
<li><code><a title="exchangelib.Q.conn_type" href="#exchangelib.Q.conn_type">conn_type</a></code></li>
<li><code><a title="exchangelib.Q.expr" href="#exchangelib.Q.expr">expr</a></code></li>
<li><code><a title="exchangelib.Q.field_path" href="#exchangelib.Q.field_path">field_path</a></code></li>
<li><code><a title="exchangelib.Q.is_empty" href="#exchangelib.Q.is_empty">is_empty</a></code></li>
<li><code><a title="exchangelib.Q.is_leaf" href="#exchangelib.Q.is_leaf">is_leaf</a></code></li>
<li><code><a title="exchangelib.Q.is_never" href="#exchangelib.Q.is_never">is_never</a></code></li>
<li><code><a title="exchangelib.Q.op" href="#exchangelib.Q.op">op</a></code></li>
<li><code><a title="exchangelib.Q.query_string" href="#exchangelib.Q.query_string">query_string</a></code></li>
<li><code><a title="exchangelib.Q.reduce" href="#exchangelib.Q.reduce">reduce</a></code></li>
<li><code><a title="exchangelib.Q.to_xml" href="#exchangelib.Q.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.Q.value" href="#exchangelib.Q.value">value</a></code></li>
<li><code><a title="exchangelib.Q.xml_elem" href="#exchangelib.Q.xml_elem">xml_elem</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.ReplyAllToItem" href="#exchangelib.ReplyAllToItem">ReplyAllToItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.ReplyAllToItem.ELEMENT_NAME" href="#exchangelib.ReplyAllToItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.ReplyToItem" href="#exchangelib.ReplyToItem">ReplyToItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.ReplyToItem.ELEMENT_NAME" href="#exchangelib.ReplyToItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Room" href="#exchangelib.Room">Room</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Room.ELEMENT_NAME" href="#exchangelib.Room.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Room.from_xml" href="#exchangelib.Room.from_xml">from_xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.RoomList" href="#exchangelib.RoomList">RoomList</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.RoomList.ELEMENT_NAME" href="#exchangelib.RoomList.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.RoomList.NAMESPACE" href="#exchangelib.RoomList.NAMESPACE">NAMESPACE</a></code></li>
<li><code><a title="exchangelib.RoomList.response_tag" href="#exchangelib.RoomList.response_tag">response_tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.RootOfHierarchy" href="#exchangelib.RootOfHierarchy">RootOfHierarchy</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.RootOfHierarchy.FIELDS" href="#exchangelib.RootOfHierarchy.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.WELLKNOWN_FOLDERS" href="#exchangelib.RootOfHierarchy.WELLKNOWN_FOLDERS">WELLKNOWN_FOLDERS</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.add_folder" href="#exchangelib.RootOfHierarchy.add_folder">add_folder</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.clear_cache" href="#exchangelib.RootOfHierarchy.clear_cache">clear_cache</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.effective_rights" href="#exchangelib.RootOfHierarchy.effective_rights">effective_rights</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.folder_cls_from_folder_name" href="#exchangelib.RootOfHierarchy.folder_cls_from_folder_name">folder_cls_from_folder_name</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.from_xml" href="#exchangelib.RootOfHierarchy.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.get_children" href="#exchangelib.RootOfHierarchy.get_children">get_children</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.get_default_folder" href="#exchangelib.RootOfHierarchy.get_default_folder">get_default_folder</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.get_distinguished" href="#exchangelib.RootOfHierarchy.get_distinguished">get_distinguished</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.get_folder" href="#exchangelib.RootOfHierarchy.get_folder">get_folder</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.remove_folder" href="#exchangelib.RootOfHierarchy.remove_folder">remove_folder</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.update_folder" href="#exchangelib.RootOfHierarchy.update_folder">update_folder</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.TLSClientAuth" href="#exchangelib.TLSClientAuth">TLSClientAuth</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.TLSClientAuth.cert_file" href="#exchangelib.TLSClientAuth.cert_file">cert_file</a></code></li>
<li><code><a title="exchangelib.TLSClientAuth.init_poolmanager" href="#exchangelib.TLSClientAuth.init_poolmanager">init_poolmanager</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Task" href="#exchangelib.Task">Task</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.Task.COMPLETED" href="#exchangelib.Task.COMPLETED">COMPLETED</a></code></li>
<li><code><a title="exchangelib.Task.ELEMENT_NAME" href="#exchangelib.Task.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Task.FIELDS" href="#exchangelib.Task.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Task.NOT_STARTED" href="#exchangelib.Task.NOT_STARTED">NOT_STARTED</a></code></li>
<li><code><a title="exchangelib.Task.actual_work" href="#exchangelib.Task.actual_work">actual_work</a></code></li>
<li><code><a title="exchangelib.Task.assigned_time" href="#exchangelib.Task.assigned_time">assigned_time</a></code></li>
<li><code><a title="exchangelib.Task.billing_information" href="#exchangelib.Task.billing_information">billing_information</a></code></li>
<li><code><a title="exchangelib.Task.change_count" href="#exchangelib.Task.change_count">change_count</a></code></li>
<li><code><a title="exchangelib.Task.clean" href="#exchangelib.Task.clean">clean</a></code></li>
<li><code><a title="exchangelib.Task.companies" href="#exchangelib.Task.companies">companies</a></code></li>
<li><code><a title="exchangelib.Task.complete" href="#exchangelib.Task.complete">complete</a></code></li>
<li><code><a title="exchangelib.Task.complete_date" href="#exchangelib.Task.complete_date">complete_date</a></code></li>
<li><code><a title="exchangelib.Task.contacts" href="#exchangelib.Task.contacts">contacts</a></code></li>
<li><code><a title="exchangelib.Task.delegation_state" href="#exchangelib.Task.delegation_state">delegation_state</a></code></li>
<li><code><a title="exchangelib.Task.delegator" href="#exchangelib.Task.delegator">delegator</a></code></li>
<li><code><a title="exchangelib.Task.due_date" href="#exchangelib.Task.due_date">due_date</a></code></li>
<li><code><a title="exchangelib.Task.is_complete" href="#exchangelib.Task.is_complete">is_complete</a></code></li>
<li><code><a title="exchangelib.Task.is_editable" href="#exchangelib.Task.is_editable">is_editable</a></code></li>
<li><code><a title="exchangelib.Task.is_recurring" href="#exchangelib.Task.is_recurring">is_recurring</a></code></li>
<li><code><a title="exchangelib.Task.is_team_task" href="#exchangelib.Task.is_team_task">is_team_task</a></code></li>
<li><code><a title="exchangelib.Task.mileage" href="#exchangelib.Task.mileage">mileage</a></code></li>
<li><code><a title="exchangelib.Task.owner" href="#exchangelib.Task.owner">owner</a></code></li>
<li><code><a title="exchangelib.Task.percent_complete" href="#exchangelib.Task.percent_complete">percent_complete</a></code></li>
<li><code><a title="exchangelib.Task.recurrence" href="#exchangelib.Task.recurrence">recurrence</a></code></li>
<li><code><a title="exchangelib.Task.start_date" href="#exchangelib.Task.start_date">start_date</a></code></li>
<li><code><a title="exchangelib.Task.status" href="#exchangelib.Task.status">status</a></code></li>
<li><code><a title="exchangelib.Task.status_description" href="#exchangelib.Task.status_description">status_description</a></code></li>
<li><code><a title="exchangelib.Task.total_work" href="#exchangelib.Task.total_work">total_work</a></code></li>
<li><code><a title="exchangelib.Task.unique_body_idx" href="#exchangelib.Task.unique_body_idx">unique_body_idx</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.TentativelyAcceptItem" href="#exchangelib.TentativelyAcceptItem">TentativelyAcceptItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.TentativelyAcceptItem.ELEMENT_NAME" href="#exchangelib.TentativelyAcceptItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.UID" href="#exchangelib.UID">UID</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.UID.to_global_object_id" href="#exchangelib.UID.to_global_object_id">to_global_object_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Version" href="#exchangelib.Version">Version</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.Version.all_versions" href="#exchangelib.Version.all_versions">all_versions</a></code></li>
<li><code><a title="exchangelib.Version.api_version" href="#exchangelib.Version.api_version">api_version</a></code></li>
<li><code><a title="exchangelib.Version.build" href="#exchangelib.Version.build">build</a></code></li>
<li><code><a title="exchangelib.Version.copy" href="#exchangelib.Version.copy">copy</a></code></li>
<li><code><a title="exchangelib.Version.from_soap_header" href="#exchangelib.Version.from_soap_header">from_soap_header</a></code></li>
<li><code><a title="exchangelib.Version.fullname" href="#exchangelib.Version.fullname">fullname</a></code></li>
<li><code><a title="exchangelib.Version.guess" href="#exchangelib.Version.guess">guess</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
