<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exchangelib.autodiscover API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exchangelib.autodiscover</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .cache import AutodiscoverCache, autodiscover_cache
from .discovery import Autodiscovery, discover
from .protocol import AutodiscoverProtocol


def close_connections():
    with autodiscover_cache:
        autodiscover_cache.close()


def clear_cache():
    with autodiscover_cache:
        autodiscover_cache.clear()


__all__ = [
    &#34;AutodiscoverCache&#34;,
    &#34;AutodiscoverProtocol&#34;,
    &#34;Autodiscovery&#34;,
    &#34;discover&#34;,
    &#34;autodiscover_cache&#34;,
    &#34;close_connections&#34;,
    &#34;clear_cache&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="exchangelib.autodiscover.cache" href="cache.html">exchangelib.autodiscover.cache</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.autodiscover.discovery" href="discovery.html">exchangelib.autodiscover.discovery</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.autodiscover.protocol" href="protocol.html">exchangelib.autodiscover.protocol</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="exchangelib.autodiscover.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache():
    with autodiscover_cache:
        autodiscover_cache.clear()</code></pre>
</details>
</dd>
<dt id="exchangelib.autodiscover.close_connections"><code class="name flex">
<span>def <span class="ident">close_connections</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_connections():
    with autodiscover_cache:
        autodiscover_cache.close()</code></pre>
</details>
</dd>
<dt id="exchangelib.autodiscover.discover"><code class="name flex">
<span>def <span class="ident">discover</span></span>(<span>email, credentials=None, auth_type=None, retry_policy=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover(email, credentials=None, auth_type=None, retry_policy=None):
    ad_response, protocol = Autodiscovery(email=email, credentials=credentials).discover()
    protocol.config.auth_typ = auth_type
    protocol.config.retry_policy = retry_policy
    return ad_response, protocol</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.autodiscover.AutodiscoverCache"><code class="flex name class">
<span>class <span class="ident">AutodiscoverCache</span></span>
</code></dt>
<dd>
<div class="desc"><p>Stores the translation from (email domain, credentials) -&gt; AutodiscoverProtocol object, so we can re-use TCP
connections to an autodiscover server within the same process. Also persists the email domain -&gt; (autodiscover
endpoint URL, auth_type) translation to the filesystem so the cache can be shared between multiple processes.</p>
<p>According to Microsoft, we may forever cache the (email domain -&gt; autodiscover endpoint URL) mapping, or until
it stops responding. My previous experience with Exchange products in mind, I'm not sure if I should trust that
advice. But it could save some valuable seconds every time we start a new connection to a known server. In any
case, the persistent storage must not contain any sensitive information since the cache could be readable by
unprivileged users. Domain, endpoint and auth_type are OK to cache since this info is make publicly available on
HTTP and DNS servers via the autodiscover protocol. Just don't persist any credential info.</p>
<p>If an autodiscover lookup fails for any reason, the corresponding cache entry must be purged.</p>
<p>'shelve' is supposedly thread-safe and process-safe, which suits our needs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AutodiscoverCache:
    &#34;&#34;&#34;Stores the translation from (email domain, credentials) -&gt; AutodiscoverProtocol object, so we can re-use TCP
    connections to an autodiscover server within the same process. Also persists the email domain -&gt; (autodiscover
    endpoint URL, auth_type) translation to the filesystem so the cache can be shared between multiple processes.

    According to Microsoft, we may forever cache the (email domain -&gt; autodiscover endpoint URL) mapping, or until
    it stops responding. My previous experience with Exchange products in mind, I&#39;m not sure if I should trust that
    advice. But it could save some valuable seconds every time we start a new connection to a known server. In any
    case, the persistent storage must not contain any sensitive information since the cache could be readable by
    unprivileged users. Domain, endpoint and auth_type are OK to cache since this info is make publicly available on
    HTTP and DNS servers via the autodiscover protocol. Just don&#39;t persist any credential info.

    If an autodiscover lookup fails for any reason, the corresponding cache entry must be purged.

    &#39;shelve&#39; is supposedly thread-safe and process-safe, which suits our needs.
    &#34;&#34;&#34;

    def __init__(self):
        self._protocols = {}  # Mapping from (domain, credentials) to AutodiscoverProtocol
        self._lock = RLock()

    @property
    def _storage_file(self):
        return AUTODISCOVER_PERSISTENT_STORAGE

    def clear(self):
        # Wipe the entire cache
        with shelve_open_with_failover(self._storage_file) as db:
            db.clear()
        self._protocols.clear()

    def __len__(self):
        return len(self._protocols)

    def __contains__(self, key):
        domain = key[0]
        with shelve_open_with_failover(self._storage_file) as db:
            return str(domain) in db

    def __getitem__(self, key):
        protocol = self._protocols.get(key)
        if protocol:
            return protocol
        domain, credentials = key
        with shelve_open_with_failover(self._storage_file) as db:
            endpoint, auth_type, retry_policy = db[str(domain)]  # It&#39;s OK to fail with KeyError here
        protocol = AutodiscoverProtocol(
            config=Configuration(
                service_endpoint=endpoint, credentials=credentials, auth_type=auth_type, retry_policy=retry_policy
            )
        )
        self._protocols[key] = protocol
        return protocol

    def __setitem__(self, key, protocol):
        # Populate both local and persistent cache
        domain = key[0]
        with shelve_open_with_failover(self._storage_file) as db:
            # Don&#39;t change this payload without bumping the cache file version in shelve_filename()
            db[str(domain)] = (protocol.service_endpoint, protocol.auth_type, protocol.retry_policy)
        self._protocols[key] = protocol

    def __delitem__(self, key):
        # Empty both local and persistent cache. Don&#39;t fail on non-existing entries because we could end here
        # multiple times due to race conditions.
        domain = key[0]
        with shelve_open_with_failover(self._storage_file) as db:
            with suppress(KeyError):
                del db[str(domain)]
        with suppress(KeyError):
            del self._protocols[key]

    def close(self):
        # Close all open connections
        for (domain, _), protocol in self._protocols.items():
            log.debug(&#34;Domain %s: Closing sessions&#34;, domain)
            protocol.close()
            del protocol
        self._protocols.clear()

    def __enter__(self):
        self._lock.__enter__()

    def __exit__(self, *args, **kwargs):
        self._lock.__exit__(*args, **kwargs)

    def __del__(self):
        # pylint: disable=bare-except
        try:
            self.close()
        except Exception:  # nosec
            # __del__ should never fail
            pass

    def __str__(self):
        return str(self._protocols)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.autodiscover.AutodiscoverCache.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    # Wipe the entire cache
    with shelve_open_with_failover(self._storage_file) as db:
        db.clear()
    self._protocols.clear()</code></pre>
</details>
</dd>
<dt id="exchangelib.autodiscover.AutodiscoverCache.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    # Close all open connections
    for (domain, _), protocol in self._protocols.items():
        log.debug(&#34;Domain %s: Closing sessions&#34;, domain)
        protocol.close()
        del protocol
    self._protocols.clear()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol"><code class="flex name class">
<span>class <span class="ident">AutodiscoverProtocol</span></span>
<span>(</span><span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Protocol which implements the bare essentials for autodiscover.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AutodiscoverProtocol(BaseProtocol):
    &#34;&#34;&#34;Protocol which implements the bare essentials for autodiscover.&#34;&#34;&#34;

    TIMEOUT = 10  # Seconds

    def __init__(self, config):
        if not config.version:
            # Default to the latest supported version
            config.version = Version.all_versions()[0]
        super().__init__(config=config)

    def __str__(self):
        return f&#34;&#34;&#34;\
Autodiscover endpoint: {self.service_endpoint}
Auth type: {self.auth_type}&#34;&#34;&#34;

    @property
    def version(self):
        return self.config.version

    @property
    def auth_type(self):
        # Autodetect authentication type if necessary
        if self.config.auth_type is None:
            self.config.auth_type = self.get_auth_type()
        return self.config.auth_type

    def get_auth_type(self):
        # Autodetect authentication type.
        return get_autodiscover_authtype(protocol=self)

    def get_user_settings(self, user, settings=None):
        if not settings:
            settings = [
                &#34;user_dn&#34;,
                &#34;mailbox_dn&#34;,
                &#34;user_display_name&#34;,
                &#34;auto_discover_smtp_address&#34;,
                &#34;external_ews_url&#34;,
                &#34;ews_supported_schemas&#34;,
            ]
        return GetUserSettings(protocol=self).get(users=[user], settings=settings)

    def dummy_xml(self):
        # Generate a valid EWS request for SOAP autodiscovery
        svc = GetUserSettings(protocol=self)
        return svc.wrap(
            content=svc.get_payload(
                users=[&#34;DUMMY@example.com&#34;],
                settings=[&#34;auto_discover_smtp_address&#34;],
            ),
            api_version=self.config.version.api_version,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.protocol.BaseProtocol" href="../protocol.html#exchangelib.protocol.BaseProtocol">BaseProtocol</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol.TIMEOUT"><code class="name">var <span class="ident">TIMEOUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol.auth_type"><code class="name">var <span class="ident">auth_type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def auth_type(self):
    # Autodetect authentication type if necessary
    if self.config.auth_type is None:
        self.config.auth_type = self.get_auth_type()
    return self.config.auth_type</code></pre>
</details>
</dd>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def version(self):
    return self.config.version</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol.dummy_xml"><code class="name flex">
<span>def <span class="ident">dummy_xml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dummy_xml(self):
    # Generate a valid EWS request for SOAP autodiscovery
    svc = GetUserSettings(protocol=self)
    return svc.wrap(
        content=svc.get_payload(
            users=[&#34;DUMMY@example.com&#34;],
            settings=[&#34;auto_discover_smtp_address&#34;],
        ),
        api_version=self.config.version.api_version,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.autodiscover.AutodiscoverProtocol.get_user_settings"><code class="name flex">
<span>def <span class="ident">get_user_settings</span></span>(<span>self, user, settings=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_user_settings(self, user, settings=None):
    if not settings:
        settings = [
            &#34;user_dn&#34;,
            &#34;mailbox_dn&#34;,
            &#34;user_display_name&#34;,
            &#34;auto_discover_smtp_address&#34;,
            &#34;external_ews_url&#34;,
            &#34;ews_supported_schemas&#34;,
        ]
    return GetUserSettings(protocol=self).get(users=[user], settings=settings)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.protocol.BaseProtocol" href="../protocol.html#exchangelib.protocol.BaseProtocol">BaseProtocol</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.protocol.BaseProtocol.HTTP_ADAPTER_CLS" href="../protocol.html#exchangelib.protocol.BaseProtocol.HTTP_ADAPTER_CLS">HTTP_ADAPTER_CLS</a></code></li>
<li><code><a title="exchangelib.protocol.BaseProtocol.decrease_poolsize" href="../protocol.html#exchangelib.protocol.BaseProtocol.decrease_poolsize">decrease_poolsize</a></code></li>
<li><code><a title="exchangelib.protocol.BaseProtocol.get_auth_type" href="../protocol.html#exchangelib.protocol.BaseProtocol.get_auth_type">get_auth_type</a></code></li>
<li><code><a title="exchangelib.protocol.BaseProtocol.increase_poolsize" href="../protocol.html#exchangelib.protocol.BaseProtocol.increase_poolsize">increase_poolsize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.autodiscover.Autodiscovery"><code class="flex name class">
<span>class <span class="ident">Autodiscovery</span></span>
<span>(</span><span>email, credentials=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Autodiscover is a Microsoft protocol for automatically getting the endpoint of the Exchange server and other
connection-related settings holding the email address using only the email address, and username and password of the
user.</p>
<p>For a description of the protocol implemented, see "Autodiscover for Exchange ActiveSync developers":</p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-interoperability-guidance/hh352638%28v%3dexchg.140%29">https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-interoperability-guidance/hh352638%28v%3dexchg.140%29</a></p>
<p>Descriptions of the steps from the article are provided in their respective methods in this class.</p>
<p>For a description of how to handle autodiscover error messages, see:</p>
<p><a href="https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/handling-autodiscover-error-messages">https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/handling-autodiscover-error-messages</a></p>
<p>A tip from the article:
The client can perform steps 1 through 4 in any order or in parallel to expedite the process, but it must wait for
responses to finish at each step before proceeding. Given that many organizations prefer to use the URL in step 2 to
set up the Autodiscover service, the client might try this step first.</p>
<p>Another possibly newer resource which has not yet been attempted is "Outlook 2016 Implementation of Autodiscover":
<a href="https://support.microsoft.com/en-us/help/3211279/outlook-2016-implementation-of-autodiscover">https://support.microsoft.com/en-us/help/3211279/outlook-2016-implementation-of-autodiscover</a></p>
<p>WARNING: The autodiscover protocol is very complicated. If you have problems autodiscovering using this
implementation, start by doing an official test at <a href="https://testconnectivity.microsoft.com">https://testconnectivity.microsoft.com</a></p>
<p>:param email: The email address to autodiscover
:param credentials: Credentials with authorization to make autodiscover lookups for this Account
(Default value = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Autodiscovery:
    &#34;&#34;&#34;Autodiscover is a Microsoft protocol for automatically getting the endpoint of the Exchange server and other
    connection-related settings holding the email address using only the email address, and username and password of the
    user.

    For a description of the protocol implemented, see &#34;Autodiscover for Exchange ActiveSync developers&#34;:

    https://docs.microsoft.com/en-us/previous-versions/office/developer/exchange-server-interoperability-guidance/hh352638%28v%3dexchg.140%29

    Descriptions of the steps from the article are provided in their respective methods in this class.

    For a description of how to handle autodiscover error messages, see:

    https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/handling-autodiscover-error-messages

    A tip from the article:
    The client can perform steps 1 through 4 in any order or in parallel to expedite the process, but it must wait for
    responses to finish at each step before proceeding. Given that many organizations prefer to use the URL in step 2 to
    set up the Autodiscover service, the client might try this step first.

    Another possibly newer resource which has not yet been attempted is &#34;Outlook 2016 Implementation of Autodiscover&#34;:
    https://support.microsoft.com/en-us/help/3211279/outlook-2016-implementation-of-autodiscover

    WARNING: The autodiscover protocol is very complicated. If you have problems autodiscovering using this
    implementation, start by doing an official test at https://testconnectivity.microsoft.com
    &#34;&#34;&#34;

    # When connecting to servers that may not be serving the correct endpoint, we should use a retry policy that does
    # not leave us hanging for a long time on each step in the protocol.
    INITIAL_RETRY_POLICY = FailFast()
    MAX_REDIRECTS = 10  # Maximum number of URL redirects before we give up
    DNS_RESOLVER_KWARGS = {}
    DNS_RESOLVER_ATTRS = {
        &#34;timeout&#34;: AutodiscoverProtocol.TIMEOUT / 2.5,  # Timeout for query to a single nameserver
    }
    DNS_RESOLVER_LIFETIME = AutodiscoverProtocol.TIMEOUT  # Total timeout for a query in case of multiple nameservers
    URL_PATH = &#34;autodiscover/autodiscover.svc&#34;

    def __init__(self, email, credentials=None):
        &#34;&#34;&#34;

        :param email: The email address to autodiscover
        :param credentials: Credentials with authorization to make autodiscover lookups for this Account
            (Default value = None)
        &#34;&#34;&#34;
        self.email = email
        self.credentials = credentials
        self._urls_visited = []  # Collects HTTP and Autodiscover redirects
        self._redirect_count = 0
        self._emails_visited = []  # Collects Autodiscover email redirects

    def discover(self):
        self._emails_visited.append(self.email.lower())

        # Check the autodiscover cache to see if we already know the autodiscover service endpoint for this email
        # domain. Use a lock to guard against multiple threads competing to cache information.
        log.debug(&#34;Waiting for autodiscover_cache lock&#34;)
        with autodiscover_cache:
            log.debug(&#34;autodiscover_cache lock acquired&#34;)
            cache_key = self._cache_key
            domain = get_domain(self.email)
            if cache_key in autodiscover_cache:
                ad_protocol = autodiscover_cache[cache_key]
                log.debug(&#34;Cache hit for key %s: %s&#34;, cache_key, ad_protocol.service_endpoint)
                try:
                    ad = self._quick(protocol=ad_protocol)
                except AutoDiscoverFailed:
                    # Autodiscover no longer works with this domain. Clear cache and try again after releasing the lock
                    log.debug(&#34;AD request failure. Removing cache for key %s&#34;, cache_key)
                    del autodiscover_cache[cache_key]
                    ad = self._step_1(hostname=domain)
            else:
                # This will cache the result
                log.debug(&#34;Cache miss for key %s&#34;, cache_key)
                ad = self._step_1(hostname=domain)

        log.debug(&#34;Released autodiscover_cache_lock&#34;)
        if ad.redirect_address:
            log.debug(&#34;Got a redirect address: %s&#34;, ad.redirect_address)
            if ad.redirect_address.lower() in self._emails_visited:
                raise AutoDiscoverCircularRedirect(&#34;We were redirected to an email address we have already seen&#34;)

            # Start over, but with the new email address
            self.email = ad.redirect_address
            return self.discover()

        # We successfully received a response. Clear the cache of seen emails etc.
        self.clear()
        return self._build_response(ad_response=ad)

    def clear(self):
        # This resets cached variables
        self._urls_visited = []
        self._redirect_count = 0
        self._emails_visited = []

    @property
    def _cache_key(self):
        # We may be using multiple different credentials and changing our minds on TLS verification. This key
        # combination should be safe for caching.
        domain = get_domain(self.email)
        return domain, self.credentials

    @threaded_cached_property
    def resolver(self):
        resolver = dns.resolver.Resolver(**self.DNS_RESOLVER_KWARGS)
        for k, v in self.DNS_RESOLVER_ATTRS.items():
            setattr(resolver, k, v)
        return resolver

    def _build_response(self, ad_response):
        if not ad_response.autodiscover_smtp_address:
            # Autodiscover does not always return an email address. In that case, the requesting email should be used
            ad_response.autodiscover_smtp_address = self.email

        protocol = Protocol(
            config=Configuration(
                service_endpoint=ad_response.ews_url,
                credentials=self.credentials,
                version=ad_response.version,
                # TODO: Detect EWS service auth type somehow
            )
        )
        return ad_response, protocol

    def _quick(self, protocol):
        try:
            user_response = protocol.get_user_settings(user=self.email)
        except TransportError as e:
            raise AutoDiscoverFailed(f&#34;Response error: {e}&#34;)
        return self._step_5(ad=user_response)

    def _redirect_url_is_valid(self, url):
        &#34;&#34;&#34;Three separate responses can be “Redirect responses”:
        * An HTTP status code (301, 302) with a new URL
        * An HTTP status code of 200, but with a payload XML containing a redirect to a different URL
        * An HTTP status code of 200, but with a payload XML containing a different SMTP address as the target address

        We only handle the HTTP 302 redirects here. We validate the URL received in the redirect response to ensure that
        it does not redirect to non-SSL endpoints or SSL endpoints with invalid certificates, and that the redirect is
        not circular. Finally, we should fail after 10 redirects.

        :param url:
        :return:
        &#34;&#34;&#34;
        if url.lower() in self._urls_visited:
            log.warning(&#34;We have already tried this URL: %s&#34;, url)
            return False

        if self._redirect_count &gt;= self.MAX_REDIRECTS:
            log.warning(&#34;We reached max redirects at URL: %s&#34;, url)
            return False

        # We require TLS endpoints
        if not url.startswith(&#34;https://&#34;):
            log.debug(&#34;Invalid scheme for URL: %s&#34;, url)
            return False

        # Quick test that the endpoint responds and that TLS handshake is OK
        try:
            self._get_unauthenticated_response(url, method=&#34;head&#34;)
        except TransportError as e:
            log.debug(&#34;Response error on redirect URL %s: %s&#34;, url, e)
            return False

        self._redirect_count += 1
        return True

    def _get_unauthenticated_response(self, url, method=&#34;post&#34;):
        &#34;&#34;&#34;Get response from server using the given HTTP method

        :param url:
        :return:
        &#34;&#34;&#34;
        # We are connecting to untrusted servers here, so take necessary precautions.
        self._ensure_valid_hostname(url)

        protocol = AutodiscoverProtocol(
            config=Configuration(
                service_endpoint=url,
                retry_policy=self.INITIAL_RETRY_POLICY,
            )
        )
        return None, get_unauthenticated_autodiscover_response(protocol=protocol, method=method)

    def _attempt_response(self, url):
        &#34;&#34;&#34;Return an (is_valid_response, response) tuple.

        :param url:
        :return:
        &#34;&#34;&#34;
        self._urls_visited.append(url.lower())
        log.debug(&#34;Attempting to get a valid response from %s&#34;, url)

        try:
            self._ensure_valid_hostname(url)
        except TransportError:
            return False, None

        protocol = AutodiscoverProtocol(
            config=Configuration(
                service_endpoint=url,
                credentials=self.credentials,
                retry_policy=self.INITIAL_RETRY_POLICY,
            )
        )
        try:
            user_response = protocol.get_user_settings(user=self.email)
        except RedirectError as e:
            if self._redirect_url_is_valid(url=e.url):
                # The protocol does not specify this explicitly, but by looking at how testconnectivity.microsoft.com
                # works, it seems that we should follow this URL now and try to get a valid response.
                return self._attempt_response(url=e.url)
            log.debug(&#34;Invalid redirect URL: %s&#34;, e.url)
            return False, None
        except TransportError as e:
            log.debug(&#34;Failed to get a response: %s&#34;, e)
            return False, None
        except CONNECTION_ERRORS as e:
            log.debug(&#34;Failed to get a response: %s&#34;, e)
            return False, None

        # We got a valid response. Unless this is a URL redirect response, we cache the result
        if not user_response.redirect_url:
            cache_key = self._cache_key
            log.debug(&#34;Adding cache entry for key %s: %s&#34;, cache_key, protocol.service_endpoint)
            autodiscover_cache[cache_key] = protocol
        return True, user_response

    def _ensure_valid_hostname(self, url):
        hostname = urlparse(url).netloc
        log.debug(&#34;Checking if %s can be looked up in DNS&#34;, hostname)
        try:
            self.resolver.resolve(f&#34;{hostname}.&#34;, &#34;A&#34;, lifetime=self.DNS_RESOLVER_LIFETIME)
        except DNS_LOOKUP_ERRORS as e:
            log.debug(&#34;DNS A lookup failure: %s&#34;, e)
            # &#39;requests&#39; is bad at reporting that a hostname cannot be resolved. Let&#39;s check this separately.
            # Don&#39;t retry on DNS errors. They will most likely be persistent.
            raise TransportError(f&#34;{hostname!r} has no DNS entry&#34;)

    def _get_srv_records(self, hostname):
        &#34;&#34;&#34;Send a DNS query for SRV entries for the hostname.

        An SRV entry that has been formatted for autodiscovery will have the following format:

            canonical name = mail.example.com.
            service = 8 100 443 webmail.example.com.

        The first three numbers in the service line are: priority, weight, port

        :param hostname:
        :return:
        &#34;&#34;&#34;
        log.debug(&#34;Attempting to get SRV records for %s&#34;, hostname)
        records = []
        try:
            answers = self.resolver.resolve(f&#34;{hostname}.&#34;, &#34;SRV&#34;, lifetime=self.DNS_RESOLVER_LIFETIME)
        except DNS_LOOKUP_ERRORS as e:
            log.debug(&#34;DNS SRV lookup failure: %s&#34;, e)
            return records
        for rdata in answers:
            try:
                vals = rdata.to_text().strip().rstrip(&#34;.&#34;).split(&#34; &#34;)
                # Raise ValueError if the first three are not ints, and IndexError if there are less than 4 values
                priority, weight, port, srv = int(vals[0]), int(vals[1]), int(vals[2]), vals[3]
                record = SrvRecord(priority=priority, weight=weight, port=port, srv=srv)
                log.debug(&#34;Found SRV record %s &#34;, record)
                records.append(record)
            except (ValueError, IndexError):
                log.debug(&#34;Incompatible SRV record for %s (%s)&#34;, hostname, rdata.to_text())
        return records

    def _step_1(self, hostname):
        &#34;&#34;&#34;Perform step 1, where the client sends an Autodiscover request to
        https://example.com/ and then does one of the following:
            * If the Autodiscover attempt succeeds, the client proceeds to step 5.
            * If the Autodiscover attempt fails, the client proceeds to step 2.

        :param hostname:
        :return:
        &#34;&#34;&#34;
        url = f&#34;https://{hostname}/{self.URL_PATH}&#34;
        log.info(&#34;Step 1: Trying autodiscover on %r with email %r&#34;, url, self.email)
        is_valid_response, ad = self._attempt_response(url=url)
        if is_valid_response:
            return self._step_5(ad=ad)
        return self._step_2(hostname=hostname)

    def _step_2(self, hostname):
        &#34;&#34;&#34;Perform step 2, where the client sends an Autodiscover request to
        https://autodiscover.example.com/ and then does one of the following:
            * If the Autodiscover attempt succeeds, the client proceeds to step 5.
            * If the Autodiscover attempt fails, the client proceeds to step 3.

        :param hostname:
        :return:
        &#34;&#34;&#34;
        url = f&#34;https://autodiscover.{hostname}/{self.URL_PATH}&#34;
        log.info(&#34;Step 2: Trying autodiscover on %r with email %r&#34;, url, self.email)
        is_valid_response, ad = self._attempt_response(url=url)
        if is_valid_response:
            return self._step_5(ad=ad)
        return self._step_3(hostname=hostname)

    def _step_3(self, hostname):
        &#34;&#34;&#34;Perform step 3, where the client sends an unauthenticated GET method request to
        http://autodiscover.example.com/ (Note that this is a non-HTTPS endpoint). The
        client then does one of the following:
            * If the GET request returns a 302 redirect response, it gets the redirection URL from the &#39;Location&#39; HTTP
            header and validates it as described in the &#34;Redirect responses&#34; section. The client then does one of the
            following:
                * If the redirection URL is valid, the client tries the URL and then does one of the following:
                    * If the attempt succeeds, the client proceeds to step 5.
                    * If the attempt fails, the client proceeds to step 4.
                * If the redirection URL is not valid, the client proceeds to step 4.
            * If the GET request does not return a 302 redirect response, the client proceeds to step 4.

        :param hostname:
        :return:
        &#34;&#34;&#34;
        url = f&#34;http://autodiscover.{hostname}/{self.URL_PATH}&#34;
        log.info(&#34;Step 3: Trying autodiscover on %r with email %r&#34;, url, self.email)
        try:
            _, r = self._get_unauthenticated_response(url=url, method=&#34;get&#34;)
        except TransportError:
            pass
        else:
            if r.status_code in (301, 302) and &#34;location&#34; in r.headers:
                redirect_url = get_redirect_url(r)
                if self._redirect_url_is_valid(url=redirect_url):
                    is_valid_response, ad = self._attempt_response(url=redirect_url)
                    if is_valid_response:
                        return self._step_5(ad=ad)
                    log.debug(&#34;Got invalid response&#34;)
                    return self._step_4(hostname=hostname)
                log.debug(&#34;Got invalid redirect URL&#34;)
                return self._step_4(hostname=hostname)
        log.debug(&#34;Got no redirect URL&#34;)
        return self._step_4(hostname=hostname)

    def _step_4(self, hostname):
        &#34;&#34;&#34;Perform step 4, where the client performs a Domain Name System (DNS) query for an SRV record for
        _autodiscover._tcp.example.com. The query might return multiple records. The client selects only records that
        point to an SSL endpoint and that have the highest priority and weight. One of the following actions then
        occurs:
            * If no such records are returned, the client proceeds to step 6.
            * If records are returned, the application randomly chooses a record in the list and validates the endpoint
              that it points to by following the process described in the &#34;Redirect Response&#34; section. The client then
              does one of the following:
                * If the redirection URL is valid, the client tries the URL and then does one of the following:
                    * If the attempt succeeds, the client proceeds to step 5.
                    * If the attempt fails, the client proceeds to step 6.
                * If the redirection URL is not valid, the client proceeds to step 6.

        :param hostname:
        :return:
        &#34;&#34;&#34;
        dns_hostname = f&#34;_autodiscover._tcp.{hostname}&#34;
        log.info(&#34;Step 4: Trying autodiscover on %r with email %r&#34;, dns_hostname, self.email)
        srv_records = self._get_srv_records(dns_hostname)
        try:
            srv_host = _select_srv_host(srv_records)
        except ValueError:
            srv_host = None
        if not srv_host:
            return self._step_6()
        redirect_url = f&#34;https://{srv_host}/{self.URL_PATH}&#34;
        if self._redirect_url_is_valid(url=redirect_url):
            is_valid_response, ad = self._attempt_response(url=redirect_url)
            if is_valid_response:
                return self._step_5(ad=ad)
            log.debug(&#34;Got invalid response&#34;)
            return self._step_6()
        log.debug(&#34;Got invalid redirect URL&#34;)
        return self._step_6()

    def _step_5(self, ad):
        &#34;&#34;&#34;Perform step 5. When a valid Autodiscover request succeeds, the following sequence occurs:
            * If the server responds with an HTTP 302 redirect, the client validates the redirection URL according to
              the process defined in the &#34;Redirect responses&#34; and then does one of the following:
                * If the redirection URL is valid, the client tries the URL and then does one of the following:
                    * If the attempt succeeds, the client repeats step 5 from the beginning.
                    * If the attempt fails, the client proceeds to step 6.
                * If the redirection URL is not valid, the client proceeds to step 6.
            * If the server responds with a valid Autodiscover response, the client does one of the following:
                * If the value of the Action element is &#34;Redirect&#34;, the client gets the redirection email address from
                  the Redirect element and then returns to step 1, using this new email address.
                * If the value of the Action element is &#34;Settings&#34;, the client has successfully received the requested
                  configuration settings for the specified user. The client does not need to proceed to step 6.

        :param ad:
        :return:
        &#34;&#34;&#34;
        log.info(&#34;Step 5: Checking response&#34;)
        # This is not explicit in the protocol, but let&#39;s raise any errors here
        ad.raise_errors()

        if ad.redirect_url:
            log.debug(&#34;Got a redirect URL: %s&#34;, ad.redirect_url)
            # We are diverging a bit from the protocol here. We will never get an HTTP 302 since earlier steps already
            # followed the redirects where possible. Instead, we handle redirect responses here.
            if self._redirect_url_is_valid(url=ad.redirect_url):
                is_valid_response, ad = self._attempt_response(url=ad.redirect_url)
                if is_valid_response:
                    return self._step_5(ad=ad)
                log.debug(&#34;Got invalid response&#34;)
                return self._step_6()
            log.debug(&#34;Invalid redirect URL&#34;)
            return self._step_6()
        # This could be an email redirect. Let outer layer handle this
        return ad

    def _step_6(self):
        &#34;&#34;&#34;Perform step 6. If the client cannot contact the Autodiscover service, the client should ask the user for
        the Exchange server name and use it to construct an Exchange EWS URL. The client should try to use this URL for
        future requests.
        &#34;&#34;&#34;
        raise AutoDiscoverFailed(
            f&#34;All steps in the autodiscover protocol failed for email {self.email}. If you think this is an error, &#34;
            f&#34;consider doing an official test at https://testconnectivity.microsoft.com&#34;
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.autodiscover.Autodiscovery.DNS_RESOLVER_ATTRS"><code class="name">var <span class="ident">DNS_RESOLVER_ATTRS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.autodiscover.Autodiscovery.DNS_RESOLVER_KWARGS"><code class="name">var <span class="ident">DNS_RESOLVER_KWARGS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.autodiscover.Autodiscovery.DNS_RESOLVER_LIFETIME"><code class="name">var <span class="ident">DNS_RESOLVER_LIFETIME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.autodiscover.Autodiscovery.INITIAL_RETRY_POLICY"><code class="name">var <span class="ident">INITIAL_RETRY_POLICY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.autodiscover.Autodiscovery.MAX_REDIRECTS"><code class="name">var <span class="ident">MAX_REDIRECTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.autodiscover.Autodiscovery.URL_PATH"><code class="name">var <span class="ident">URL_PATH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.autodiscover.Autodiscovery.resolver"><code class="name">var <span class="ident">resolver</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.autodiscover.Autodiscovery.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    # This resets cached variables
    self._urls_visited = []
    self._redirect_count = 0
    self._emails_visited = []</code></pre>
</details>
</dd>
<dt id="exchangelib.autodiscover.Autodiscovery.discover"><code class="name flex">
<span>def <span class="ident">discover</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover(self):
    self._emails_visited.append(self.email.lower())

    # Check the autodiscover cache to see if we already know the autodiscover service endpoint for this email
    # domain. Use a lock to guard against multiple threads competing to cache information.
    log.debug(&#34;Waiting for autodiscover_cache lock&#34;)
    with autodiscover_cache:
        log.debug(&#34;autodiscover_cache lock acquired&#34;)
        cache_key = self._cache_key
        domain = get_domain(self.email)
        if cache_key in autodiscover_cache:
            ad_protocol = autodiscover_cache[cache_key]
            log.debug(&#34;Cache hit for key %s: %s&#34;, cache_key, ad_protocol.service_endpoint)
            try:
                ad = self._quick(protocol=ad_protocol)
            except AutoDiscoverFailed:
                # Autodiscover no longer works with this domain. Clear cache and try again after releasing the lock
                log.debug(&#34;AD request failure. Removing cache for key %s&#34;, cache_key)
                del autodiscover_cache[cache_key]
                ad = self._step_1(hostname=domain)
        else:
            # This will cache the result
            log.debug(&#34;Cache miss for key %s&#34;, cache_key)
            ad = self._step_1(hostname=domain)

    log.debug(&#34;Released autodiscover_cache_lock&#34;)
    if ad.redirect_address:
        log.debug(&#34;Got a redirect address: %s&#34;, ad.redirect_address)
        if ad.redirect_address.lower() in self._emails_visited:
            raise AutoDiscoverCircularRedirect(&#34;We were redirected to an email address we have already seen&#34;)

        # Start over, but with the new email address
        self.email = ad.redirect_address
        return self.discover()

    # We successfully received a response. Clear the cache of seen emails etc.
    self.clear()
    return self._build_response(ad_response=ad)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exchangelib" href="../index.html">exchangelib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="exchangelib.autodiscover.cache" href="cache.html">exchangelib.autodiscover.cache</a></code></li>
<li><code><a title="exchangelib.autodiscover.discovery" href="discovery.html">exchangelib.autodiscover.discovery</a></code></li>
<li><code><a title="exchangelib.autodiscover.protocol" href="protocol.html">exchangelib.autodiscover.protocol</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="exchangelib.autodiscover.clear_cache" href="#exchangelib.autodiscover.clear_cache">clear_cache</a></code></li>
<li><code><a title="exchangelib.autodiscover.close_connections" href="#exchangelib.autodiscover.close_connections">close_connections</a></code></li>
<li><code><a title="exchangelib.autodiscover.discover" href="#exchangelib.autodiscover.discover">discover</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.autodiscover.AutodiscoverCache" href="#exchangelib.autodiscover.AutodiscoverCache">AutodiscoverCache</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.autodiscover.AutodiscoverCache.clear" href="#exchangelib.autodiscover.AutodiscoverCache.clear">clear</a></code></li>
<li><code><a title="exchangelib.autodiscover.AutodiscoverCache.close" href="#exchangelib.autodiscover.AutodiscoverCache.close">close</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.autodiscover.AutodiscoverProtocol" href="#exchangelib.autodiscover.AutodiscoverProtocol">AutodiscoverProtocol</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.autodiscover.AutodiscoverProtocol.TIMEOUT" href="#exchangelib.autodiscover.AutodiscoverProtocol.TIMEOUT">TIMEOUT</a></code></li>
<li><code><a title="exchangelib.autodiscover.AutodiscoverProtocol.auth_type" href="#exchangelib.autodiscover.AutodiscoverProtocol.auth_type">auth_type</a></code></li>
<li><code><a title="exchangelib.autodiscover.AutodiscoverProtocol.dummy_xml" href="#exchangelib.autodiscover.AutodiscoverProtocol.dummy_xml">dummy_xml</a></code></li>
<li><code><a title="exchangelib.autodiscover.AutodiscoverProtocol.get_user_settings" href="#exchangelib.autodiscover.AutodiscoverProtocol.get_user_settings">get_user_settings</a></code></li>
<li><code><a title="exchangelib.autodiscover.AutodiscoverProtocol.version" href="#exchangelib.autodiscover.AutodiscoverProtocol.version">version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.autodiscover.Autodiscovery" href="#exchangelib.autodiscover.Autodiscovery">Autodiscovery</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.autodiscover.Autodiscovery.DNS_RESOLVER_ATTRS" href="#exchangelib.autodiscover.Autodiscovery.DNS_RESOLVER_ATTRS">DNS_RESOLVER_ATTRS</a></code></li>
<li><code><a title="exchangelib.autodiscover.Autodiscovery.DNS_RESOLVER_KWARGS" href="#exchangelib.autodiscover.Autodiscovery.DNS_RESOLVER_KWARGS">DNS_RESOLVER_KWARGS</a></code></li>
<li><code><a title="exchangelib.autodiscover.Autodiscovery.DNS_RESOLVER_LIFETIME" href="#exchangelib.autodiscover.Autodiscovery.DNS_RESOLVER_LIFETIME">DNS_RESOLVER_LIFETIME</a></code></li>
<li><code><a title="exchangelib.autodiscover.Autodiscovery.INITIAL_RETRY_POLICY" href="#exchangelib.autodiscover.Autodiscovery.INITIAL_RETRY_POLICY">INITIAL_RETRY_POLICY</a></code></li>
<li><code><a title="exchangelib.autodiscover.Autodiscovery.MAX_REDIRECTS" href="#exchangelib.autodiscover.Autodiscovery.MAX_REDIRECTS">MAX_REDIRECTS</a></code></li>
<li><code><a title="exchangelib.autodiscover.Autodiscovery.URL_PATH" href="#exchangelib.autodiscover.Autodiscovery.URL_PATH">URL_PATH</a></code></li>
<li><code><a title="exchangelib.autodiscover.Autodiscovery.clear" href="#exchangelib.autodiscover.Autodiscovery.clear">clear</a></code></li>
<li><code><a title="exchangelib.autodiscover.Autodiscovery.discover" href="#exchangelib.autodiscover.Autodiscovery.discover">discover</a></code></li>
<li><code><a title="exchangelib.autodiscover.Autodiscovery.resolver" href="#exchangelib.autodiscover.Autodiscovery.resolver">resolver</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
